
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>PM synchronous motor transient analysis &#8212; PyAEDT Examples</title>

  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css\ansys_sphinx_theme.css?v=d2ac875c" />
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.23/css/jquery.dataTables.min.css" />
    <link rel="stylesheet" type="text/css" href="https://www.nerdfonts.com/assets/css/webfont.css" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/nbsphinx-code-cells.css?v=2aa19091" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom.css?v=9233c59b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/css/highlight.css?v=500661c4" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>
 
<link href="../../../../_static/css/breadcrumbs.css" rel="stylesheet" />

    <script src="../../../../_static/documentation_options.js?v=e7fb764e"></script>
    <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../../../_static/copybutton.js?v=49e1bf35"></script>
    <script src="../../../../_static/js\table.js?v=b64f5182"></script>
    <script src="https://cdn.datatables.net/1.10.23/js/jquery.dataTables.min.js"></script>
    <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'examples/low_frequency/motor/aedt_motor/pm_synchronous';</script>
    <link rel="icon" href="../../../../_static/ansys-favicon.png"/>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <link rel="canonical" href="https://examples.aedt.docs.pyansys.com/version/stable/examples/low_frequency/motor/aedt_motor/pm_synchronous.html" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container"><!-- Debugging: html_theme_options =  -->

  <!-- If there is no MeiliSearch enabled, use the PyData search -->
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

   
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="https://www.ansys.com/">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../_static/ansys_logo_transparent_black.png" class="logo__image only-light" alt="PyAEDT Examples - Home"/>
    <script>document.write(`<img src="../../../../_static/ansys_logo_transparent_white.png" class="logo__image only-dark" alt="PyAEDT Examples - Home"/>`);</script>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/ansys/pyaedt-examples" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/ansys/pyaedt-examples/discussions" title="Support" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa fa-comment fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Support</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
    

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/ansys/pyaedt-examples" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/ansys/pyaedt-examples/discussions" title="Support" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa fa-comment fa-fw fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Support</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">
<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">
         
    <li class="breadcrumb-item breadcrumb-home">
      <a href="https://docs.pyansys.com/" class="nav-link">PyAnsys</a>
    </li>
       
    <li class="breadcrumb-item">
      <a href="https://aedt.docs.pyansys.com/" class="nav-link">PyAEDT</a>
    </li>
     
    <li class="breadcrumb-item">
      <a
        href="../../../../index.html"
        class="nav-link"
        aria-label="Home"
      >
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
      
    <li class="breadcrumb-item active" aria-current="page">PM synchronous motor transient analysis</li>
    
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <div class="admonition-download-this-example admonition">
<p class="admonition-title">Download this example</p>
<p>Download this example as a <a class="reference external" href="https://examples.aedt.docs.pyansys.com/version/dev/examples/low_frequency/motor/aedt_motor/pm_synchronous.ipynb">Jupyter Notebook</a>
or as a <a class="reference external" href="https://examples.aedt.docs.pyansys.com/version/dev/examples/low_frequency/motor/aedt_motor/pm_synchronous.py">Python script</a>.</p>
</div>
<hr class="docutils" />
<section id="PM-synchronous-motor-transient-analysis">
<h1>PM synchronous motor transient analysis<a class="headerlink" href="#PM-synchronous-motor-transient-analysis" title="Link to this heading">#</a></h1>
<p>This example shows how to use PyAEDT to create a Maxwell 2D transient analysis for an interior permanent magnet (PM) electric motor.</p>
<p>Keywords: <strong>Maxwell 2D</strong>, <strong>transient</strong>, <strong>motor</strong>.</p>
<section id="Perform-imports-and-define-constants">
<h2>Perform imports and define constants<a class="headerlink" href="#Perform-imports-and-define-constants" title="Link to this heading">#</a></h2>
<p>Perform required imports.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">csv</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">attrgetter</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ansys.aedt.core</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ansys.aedt.core.examples.downloads</span><span class="w"> </span><span class="kn">import</span> <span class="n">download_leaf</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ansys.aedt.core.generic.constants</span><span class="w"> </span><span class="kn">import</span> <span class="n">unit_converter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">ansys.aedt.core.generic.numbers_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">Quantity</span>
<br/></pre></div>
</div>
</div>
<p>Define constants.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">AEDT_VERSION</span> <span class="o">=</span> <span class="s2">&quot;2025.2&quot;</span>
<span class="n">NUM_CORES</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">NG_MODE</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Open AEDT UI when it is launched.</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-temporary-directory-and-download-files">
<h2>Create temporary directory and download files<a class="headerlink" href="#Create-temporary-directory-and-download-files" title="Link to this heading">#</a></h2>
<p>Create a temporary directory where downloaded data or dumped data can be stored. If youâ€™d like to retrieve the project data for subsequent use, the temporary folder name is given by <code class="docutils literal notranslate"><span class="pre">temp_folder.name</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">temp_folder</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">TemporaryDirectory</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.ansys&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Initialize-dictionaries">
<h2>Initialize dictionaries<a class="headerlink" href="#Initialize-dictionaries" title="Link to this heading">#</a></h2>
<p>Dictionaries contain all the definitions for the design variables and output variables.</p>
</section>
<section id="Initialize-definitions-for-th-stator,-rotor,-and-shaft">
<h2>Initialize definitions for th stator, rotor, and shaft<a class="headerlink" href="#Initialize-definitions-for-th-stator,-rotor,-and-shaft" title="Link to this heading">#</a></h2>
<p>Initialize geometry parameter definitions for the stator, rotor, and shaft. The naming refers to RMxprt primitives.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">geom_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;DiaGap&quot;</span><span class="p">:</span> <span class="s2">&quot;132mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DiaStatorYoke&quot;</span><span class="p">:</span> <span class="s2">&quot;198mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DiaStatorInner&quot;</span><span class="p">:</span> <span class="s2">&quot;132mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DiaRotorLam&quot;</span><span class="p">:</span> <span class="s2">&quot;130mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DiaShaft&quot;</span><span class="p">:</span> <span class="s2">&quot;44.45mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;DiaOuter&quot;</span><span class="p">:</span> <span class="s2">&quot;198mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Airgap&quot;</span><span class="p">:</span> <span class="s2">&quot;1mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SlotNumber&quot;</span><span class="p">:</span> <span class="s2">&quot;48&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SlotType&quot;</span><span class="p">:</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Initialize-definitions-for-stator-windings">
<h2>Initialize definitions for stator windings<a class="headerlink" href="#Initialize-definitions-for-stator-windings" title="Link to this heading">#</a></h2>
<p>Initialize geometry parameter definitions for the stator windings. The naming refers to RMxprt primitives.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">wind_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;Layers&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ParallelPaths&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;R_Phase&quot;</span><span class="p">:</span> <span class="s2">&quot;7.5mOhm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;WdgExt_F&quot;</span><span class="p">:</span> <span class="s2">&quot;5mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SpanExt&quot;</span><span class="p">:</span> <span class="s2">&quot;30mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SegAngle&quot;</span><span class="p">:</span> <span class="s2">&quot;0.25&quot;</span><span class="p">,</span>
    <span class="s2">&quot;CoilPitch&quot;</span><span class="p">:</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span>  <span class="c1"># coil pitch in slots</span>
    <span class="s2">&quot;Coil_SetBack&quot;</span><span class="p">:</span> <span class="s2">&quot;3.605732823mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SlotWidth&quot;</span><span class="p">:</span> <span class="s2">&quot;2.814mm&quot;</span><span class="p">,</span>  <span class="c1"># RMxprt Bs0</span>
    <span class="s2">&quot;Coil_Edge_Short&quot;</span><span class="p">:</span> <span class="s2">&quot;3.769235435mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Coil_Edge_Long&quot;</span><span class="p">:</span> <span class="s2">&quot;15.37828521mm&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Initialize-definitions-for-model-setup">
<h2>Initialize definitions for model setup<a class="headerlink" href="#Initialize-definitions-for-model-setup" title="Link to this heading">#</a></h2>
<p>Initialize geometry parameter definitions for the model setup.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mod_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;NumPoles&quot;</span><span class="p">:</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Model_Length&quot;</span><span class="p">:</span> <span class="s2">&quot;80mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SymmetryFactor&quot;</span><span class="p">:</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Magnetic_Axial_Length&quot;</span><span class="p">:</span> <span class="s2">&quot;150mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Stator_Lam_Length&quot;</span><span class="p">:</span> <span class="s2">&quot;0mm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StatorSkewAngle&quot;</span><span class="p">:</span> <span class="s2">&quot;0deg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;NumTorquePointsPerCycle&quot;</span><span class="p">:</span> <span class="s2">&quot;30&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mapping_angle&quot;</span><span class="p">:</span> <span class="s2">&quot;0.125*4deg&quot;</span><span class="p">,</span>
    <span class="s2">&quot;num_m&quot;</span><span class="p">:</span> <span class="s2">&quot;16&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Section_Angle&quot;</span><span class="p">:</span> <span class="s2">&quot;360deg/SymmetryFactor&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Initialize-definitions-for-operational-machine">
<h2>Initialize definitions for operational machine<a class="headerlink" href="#Initialize-definitions-for-operational-machine" title="Link to this heading">#</a></h2>
<p>Initialize geometry parameter definitions for the operational machine. This identifies the operating point for the transient setup.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">oper_params</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;InitialPositionMD&quot;</span><span class="p">:</span> <span class="s2">&quot;180deg/4&quot;</span><span class="p">,</span>
    <span class="s2">&quot;IPeak&quot;</span><span class="p">:</span> <span class="s2">&quot;480A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;MachineRPM&quot;</span><span class="p">:</span> <span class="s2">&quot;3000rpm&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ElectricFrequency&quot;</span><span class="p">:</span> <span class="s2">&quot;MachineRPM/60rpm*NumPoles/2*1Hz&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ElectricPeriod&quot;</span><span class="p">:</span> <span class="s2">&quot;1/ElectricFrequency&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BandTicksinModel&quot;</span><span class="p">:</span> <span class="s2">&quot;360deg/NumPoles/mapping_angle&quot;</span><span class="p">,</span>
    <span class="s2">&quot;TimeStep&quot;</span><span class="p">:</span> <span class="s2">&quot;ElectricPeriod/(2*BandTicksinModel)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;StopTime&quot;</span><span class="p">:</span> <span class="s2">&quot;ElectricPeriod&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Theta_i&quot;</span><span class="p">:</span> <span class="s2">&quot;135deg&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Launch-AEDT-and-Maxwell-2D">
<h2>Launch AEDT and Maxwell 2D<a class="headerlink" href="#Launch-AEDT-and-Maxwell-2D" title="Link to this heading">#</a></h2>
<p>Launch AEDT and Maxwell 2D after first setting up the project and design names, the solver, and the version. The following code also creates an instance of the <code class="docutils literal notranslate"><span class="pre">Maxwell2d</span></code> class named <code class="docutils literal notranslate"><span class="pre">m2d</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">project_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_folder</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;PM_Motor.aedt&quot;</span><span class="p">)</span>
<span class="n">m2d</span> <span class="o">=</span> <span class="n">ansys</span><span class="o">.</span><span class="n">aedt</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Maxwell2d</span><span class="p">(</span>
    <span class="n">project</span><span class="o">=</span><span class="n">project_name</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="n">AEDT_VERSION</span><span class="p">,</span>
    <span class="n">design</span><span class="o">=</span><span class="s2">&quot;Sinusoidal&quot;</span><span class="p">,</span>
    <span class="n">solution_type</span><span class="o">=</span><span class="s2">&quot;TransientXY&quot;</span><span class="p">,</span>
    <span class="n">new_desktop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">non_graphical</span><span class="o">=</span><span class="n">NG_MODE</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Python version 3.10.11 (tags/v3.10.11:7d4cc5a, Apr  5 2023, 00:38:17) [MSC v.1929 64 bit (AMD64)].
PyAEDT INFO: PyAEDT version 0.25.dev0.
PyAEDT INFO: Initializing new Desktop session.
PyAEDT INFO: Log on console is enabled.
PyAEDT INFO: Log on file C:\Users\ansys\AppData\Local\Temp\pyaedt_ansys_e49b3071-d3fa-4ec3-88f1-f6e471bc1fe7.log is enabled.
PyAEDT INFO: Log on AEDT is disabled.
PyAEDT INFO: Starting new AEDT gRPC session.
PyAEDT INFO: AEDT installation Path C:\Program Files\ANSYS Inc\v252\AnsysEM
PyAEDT INFO: Client application successfully started.
PyAEDT INFO: New AEDT gRPC session session started on port 50051.
PyAEDT INFO: 2025.2 version started with process ID 3652.
PyAEDT WARNING: Service Pack is not detected. PyAEDT is currently connecting in Insecure Mode.
PyAEDT WARNING: Please download and install latest Service Pack to use connect to AEDT in Secure Mode.
PyAEDT INFO: Debug logger is disabled. PyAEDT methods will not be logged.
PyAEDT INFO: Project PM_Motor has been created.
PyAEDT INFO: Added design &#39;Sinusoidal&#39; of type Maxwell 2D.
PyAEDT INFO: Aedt Objects correctly read
</pre></div></div>
</div>
</section>
<section id="Define-modeler-units">
<h2>Define modeler units<a class="headerlink" href="#Define-modeler-units" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">model_units</span> <span class="o">=</span> <span class="s2">&quot;mm&quot;</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Modeler2D class has been initialized!
PyAEDT INFO: Modeler class has been initialized! Elapsed time: 0m 0sec
</pre></div></div>
</div>
</section>
<section id="Define-variables-from-dictionaries">
<h2>Define variables from dictionaries<a class="headerlink" href="#Define-variables-from-dictionaries" title="Link to this heading">#</a></h2>
<p>Define design variables from the created dictionaries.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">geom_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">m2d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">wind_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">m2d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mod_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">m2d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">oper_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">m2d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
</pre></div>
</div>
</div>
</section>
<section id="Define-path-for-non-linear-material-properties">
<h2>Define path for non-linear material properties<a class="headerlink" href="#Define-path-for-non-linear-material-properties" title="Link to this heading">#</a></h2>
<p>Define the path for non-linear material properties. Materials are stored in text files.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">filename_lam</span><span class="p">,</span> <span class="n">filename_PM</span> <span class="o">=</span> <span class="n">download_leaf</span><span class="p">(</span><span class="n">local_path</span><span class="o">=</span><span class="n">temp_folder</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-first-material">
<h2>Create first material<a class="headerlink" href="#Create-first-material" title="Link to this heading">#</a></h2>
<p>Create the material <code class="docutils literal notranslate"><span class="pre">&quot;Copper</span> <span class="pre">(Annealed)_65C&quot;</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mat_coils</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">add_material</span><span class="p">(</span><span class="s2">&quot;Copper (Annealed)_65C&quot;</span><span class="p">)</span>
<span class="n">mat_coils</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">mat_coils</span><span class="o">.</span><span class="n">conductivity</span> <span class="o">=</span> <span class="s2">&quot;49288048.9198&quot;</span>
<span class="n">mat_coils</span><span class="o">.</span><span class="n">permeability</span> <span class="o">=</span> <span class="s2">&quot;1&quot;</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Materials class has been initialized! Elapsed time: 0m 0sec
PyAEDT INFO: Adding new material to the Project Library: Copper (Annealed)_65C
PyAEDT INFO: Material has been added in Desktop.
</pre></div></div>
</div>
</section>
<section id="Create-materials-with-a-non-linear-permeability">
<h2>Create materials with a non-linear permeability<a class="headerlink" href="#Create-materials-with-a-non-linear-permeability" title="Link to this heading">#</a></h2>
<p>Below there are two examples of how to create materials with a non-linear permeability. The first example imports the BH curve as a 1d dataset in the project. The second example reads the BH curve from a tabbed CSV file.</p>
<p>Create second material <code class="docutils literal notranslate"><span class="pre">&quot;Arnold_Magnetics_N30UH_80C&quot;</span></code>. The BH curve is imported as a 1d dataset in the project. It means that the BH curve is available in <code class="docutils literal notranslate"><span class="pre">Project</span> <span class="pre">&gt;</span> <span class="pre">Datasets</span></code> in AEDT. Once the dataset is imported, it can be assigned to the permeability value.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mat_PM</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">add_material</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;Arnold_Magnetics_N30UH_80C_new&quot;</span><span class="p">)</span>
<span class="n">mat_PM</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">mat_PM</span><span class="o">.</span><span class="n">conductivity</span> <span class="o">=</span> <span class="s2">&quot;555555.5556&quot;</span>
<span class="n">mat_PM</span><span class="o">.</span><span class="n">set_magnetic_coercivity</span><span class="p">(</span><span class="n">value</span><span class="o">=-</span><span class="mf">800146.66287534</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mat_PM</span><span class="o">.</span><span class="n">mass_density</span> <span class="o">=</span> <span class="s2">&quot;7500&quot;</span>
<span class="n">BH_List_PM</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">import_dataset1d</span><span class="p">(</span><span class="n">filename_PM</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Arnold_Magnetics_N30UH_80C&quot;</span><span class="p">)</span>
<span class="n">mat_PM</span><span class="o">.</span><span class="n">permeability</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">BH_List_PM</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">BH_List_PM</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Adding new material to the Project Library: Arnold_Magnetics_N30UH_80C_new
PyAEDT INFO: Material has been added in Desktop.
PyAEDT INFO: Parsing C:\Users\ansys\AppData\Local\Temp\tmpv8udbbdr.ansys\PM_Motor.aedt.
PyAEDT INFO: File C:\Users\ansys\AppData\Local\Temp\tmpv8udbbdr.ansys\PM_Motor.aedt correctly loaded. Elapsed time: 0m 0sec
PyAEDT INFO: aedt file load time 0.0157928466796875
PyAEDT INFO: Dataset Arnold_Magnetics_N30UH_80C doesn&#39;t exist.
PyAEDT INFO: Dataset $Arnold_Magnetics_N30UH_80C created successfully.
</pre></div></div>
</div>
<p>Create the third material laminated <code class="docutils literal notranslate"><span class="pre">30DH_20C_smooth</span></code>. The BH curve is read from a tabbed CSV file. A list named <code class="docutils literal notranslate"><span class="pre">BH_List_lam</span></code> is created. This list is passed to the <code class="docutils literal notranslate"><span class="pre">mat_lam.permeability.value</span></code> variable.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mat_lam</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">add_material</span><span class="p">(</span><span class="s2">&quot;30DH_20C_smooth&quot;</span><span class="p">)</span>
<span class="n">mat_lam</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">mat_lam</span><span class="o">.</span><span class="n">conductivity</span> <span class="o">=</span> <span class="s2">&quot;1694915.25424&quot;</span>
<span class="n">kh</span> <span class="o">=</span> <span class="mf">71.7180985413</span>
<span class="n">kc</span> <span class="o">=</span> <span class="mf">0.25092214579</span>
<span class="n">ke</span> <span class="o">=</span> <span class="mf">12.1625774023</span>
<span class="n">kdc</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="n">eq_depth</span> <span class="o">=</span> <span class="mf">0.001</span>
<span class="n">mat_lam</span><span class="o">.</span><span class="n">set_electrical_steel_coreloss</span><span class="p">(</span><span class="n">kh</span><span class="p">,</span> <span class="n">kc</span><span class="p">,</span> <span class="n">ke</span><span class="p">,</span> <span class="n">kdc</span><span class="p">,</span> <span class="n">eq_depth</span><span class="p">)</span>
<span class="n">mat_lam</span><span class="o">.</span><span class="n">mass_density</span> <span class="o">=</span> <span class="s2">&quot;7650&quot;</span>
<span class="n">BH_List_lam</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_lam</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">next</span><span class="p">(</span><span class="n">reader</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">reader</span><span class="p">:</span>
        <span class="n">BH_List_lam</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span>
<span class="n">mat_lam</span><span class="o">.</span><span class="n">permeability</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">BH_List_lam</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Adding new material to the Project Library: 30DH_20C_smooth
PyAEDT INFO: Material has been added in Desktop.
</pre></div></div>
</div>
</section>
<section id="Create-geometry-for-stator">
<h2>Create geometry for stator<a class="headerlink" href="#Create-geometry-for-stator" title="Link to this heading">#</a></h2>
<p>Create the geometry for the stator. It is created via the RMxprt user-defined primitive (UDP). A list of lists is created with the proper UDP parameters.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">udp_par_list_stator</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;DiaGap&quot;</span><span class="p">,</span> <span class="s2">&quot;DiaGap&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;DiaYoke&quot;</span><span class="p">,</span> <span class="s2">&quot;DiaStatorYoke&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Length&quot;</span><span class="p">,</span> <span class="s2">&quot;Stator_Lam_Length&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Skew&quot;</span><span class="p">,</span> <span class="s2">&quot;StatorSkewAngle&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Slots&quot;</span><span class="p">,</span> <span class="s2">&quot;SlotNumber&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;SlotType&quot;</span><span class="p">,</span> <span class="s2">&quot;SlotType&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Hs0&quot;</span><span class="p">,</span> <span class="s2">&quot;1.2mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Hs01&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Hs1&quot;</span><span class="p">,</span> <span class="s2">&quot;0.4834227384999mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Hs2&quot;</span><span class="p">,</span> <span class="s2">&quot;17.287669825502mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Bs0&quot;</span><span class="p">,</span> <span class="s2">&quot;2.814mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Bs1&quot;</span><span class="p">,</span> <span class="s2">&quot;4.71154109036mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Bs2&quot;</span><span class="p">,</span> <span class="s2">&quot;6.9777285790998mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;Rs&quot;</span><span class="p">,</span> <span class="s2">&quot;2mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;FilletType&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;HalfSlot&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;VentHoles&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;HoleDiaIn&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;HoleDiaOut&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;HoleLocIn&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;HoleLocOut&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;VentDucts&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;DuctWidth&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;DuctPitch&quot;</span><span class="p">,</span> <span class="s2">&quot;0mm&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;SegAngle&quot;</span><span class="p">,</span> <span class="s2">&quot;0deg&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;LenRegion&quot;</span><span class="p">,</span> <span class="s2">&quot;Model_Length&quot;</span><span class="p">],</span>
    <span class="p">[</span><span class="s2">&quot;InfoCore&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">],</span>
<span class="p">]</span>

<span class="n">stator_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_udp</span><span class="p">(</span>
    <span class="n">dll</span><span class="o">=</span><span class="s2">&quot;RMxprt/VentSlotCore.dll&quot;</span><span class="p">,</span>
    <span class="n">parameters</span><span class="o">=</span><span class="n">udp_par_list_stator</span><span class="p">,</span>
    <span class="n">library</span><span class="o">=</span><span class="s2">&quot;syslib&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;my_stator&quot;</span><span class="p">,</span>
<span class="p">)</span>
<br/></pre></div>
</div>
</div>
</section>
<section id="Assign-properties-to-stator">
<h2>Assign properties to stator<a class="headerlink" href="#Assign-properties-to-stator" title="Link to this heading">#</a></h2>
<p>Assign properties to the stator. The following code assigns the <code class="docutils literal notranslate"><span class="pre">material</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">color</span></code>, and <code class="docutils literal notranslate"><span class="pre">solve_inside</span></code> properties.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">assign_material</span><span class="p">(</span><span class="n">assignment</span><span class="o">=</span><span class="n">stator_id</span><span class="p">,</span> <span class="n">material</span><span class="o">=</span><span class="s2">&quot;30DH_20C_smooth&quot;</span><span class="p">)</span>
<span class="n">stator_id</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Stator&quot;</span>
<span class="n">stator_id</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>  <span class="c1"># rgb</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># to be reassigned: m2d.assign material puts False if not dielectric</span>
<span class="n">stator_id</span><span class="o">.</span><span class="n">solve_inside</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-outer-and-inner-PMs">
<h2>Create outer and inner PMs<a class="headerlink" href="#Create-outer-and-inner-PMs" title="Link to this heading">#</a></h2>
<p>Create the outer and inner PMs and assign color to them.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">IM1_points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">56.70957112</span><span class="p">,</span> <span class="mf">3.104886585</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">40.25081875</span><span class="p">,</span> <span class="mf">16.67243502</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">38.59701538</span><span class="p">,</span> <span class="mf">14.66621111</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">55.05576774</span><span class="p">,</span> <span class="mf">1.098662669</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">OM1_points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">54.37758185</span><span class="p">,</span> <span class="mf">22.52393189</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">59.69688156</span><span class="p">,</span> <span class="mf">9.68200639</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">63.26490432</span><span class="p">,</span> <span class="mf">11.15992981</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">57.94560461</span><span class="p">,</span> <span class="mf">24.00185531</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">IPM1_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_polyline</span><span class="p">(</span>
    <span class="n">points</span><span class="o">=</span><span class="n">IM1_points</span><span class="p">,</span>
    <span class="n">cover_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;PM_I1&quot;</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s2">&quot;Arnold_Magnetics_N30UH_80C_new&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">IPM1_id</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
<span class="n">OPM1_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_polyline</span><span class="p">(</span>
    <span class="n">points</span><span class="o">=</span><span class="n">OM1_points</span><span class="p">,</span>
    <span class="n">cover_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;PM_O1&quot;</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s2">&quot;Arnold_Magnetics_N30UH_80C_new&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">OPM1_id</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-coordinate-system-for-PMs">
<h2>Create coordinate system for PMs<a class="headerlink" href="#Create-coordinate-system-for-PMs" title="Link to this heading">#</a></h2>
<p>Create the coordinate system for the PMs. In Maxwell 2D, you assign magnetization via the coordinate system. The inputs are the object name, coordinate system name, and inner or outer magnetization.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">create_cs_magnets</span><span class="p">(</span><span class="n">pm_id</span><span class="p">,</span> <span class="n">cs_name</span><span class="p">,</span> <span class="n">point_direction</span><span class="p">):</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pm_id</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">attrgetter</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">point_direction</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
        <span class="n">my_axis_pos</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">point_direction</span> <span class="o">==</span> <span class="s2">&quot;inner&quot;</span><span class="p">:</span>
        <span class="n">my_axis_pos</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_face_coordinate_system</span><span class="p">(</span>
        <span class="n">face</span><span class="o">=</span><span class="n">pm_id</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">origin</span><span class="o">=</span><span class="n">pm_id</span><span class="o">.</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">axis_position</span><span class="o">=</span><span class="n">my_axis_pos</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="n">cs_name</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">pm_id</span><span class="o">.</span><span class="n">part_coordinate_system</span> <span class="o">=</span> <span class="n">cs_name</span>
    <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">set_working_coordinate_system</span><span class="p">(</span><span class="s2">&quot;Global&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-coordinate-system-for-PMs-in-face-center">
<h2>Create coordinate system for PMs in face center<a class="headerlink" href="#Create-coordinate-system-for-PMs-in-face-center" title="Link to this heading">#</a></h2>
<p>Create the coordinate system for PMs in the face center.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">create_cs_magnets</span><span class="p">(</span><span class="n">IPM1_id</span><span class="p">,</span> <span class="s2">&quot;CS_&quot;</span> <span class="o">+</span> <span class="n">IPM1_id</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">)</span>
<span class="n">create_cs_magnets</span><span class="p">(</span><span class="n">OPM1_id</span><span class="p">,</span> <span class="s2">&quot;CS_&quot;</span> <span class="o">+</span> <span class="n">OPM1_id</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;outer&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Duplicate-and-mirror-PMs">
<h2>Duplicate and mirror PMs<a class="headerlink" href="#Duplicate-and-mirror-PMs" title="Link to this heading">#</a></h2>
<p>Duplicate and mirror the PMs along with the local coordinate system.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">duplicate_and_mirror</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="p">[</span><span class="n">IPM1_id</span><span class="p">,</span> <span class="n">OPM1_id</span><span class="p">],</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">vector</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;cos((360deg/SymmetryFactor/2)+90deg)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sin((360deg/SymmetryFactor/2)+90deg)&quot;</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>
<span class="n">id_PMs</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_objects_w_string</span><span class="p">(</span><span class="n">string_name</span><span class="o">=</span><span class="s2">&quot;PM&quot;</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-coils">
<h2>Create coils<a class="headerlink" href="#Create-coils" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">coil_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_rectangle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;DiaRotorLam/2+Airgap+Coil_SetBack&quot;</span><span class="p">,</span> <span class="s2">&quot;-Coil_Edge_Short/2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">sizes</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Coil_Edge_Long&quot;</span><span class="p">,</span> <span class="s2">&quot;Coil_Edge_Short&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Coil&quot;</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s2">&quot;Copper (Annealed)_65C&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">coil_id</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">assignment</span><span class="o">=</span><span class="n">coil_id</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="s2">&quot;360deg/SlotNumber/2&quot;</span><span class="p">)</span>
<span class="n">coil_id</span><span class="o">.</span><span class="n">duplicate_around_axis</span><span class="p">(</span>
    <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="n">angle</span><span class="o">=</span><span class="s2">&quot;360deg/SlotNumber&quot;</span><span class="p">,</span> <span class="n">clones</span><span class="o">=</span><span class="s2">&quot;CoilPitch+1&quot;</span><span class="p">,</span> <span class="n">create_new_objects</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">id_coils</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_objects_w_string</span><span class="p">(</span><span class="n">string_name</span><span class="o">=</span><span class="s2">&quot;Coil&quot;</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-shaft-and-region">
<h2>Create shaft and region<a class="headerlink" href="#Create-shaft-and-region" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">region_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;DiaOuter/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="s2">&quot;SegAngle&quot;</span><span class="p">,</span>
    <span class="n">is_covered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Region&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">shaft_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;DiaShaft/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="s2">&quot;SegAngle&quot;</span><span class="p">,</span>
    <span class="n">is_covered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Shaft&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-bands">
<h2>Create bands<a class="headerlink" href="#Create-bands" title="Link to this heading">#</a></h2>
<p>Create the inner band, band, and outer band.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bandIN_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;(DiaGap - (1.5 * Airgap))/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="s2">&quot;mapping_angle&quot;</span><span class="p">,</span>
    <span class="n">is_covered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Inner_Band&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">bandMID_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;(DiaGap - (1.0 * Airgap))/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="s2">&quot;mapping_angle&quot;</span><span class="p">,</span>
    <span class="n">is_covered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Band&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">bandOUT_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;(DiaGap - (0.5 * Airgap))/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="s2">&quot;mapping_angle&quot;</span><span class="p">,</span>
    <span class="n">is_covered</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Outer_Band&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-list-of-vacuum-objects">
<h2>Create list of vacuum objects<a class="headerlink" href="#Create-list-of-vacuum-objects" title="Link to this heading">#</a></h2>
<p>Create a list of vacuum objects and assign color.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">vacuum_obj_id</span> <span class="o">=</span> <span class="p">[</span>
    <span class="n">shaft_id</span><span class="p">,</span>
    <span class="n">region_id</span><span class="p">,</span>
    <span class="n">bandIN_id</span><span class="p">,</span>
    <span class="n">bandMID_id</span><span class="p">,</span>
    <span class="n">bandOUT_id</span><span class="p">,</span>
<span class="p">]</span>  <span class="c1"># put shaft first</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">vacuum_obj_id</span><span class="p">:</span>
    <span class="n">item</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-rotor">
<h2>Create rotor<a class="headerlink" href="#Create-rotor" title="Link to this heading">#</a></h2>
<p>Create the rotor. Holes are specific to the lamination. Allocated PMs are created.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">rotor_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;DiaRotorLam/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Rotor&quot;</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s2">&quot;30DH_20C_smooth&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">rotor_id</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">blank_list</span><span class="o">=</span><span class="n">rotor_id</span><span class="p">,</span> <span class="n">tool_list</span><span class="o">=</span><span class="n">shaft_id</span><span class="p">,</span> <span class="n">keep_originals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">void_small_1_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">62</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;2.55mm&quot;</span><span class="p">,</span> <span class="n">num_sides</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;void1&quot;</span><span class="p">,</span> <span class="n">material</span><span class="o">=</span><span class="s2">&quot;vacuum&quot;</span>
<span class="p">)</span>

<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">duplicate_around_axis</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="n">void_small_1_id</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span>
    <span class="n">angle</span><span class="o">=</span><span class="s2">&quot;360deg/SymmetryFactor&quot;</span><span class="p">,</span>
    <span class="n">clones</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">create_new_objects</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">void_big_1_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_circle</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mf">29.5643</span><span class="p">,</span> <span class="mf">12.234389332712</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">radius</span><span class="o">=</span><span class="s2">&quot;9.88mm/2&quot;</span><span class="p">,</span>
    <span class="n">num_sides</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;void_big&quot;</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s2">&quot;vacuum&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span>
    <span class="n">blank_list</span><span class="o">=</span><span class="n">rotor_id</span><span class="p">,</span>
    <span class="n">tool_list</span><span class="o">=</span><span class="p">[</span><span class="n">void_small_1_id</span><span class="p">,</span> <span class="n">void_big_1_id</span><span class="p">],</span>
    <span class="n">keep_originals</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">slot_IM1_points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">37.5302872</span><span class="p">,</span> <span class="mf">15.54555396</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">55.05576774</span><span class="p">,</span> <span class="mf">1.098662669</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">57.33637589</span><span class="p">,</span> <span class="mf">1.25</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">57.28982158</span><span class="p">,</span> <span class="mf">2.626565019</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">40.25081875</span><span class="p">,</span> <span class="mf">16.67243502</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">slot_OM1_points</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">[</span><span class="mf">54.37758185</span><span class="p">,</span> <span class="mf">22.52393189</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">59.69688156</span><span class="p">,</span> <span class="mf">9.68200639</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">63.53825619</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">57.94560461</span><span class="p">,</span> <span class="mf">24.00185531</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">]</span>
<span class="n">slot_IM_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_polyline</span><span class="p">(</span>
    <span class="n">points</span><span class="o">=</span><span class="n">slot_IM1_points</span><span class="p">,</span> <span class="n">cover_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;slot_IM1&quot;</span><span class="p">,</span> <span class="n">material</span><span class="o">=</span><span class="s2">&quot;vacuum&quot;</span>
<span class="p">)</span>
<span class="n">slot_OM_id</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_polyline</span><span class="p">(</span>
    <span class="n">points</span><span class="o">=</span><span class="n">slot_OM1_points</span><span class="p">,</span> <span class="n">cover_surface</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;slot_OM1&quot;</span><span class="p">,</span> <span class="n">material</span><span class="o">=</span><span class="s2">&quot;vacuum&quot;</span>
<span class="p">)</span>

<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">duplicate_and_mirror</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="p">[</span><span class="n">slot_IM_id</span><span class="p">,</span> <span class="n">slot_OM_id</span><span class="p">],</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">vector</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;cos((360deg/SymmetryFactor/2)+90deg)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sin((360deg/SymmetryFactor/2)+90deg)&quot;</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>

<span class="n">id_holes</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_objects_w_string</span><span class="p">(</span><span class="n">string_name</span><span class="o">=</span><span class="s2">&quot;slot_&quot;</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">rotor_id</span><span class="p">,</span> <span class="n">id_holes</span><span class="p">,</span> <span class="n">keep_originals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Parsing design objects. This operation can take time
PyAEDT INFO: Refreshing bodies from Object Info
PyAEDT INFO: Bodies Info Refreshed Elapsed time: 0m 0sec
PyAEDT INFO: 3D Modeler objects parsed. Elapsed time: 0m 0sec
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Create-section-of-machine">
<h2>Create section of machine<a class="headerlink" href="#Create-section-of-machine" title="Link to this heading">#</a></h2>
<p>Create a section of the machine. This allows you to take advantage of symmetries.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">object_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">stator_id</span><span class="p">,</span> <span class="n">rotor_id</span><span class="p">]</span> <span class="o">+</span> <span class="n">vacuum_obj_id</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">create_coordinate_system</span><span class="p">(</span>
    <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">reference_cs</span><span class="o">=</span><span class="s2">&quot;Global&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Section&quot;</span><span class="p">,</span>
    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;axis&quot;</span><span class="p">,</span>
    <span class="n">x_pointing</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;cos(360deg/SymmetryFactor)&quot;</span><span class="p">,</span> <span class="s2">&quot;sin(360deg/SymmetryFactor)&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="n">y_pointing</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;-sin(360deg/SymmetryFactor)&quot;</span><span class="p">,</span> <span class="s2">&quot;cos(360deg/SymmetryFactor)&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">set_working_coordinate_system</span><span class="p">(</span><span class="s2">&quot;Section&quot;</span><span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">assignment</span><span class="o">=</span><span class="n">object_list</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="s2">&quot;ZX&quot;</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s2">&quot;NegativeOnly&quot;</span><span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">set_working_coordinate_system</span><span class="p">(</span><span class="s2">&quot;Global&quot;</span><span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">assignment</span><span class="o">=</span><span class="n">object_list</span><span class="p">,</span> <span class="n">plane</span><span class="o">=</span><span class="s2">&quot;ZX&quot;</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="s2">&quot;PositiveOnly&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[&#39;Stator,Rotor,Shaft,Region,Inner_Band,Band,Outer_Band&#39;]
</pre></div></div>
</div>
</section>
<section id="Create-boundary-conditions">
<h2>Create boundary conditions<a class="headerlink" href="#Create-boundary-conditions" title="Link to this heading">#</a></h2>
<p>Create independent and dependent boundary conditions. Edges for assignment are picked by position. The points for edge picking are in the airgap.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pos_1</span> <span class="o">=</span> <span class="s2">&quot;((DiaGap - (1.0 * Airgap))/4)&quot;</span>
<span class="n">id_bc_1</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_edgeid_from_position</span><span class="p">(</span>
    <span class="n">position</span><span class="o">=</span><span class="p">[</span><span class="n">pos_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Region&quot;</span>
<span class="p">)</span>
<span class="n">id_bc_2</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_edgeid_from_position</span><span class="p">(</span>
    <span class="n">position</span><span class="o">=</span><span class="p">[</span>
        <span class="n">pos_1</span> <span class="o">+</span> <span class="s2">&quot;*cos((360deg/SymmetryFactor))&quot;</span><span class="p">,</span>
        <span class="n">pos_1</span> <span class="o">+</span> <span class="s2">&quot;*sin((360deg/SymmetryFactor))&quot;</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Region&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_master_slave</span><span class="p">(</span>
    <span class="n">independent</span><span class="o">=</span><span class="n">id_bc_1</span><span class="p">,</span>
    <span class="n">dependent</span><span class="o">=</span><span class="n">id_bc_2</span><span class="p">,</span>
    <span class="n">reverse_master</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">reverse_slave</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">same_as_master</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;Matching&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Independent Matching has been created.
PyAEDT INFO: Boundary Dependent Matching_dep has been created.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(Matching, Matching_dep)
</pre></div></div>
</div>
</section>
<section id="Assign-vector-potential">
<h2>Assign vector potential<a class="headerlink" href="#Assign-vector-potential" title="Link to this heading">#</a></h2>
<p>Assign a vector potential of <code class="docutils literal notranslate"><span class="pre">0</span></code> to the second position.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pos_2</span> <span class="o">=</span> <span class="s2">&quot;(DiaOuter/2)&quot;</span>
<span class="n">id_bc_az</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_edgeid_from_position</span><span class="p">(</span>
    <span class="n">position</span><span class="o">=</span><span class="p">[</span>
        <span class="n">pos_2</span> <span class="o">+</span> <span class="s2">&quot;*cos((360deg/SymmetryFactor/2))&quot;</span><span class="p">,</span>
        <span class="n">pos_2</span> <span class="o">+</span> <span class="s2">&quot;*sin((360deg/SymmetryFactor)/2)&quot;</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Region&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_vector_potential</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="n">id_bc_az</span><span class="p">,</span> <span class="n">vector_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s2">&quot;VectorPotentialZero&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Vector Potential VectorPotentialZero has been created.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
VectorPotentialZero
</pre></div></div>
</div>
</section>
<section id="Create-excitations">
<h2>Create excitations<a class="headerlink" href="#Create-excitations" title="Link to this heading">#</a></h2>
<p>Create excitations, defining phase currents for the windings.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ph_a_current</span> <span class="o">=</span> <span class="s2">&quot;IPeak * cos(2*pi*ElectricFrequency*time+Theta_i)&quot;</span>
<span class="n">ph_b_current</span> <span class="o">=</span> <span class="s2">&quot;IPeak * cos(2*pi * ElectricFrequency*time - 120deg+Theta_i)&quot;</span>
<span class="n">ph_c_current</span> <span class="o">=</span> <span class="s2">&quot;IPeak * cos(2*pi * ElectricFrequency*time - 240deg+Theta_i)&quot;</span>
</pre></div>
</div>
</div>
</section>
<section id="Define-windings-in-phase-A">
<h2>Define windings in phase A<a class="headerlink" href="#Define-windings-in-phase-A" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">assign_coil</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Coil&quot;</span><span class="p">],</span>
    <span class="n">conductors_number</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">polarity</span><span class="o">=</span><span class="s2">&quot;Positive&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CT_Ph1_P2_C1_Go&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_coil</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Coil_5&quot;</span><span class="p">],</span>
    <span class="n">conductors_number</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">polarity</span><span class="o">=</span><span class="s2">&quot;Negative&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CT_Ph1_P2_C1_Ret&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_winding</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">winding_type</span><span class="o">=</span><span class="s2">&quot;Current&quot;</span><span class="p">,</span>
    <span class="n">is_solid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">current</span><span class="o">=</span><span class="n">ph_a_current</span><span class="p">,</span>
    <span class="n">parallel_branches</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Phase_A&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">add_winding_coils</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Phase_A&quot;</span><span class="p">,</span> <span class="n">coils</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CT_Ph1_P2_C1_Go&quot;</span><span class="p">,</span> <span class="s2">&quot;CT_Ph1_P2_C1_Ret&quot;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Coil CT_Ph1_P2_C1_Go has been created.
PyAEDT INFO: Boundary Coil CT_Ph1_P2_C1_Ret has been created.
PyAEDT INFO: Boundary Winding Phase_A has been created.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Define-windings-in-phase-B">
<h2>Define windings in phase B<a class="headerlink" href="#Define-windings-in-phase-B" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">assign_coil</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Coil_3&quot;</span><span class="p">,</span>
    <span class="n">conductors_number</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">polarity</span><span class="o">=</span><span class="s2">&quot;Positive&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CT_Ph3_P1_C2_Go&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_coil</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Coil_4&quot;</span><span class="p">,</span>
    <span class="n">conductors_number</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">polarity</span><span class="o">=</span><span class="s2">&quot;Positive&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CT_Ph3_P1_C1_Go&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_winding</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">winding_type</span><span class="o">=</span><span class="s2">&quot;Current&quot;</span><span class="p">,</span>
    <span class="n">is_solid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">current</span><span class="o">=</span><span class="n">ph_b_current</span><span class="p">,</span>
    <span class="n">parallel_branches</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Phase_B&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">add_winding_coils</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Phase_B&quot;</span><span class="p">,</span> <span class="n">coils</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CT_Ph3_P1_C2_Go&quot;</span><span class="p">,</span> <span class="s2">&quot;CT_Ph3_P1_C1_Go&quot;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Coil CT_Ph3_P1_C2_Go has been created.
PyAEDT INFO: Boundary Coil CT_Ph3_P1_C1_Go has been created.
PyAEDT INFO: Boundary Winding Phase_B has been created.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Define-windings-in-phase-C">
<h2>Define windings in phase C<a class="headerlink" href="#Define-windings-in-phase-C" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">assign_coil</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Coil_1&quot;</span><span class="p">,</span>
    <span class="n">conductors_number</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">polarity</span><span class="o">=</span><span class="s2">&quot;Negative&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CT_Ph2_P2_C2_Ret&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_coil</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Coil_2&quot;</span><span class="p">,</span>
    <span class="n">conductors_number</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">polarity</span><span class="o">=</span><span class="s2">&quot;Negative&quot;</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;CT_Ph2_P2_C1_Ret&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">assign_winding</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">winding_type</span><span class="o">=</span><span class="s2">&quot;Current&quot;</span><span class="p">,</span>
    <span class="n">is_solid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">current</span><span class="o">=</span><span class="n">ph_c_current</span><span class="p">,</span>
    <span class="n">parallel_branches</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;Phase_C&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">add_winding_coils</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Phase_C&quot;</span><span class="p">,</span> <span class="n">coils</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;CT_Ph2_P2_C2_Ret&quot;</span><span class="p">,</span> <span class="s2">&quot;CT_Ph2_P2_C1_Ret&quot;</span><span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Coil CT_Ph2_P2_C2_Ret has been created.
PyAEDT INFO: Boundary Coil CT_Ph2_P2_C1_Ret has been created.
PyAEDT INFO: Boundary Winding Phase_C has been created.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Assign-total-current-on-PMs">
<h2>Assign total current on PMs<a class="headerlink" href="#Assign-total-current-on-PMs" title="Link to this heading">#</a></h2>
<p>Assign a total current of <code class="docutils literal notranslate"><span class="pre">0</span></code> on the PMs.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PM_list</span> <span class="o">=</span> <span class="n">id_PMs</span>
<span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">PM_list</span><span class="p">:</span>
    <span class="n">m2d</span><span class="o">.</span><span class="n">assign_current</span><span class="p">(</span><span class="n">assignment</span><span class="o">=</span><span class="n">item</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solid</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">item</span> <span class="o">+</span> <span class="s2">&quot;_I0&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Current PM_I1_I0 has been created.
PyAEDT INFO: Boundary Current PM_O1_I0 has been created.
PyAEDT INFO: Boundary Current PM_I1_1_I0 has been created.
PyAEDT INFO: Boundary Current PM_O1_1_I0 has been created.
</pre></div></div>
</div>
</section>
<section id="Create-mesh-operations">
<h2>Create mesh operations<a class="headerlink" href="#Create-mesh-operations" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">assign_length_mesh</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="n">id_coils</span><span class="p">,</span>
    <span class="n">inside_selection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">maximum_length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">maximum_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;coils&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">assign_length_mesh</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="n">stator_id</span><span class="p">,</span>
    <span class="n">inside_selection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">maximum_length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">maximum_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;stator&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">assign_length_mesh</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="n">rotor_id</span><span class="p">,</span>
    <span class="n">inside_selection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">maximum_length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
    <span class="n">maximum_elements</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;rotor&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Mesh class has been initialized! Elapsed time: 0m 0sec
PyAEDT INFO: Mesh class has been initialized! Elapsed time: 0m 0sec
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
rotor
</pre></div></div>
</div>
</section>
<section id="Turn-on-core-loss">
<h2>Turn on core loss<a class="headerlink" href="#Turn-on-core-loss" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">core_loss_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Rotor&quot;</span><span class="p">,</span> <span class="s2">&quot;Stator&quot;</span><span class="p">]</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">set_core_losses</span><span class="p">(</span><span class="n">core_loss_list</span><span class="p">,</span> <span class="n">core_loss_on_field</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Compute-transient-inductance">
<h2>Compute transient inductance<a class="headerlink" href="#Compute-transient-inductance" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">change_inductance_computation</span><span class="p">(</span>
    <span class="n">compute_transient_inductance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">incremental_matrix</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Set-model-depth">
<h2>Set model depth<a class="headerlink" href="#Set-model-depth" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">model_depth</span> <span class="o">=</span> <span class="s2">&quot;Magnetic_Axial_Length&quot;</span>
</pre></div>
</div>
</div>
</section>
<section id="Set-symmetry-factor">
<h2>Set symmetry factor<a class="headerlink" href="#Set-symmetry-factor" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">change_symmetry_multiplier</span><span class="p">(</span><span class="s2">&quot;SymmetryFactor&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Assign-motion-setup-to-object">
<h2>Assign motion setup to object<a class="headerlink" href="#Assign-motion-setup-to-object" title="Link to this heading">#</a></h2>
<p>Assign a motion setup to a <code class="docutils literal notranslate"><span class="pre">Band</span></code> object named <code class="docutils literal notranslate"><span class="pre">RotatingBand_mid</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[40]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">assign_rotate_motion</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="s2">&quot;Band&quot;</span><span class="p">,</span>
    <span class="n">coordinate_system</span><span class="o">=</span><span class="s2">&quot;Global&quot;</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span>
    <span class="n">positive_movement</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">start_position</span><span class="o">=</span><span class="s2">&quot;InitialPositionMD&quot;</span><span class="p">,</span>
    <span class="n">angular_velocity</span><span class="o">=</span><span class="s2">&quot;MachineRPM&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Boundary Band MotionSetup1 has been created.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[40]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
MotionSetup1
</pre></div></div>
</div>
</section>
<section id="Create-setup-and-validate">
<h2>Create setup and validate<a class="headerlink" href="#Create-setup-and-validate" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">setup_name</span> <span class="o">=</span> <span class="s2">&quot;MySetupAuto&quot;</span>
<span class="n">setup</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">create_setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">setup_name</span><span class="p">)</span>
<span class="n">setup</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;StopTime&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;StopTime&quot;</span>
<span class="n">setup</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;TimeStep&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;TimeStep&quot;</span>
<span class="n">setup</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;SaveFieldsType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
<span class="n">setup</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;OutputPerObjectCoreLoss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">setup</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;OutputPerObjectSolidLoss&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">setup</span><span class="o">.</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;OutputError&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">setup</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">validate_simple</span><span class="p">()</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">temp_folder</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;Image.jpg&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: PostProcessor class has been initialized! Elapsed time: 0m 0sec
PyAEDT INFO: PostProcessor class has been initialized! Elapsed time: 0m 0sec
PyAEDT INFO: Post class has been initialized! Elapsed time: 0m 0sec
</pre></div></div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"version_major": 2, "version_minor": 0, "model_id": "bca799681b6745338b59129d4e64760f"}</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Initialize-definitions-for-output-variables">
<h2>Initialize definitions for output variables<a class="headerlink" href="#Initialize-definitions-for-output-variables" title="Link to this heading">#</a></h2>
<p>Initialize the definitions for the output variables. These are used later to generate reports.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[42]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">output_vars</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;Current_A&quot;</span><span class="p">:</span> <span class="s2">&quot;InputCurrent(Phase_A)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Current_B&quot;</span><span class="p">:</span> <span class="s2">&quot;InputCurrent(Phase_B)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Current_C&quot;</span><span class="p">:</span> <span class="s2">&quot;InputCurrent(Phase_C)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flux_A&quot;</span><span class="p">:</span> <span class="s2">&quot;FluxLinkage(Phase_A)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flux_B&quot;</span><span class="p">:</span> <span class="s2">&quot;FluxLinkage(Phase_B)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flux_C&quot;</span><span class="p">:</span> <span class="s2">&quot;FluxLinkage(Phase_C)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="s2">&quot;(Moving1.Position -InitialPositionMD) *NumPoles/2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cos0&quot;</span><span class="p">:</span> <span class="s2">&quot;cos(pos)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cos1&quot;</span><span class="p">:</span> <span class="s2">&quot;cos(pos-2*PI/3)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;cos2&quot;</span><span class="p">:</span> <span class="s2">&quot;cos(pos-4*PI/3)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sin0&quot;</span><span class="p">:</span> <span class="s2">&quot;sin(pos)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sin1&quot;</span><span class="p">:</span> <span class="s2">&quot;sin(pos-2*PI/3)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sin2&quot;</span><span class="p">:</span> <span class="s2">&quot;sin(pos-4*PI/3)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flux_d&quot;</span><span class="p">:</span> <span class="s2">&quot;2/3*(Flux_A*cos0+Flux_B*cos1+Flux_C*cos2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Flux_q&quot;</span><span class="p">:</span> <span class="s2">&quot;-2/3*(Flux_A*sin0+Flux_B*sin1+Flux_C*sin2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;I_d&quot;</span><span class="p">:</span> <span class="s2">&quot;2/3*(Current_A*cos0 + Current_B*cos1 + Current_C*cos2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;I_q&quot;</span><span class="p">:</span> <span class="s2">&quot;-2/3*(Current_A*sin0 + Current_B*sin1 + Current_C*sin2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Irms&quot;</span><span class="p">:</span> <span class="s2">&quot;sqrt(I_d^2+I_q^2)/sqrt(2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ArmatureOhmicLoss_DC&quot;</span><span class="p">:</span> <span class="s2">&quot;Irms^2*R_phase&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Lad&quot;</span><span class="p">:</span> <span class="s2">&quot;L(Phase_A,Phase_A)*cos0 + L(Phase_A,Phase_B)*cos1 + L(Phase_A,Phase_C)*cos2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Laq&quot;</span><span class="p">:</span> <span class="s2">&quot;L(Phase_A,Phase_A)*sin0 + L(Phase_A,Phase_B)*sin1 + L(Phase_A,Phase_C)*sin2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Lbd&quot;</span><span class="p">:</span> <span class="s2">&quot;L(Phase_B,Phase_A)*cos0 + L(Phase_B,Phase_B)*cos1 + L(Phase_B,Phase_C)*cos2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Lbq&quot;</span><span class="p">:</span> <span class="s2">&quot;L(Phase_B,Phase_A)*sin0 + L(Phase_B,Phase_B)*sin1 + L(Phase_B,Phase_C)*sin2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Lcd&quot;</span><span class="p">:</span> <span class="s2">&quot;L(Phase_C,Phase_A)*cos0 + L(Phase_C,Phase_B)*cos1 + L(Phase_C,Phase_C)*cos2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Lcq&quot;</span><span class="p">:</span> <span class="s2">&quot;L(Phase_C,Phase_A)*sin0 + L(Phase_C,Phase_B)*sin1 + L(Phase_C,Phase_C)*sin2&quot;</span><span class="p">,</span>
    <span class="s2">&quot;L_d&quot;</span><span class="p">:</span> <span class="s2">&quot;(Lad*cos0 + Lbd*cos1 + Lcd*cos2) * 2/3&quot;</span><span class="p">,</span>
    <span class="s2">&quot;L_q&quot;</span><span class="p">:</span> <span class="s2">&quot;(Laq*sin0 + Lbq*sin1 + Lcq*sin2) * 2/3&quot;</span><span class="p">,</span>
    <span class="s2">&quot;OutputPower&quot;</span><span class="p">:</span> <span class="s2">&quot;Moving1.Speed*Moving1.Torque&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ui_A&quot;</span><span class="p">:</span> <span class="s2">&quot;InducedVoltage(Phase_A)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ui_B&quot;</span><span class="p">:</span> <span class="s2">&quot;InducedVoltage(Phase_B)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ui_C&quot;</span><span class="p">:</span> <span class="s2">&quot;InducedVoltage(Phase_C)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ui_d&quot;</span><span class="p">:</span> <span class="s2">&quot;2/3*(Ui_A*cos0 + Ui_B*cos1 + Ui_C*cos2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Ui_q&quot;</span><span class="p">:</span> <span class="s2">&quot;-2/3*(Ui_A*sin0 + Ui_B*sin1 + Ui_C*sin2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;U_A&quot;</span><span class="p">:</span> <span class="s2">&quot;Ui_A+R_Phase*Current_A&quot;</span><span class="p">,</span>
    <span class="s2">&quot;U_B&quot;</span><span class="p">:</span> <span class="s2">&quot;Ui_B+R_Phase*Current_B&quot;</span><span class="p">,</span>
    <span class="s2">&quot;U_C&quot;</span><span class="p">:</span> <span class="s2">&quot;Ui_C+R_Phase*Current_C&quot;</span><span class="p">,</span>
    <span class="s2">&quot;U_d&quot;</span><span class="p">:</span> <span class="s2">&quot;2/3*(U_A*cos0 + U_B*cos1 + U_C*cos2)&quot;</span><span class="p">,</span>
    <span class="s2">&quot;U_q&quot;</span><span class="p">:</span> <span class="s2">&quot;-2/3*(U_A*sin0 + U_B*sin1 + U_C*sin2)&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-output-variables-for-postprocessing">
<h2>Create output variables for postprocessing<a class="headerlink" href="#Create-output-variables-for-postprocessing" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[43]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">output_vars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">m2d</span><span class="o">.</span><span class="n">create_output_variable</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Initialize-definition-for-postprocessing-plots">
<h2>Initialize definition for postprocessing plots<a class="headerlink" href="#Initialize-definition-for-postprocessing-plots" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[44]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">post_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Moving1.Torque&quot;</span><span class="p">:</span> <span class="s2">&quot;TorquePlots&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Initialize-definition-for-postprocessing-multiplots">
<h2>Initialize definition for postprocessing multiplots<a class="headerlink" href="#Initialize-definition-for-postprocessing-multiplots" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">post_params_multiplot</span> <span class="o">=</span> <span class="p">{</span>  <span class="c1"># reports</span>
    <span class="p">(</span><span class="s2">&quot;U_A&quot;</span><span class="p">,</span> <span class="s2">&quot;U_B&quot;</span><span class="p">,</span> <span class="s2">&quot;U_C&quot;</span><span class="p">,</span> <span class="s2">&quot;Ui_A&quot;</span><span class="p">,</span> <span class="s2">&quot;Ui_B&quot;</span><span class="p">,</span> <span class="s2">&quot;Ui_C&quot;</span><span class="p">):</span> <span class="s2">&quot;PhaseVoltages&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;CoreLoss&quot;</span><span class="p">,</span> <span class="s2">&quot;SolidLoss&quot;</span><span class="p">,</span> <span class="s2">&quot;ArmatureOhmicLoss_DC&quot;</span><span class="p">):</span> <span class="s2">&quot;Losses&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="s2">&quot;InputCurrent(Phase_A)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;InputCurrent(Phase_B)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;InputCurrent(Phase_C)&quot;</span><span class="p">,</span>
    <span class="p">):</span> <span class="s2">&quot;PhaseCurrents&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="s2">&quot;FluxLinkage(Phase_A)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;FluxLinkage(Phase_B)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;FluxLinkage(Phase_C)&quot;</span><span class="p">,</span>
    <span class="p">):</span> <span class="s2">&quot;PhaseFluxes&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;I_d&quot;</span><span class="p">,</span> <span class="s2">&quot;I_q&quot;</span><span class="p">):</span> <span class="s2">&quot;Currents_dq&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;Flux_d&quot;</span><span class="p">,</span> <span class="s2">&quot;Flux_q&quot;</span><span class="p">):</span> <span class="s2">&quot;Fluxes_dq&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;Ui_d&quot;</span><span class="p">,</span> <span class="s2">&quot;Ui_q&quot;</span><span class="p">):</span> <span class="s2">&quot;InducedVoltages_dq&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;U_d&quot;</span><span class="p">,</span> <span class="s2">&quot;U_q&quot;</span><span class="p">):</span> <span class="s2">&quot;Voltages_dq&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="s2">&quot;L(Phase_A,Phase_A)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L(Phase_B,Phase_B)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L(Phase_C,Phase_C)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L(Phase_A,Phase_B)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L(Phase_A,Phase_C)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;L(Phase_B,Phase_C)&quot;</span><span class="p">,</span>
    <span class="p">):</span> <span class="s2">&quot;PhaseInductances&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;L_d&quot;</span><span class="p">,</span> <span class="s2">&quot;L_q&quot;</span><span class="p">):</span> <span class="s2">&quot;Inductances_dq&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;CoreLoss&quot;</span><span class="p">,</span> <span class="s2">&quot;CoreLoss(Stator)&quot;</span><span class="p">,</span> <span class="s2">&quot;CoreLoss(Rotor)&quot;</span><span class="p">):</span> <span class="s2">&quot;CoreLosses&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="s2">&quot;EddyCurrentLoss&quot;</span><span class="p">,</span>
        <span class="s2">&quot;EddyCurrentLoss(Stator)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;EddyCurrentLoss(Rotor)&quot;</span><span class="p">,</span>
    <span class="p">):</span> <span class="s2">&quot;EddyCurrentLosses (Core)&quot;</span><span class="p">,</span>
    <span class="p">(</span><span class="s2">&quot;ExcessLoss&quot;</span><span class="p">,</span> <span class="s2">&quot;ExcessLoss(Stator)&quot;</span><span class="p">,</span> <span class="s2">&quot;ExcessLoss(Rotor)&quot;</span><span class="p">):</span> <span class="s2">&quot;ExcessLosses (Core)&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="s2">&quot;HysteresisLoss&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HysteresisLoss(Stator)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;HysteresisLoss(Rotor)&quot;</span><span class="p">,</span>
    <span class="p">):</span> <span class="s2">&quot;HysteresisLosses (Core)&quot;</span><span class="p">,</span>
    <span class="p">(</span>
        <span class="s2">&quot;SolidLoss&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SolidLoss(IPM1)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SolidLoss(IPM1_1)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SolidLoss(OPM1)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;SolidLoss(OPM1_1)&quot;</span><span class="p">,</span>
    <span class="p">):</span> <span class="s2">&quot;SolidLoss&quot;</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</section>
<section id="Create-report.">
<h2>Create report.<a class="headerlink" href="#Create-report." title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[46]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">post_params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">m2d</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">create_report</span><span class="p">(</span>
        <span class="n">expressions</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
        <span class="n">setup_sweep_name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;Sweep&quot;</span><span class="p">,</span>
        <span class="n">variations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">primary_sweep_variable</span><span class="o">=</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span>
        <span class="n">secondary_sweep_variable</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">report_category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_type</span><span class="o">=</span><span class="s2">&quot;Rectangular Plot&quot;</span><span class="p">,</span>
        <span class="n">context</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">subdesign_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">polyline_points</span><span class="o">=</span><span class="mi">1001</span><span class="p">,</span>
        <span class="n">plot_name</span><span class="o">=</span><span class="n">v</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT WARNING: No report category provided. Automatically identified Transient
</pre></div></div>
</div>
</section>
<section id="Create-multiplot-report">
<h2>Create multiplot report<a class="headerlink" href="#Create-multiplot-report" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># for k, v in post_params_multiplot.items():</span>
<span class="c1">#     m2d.post.create_report(expressions=list(k), setup_sweep_name=&quot;&quot;,</span>
<span class="c1">#                            domain=&quot;Sweep&quot;, variations=None,</span>
<span class="c1">#                            primary_sweep_variable=&quot;Time&quot;, secondary_sweep_variable=None,</span>
<span class="c1">#                            report_category=None, plot_type=&quot;Rectangular Plot&quot;,</span>
<span class="c1">#                            context=None, subdesign_id=None,</span>
<span class="c1">#                            polyline_points=1001, plotname=v)</span>
</pre></div>
</div>
</div>
</section>
<section id="Analyze-and-save-project">
<h2>Analyze and save project<a class="headerlink" href="#Analyze-and-save-project" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[48]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">save_project</span><span class="p">()</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">analyze_setup</span><span class="p">(</span><span class="n">setup_name</span><span class="p">,</span> <span class="n">use_auto_settings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cores</span><span class="o">=</span><span class="n">NUM_CORES</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Project PM_Motor Saved correctly
PyAEDT INFO: Key Desktop/ActiveDSOConfigurations/Maxwell 2D correctly changed.
PyAEDT INFO: Solving design setup MySetupAuto
PyAEDT INFO: Design setup MySetupAuto solved correctly in 0.0h 1.0m 55.0s
PyAEDT INFO: Key Desktop/ActiveDSOConfigurations/Maxwell 2D correctly changed.
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[48]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
True
</pre></div></div>
</div>
</section>
<section id="Create-flux-lines-plot-on-region">
<h2>Create flux lines plot on region<a class="headerlink" href="#Create-flux-lines-plot-on-region" title="Link to this heading">#</a></h2>
<p>Create a flux lines plot on a region. The <code class="docutils literal notranslate"><span class="pre">object_list</span></code> is formerly created when the section is applied.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[49]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">faces_reg</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">modeler</span><span class="o">.</span><span class="n">get_object_faces</span><span class="p">(</span><span class="n">object_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>  <span class="c1"># Region</span>
<span class="n">plot1</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">create_fieldplot_surface</span><span class="p">(</span>
    <span class="n">assignment</span><span class="o">=</span><span class="n">faces_reg</span><span class="p">,</span>
    <span class="n">quantity</span><span class="o">=</span><span class="s2">&quot;Flux_Lines&quot;</span><span class="p">,</span>
    <span class="n">intrinsics</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;Time&quot;</span><span class="p">:</span> <span class="n">m2d</span><span class="o">.</span><span class="n">variable_manager</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;StopTime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">evaluated_value</span><span class="p">},</span>
    <span class="n">plot_name</span><span class="o">=</span><span class="s2">&quot;Flux_Lines&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Active Design set to Sinusoidal
</pre></div></div>
</div>
</section>
<section id="Export-a-field-plot-to-an-image-file">
<h2>Export a field plot to an image file<a class="headerlink" href="#Export-a-field-plot-to-an-image-file" title="Link to this heading">#</a></h2>
<p>Export the flux lines plot to an image file using Python PyVista.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[50]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">plot_field_from_fieldplot</span><span class="p">(</span><span class="n">plot1</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[50]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Class: ansys.aedt.core.visualization.plot.pyvista.ModelPlotter
</pre></div></div>
</div>
</section>
<section id="Get-solution-data">
<h2>Get solution data<a class="headerlink" href="#Get-solution-data" title="Link to this heading">#</a></h2>
<p>Get a simulation result from a solved setup and cast it in a <code class="docutils literal notranslate"><span class="pre">SolutionData</span></code> object. Plot the desired expression by using the Matplotlib <code class="docutils literal notranslate"><span class="pre">plot()</span></code> function.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[51]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solutions</span> <span class="o">=</span> <span class="n">m2d</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">get_solution_data</span><span class="p">(</span>
    <span class="n">expressions</span><span class="o">=</span><span class="s2">&quot;Moving1.Torque&quot;</span><span class="p">,</span>
    <span class="n">setup_sweep_name</span><span class="o">=</span><span class="n">m2d</span><span class="o">.</span><span class="n">nominal_sweep</span><span class="p">,</span>
    <span class="n">primary_sweep_variable</span><span class="o">=</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span>
    <span class="n">domain</span><span class="o">=</span><span class="s2">&quot;Sweep&quot;</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT WARNING: No report category provided. Automatically identified Transient
PyAEDT INFO: Solution Data Correctly Loaded.
Time to initialize solution data:0.0978236198425293
Time to initialize solution data:0.0978236198425293
</pre></div></div>
</div>
</section>
<section id="Retrieve-the-data-magnitude-of-an-expression">
<h2>Retrieve the data magnitude of an expression<a class="headerlink" href="#Retrieve-the-data-magnitude-of-an-expression" title="Link to this heading">#</a></h2>
<p>List of shaft torque points and compute average.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[52]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mag</span> <span class="o">=</span> <span class="n">solutions</span><span class="o">.</span><span class="n">get_expression_data</span><span class="p">(</span><span class="n">formula</span><span class="o">=</span><span class="s2">&quot;magnitude&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span>
</pre></div>
</div>
</div>
</section>
<section id="Export-a-report-to-a-file">
<h2>Export a report to a file<a class="headerlink" href="#Export-a-report-to-a-file" title="Link to this heading">#</a></h2>
<p>Export 2D plot data to a CSV file.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[53]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">post</span><span class="o">.</span><span class="n">export_report_to_file</span><span class="p">(</span>
    <span class="n">output_dir</span><span class="o">=</span><span class="n">temp_folder</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">plot_name</span><span class="o">=</span><span class="s2">&quot;TorquePlots&quot;</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s2">&quot;.csv&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[53]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&#39;C:\\Users\\ansys\\AppData\\Local\\Temp\\tmpv8udbbdr.ansys\\TorquePlots.csv&#39;
</pre></div></div>
</div>
</section>
<section id="Retrieve-the-data-values-of-Torque-within-a-time-range">
<h2>Retrieve the data values of Torque within a time range<a class="headerlink" href="#Retrieve-the-data-values-of-Torque-within-a-time-range" title="Link to this heading">#</a></h2>
<p>Retrieve the data values of Torque within a specific time range of the electric period. Since the example analyzes only one period, the time range is from <code class="docutils literal notranslate"><span class="pre">ElectricPeriod/4</span></code> to <code class="docutils literal notranslate"><span class="pre">ElectricPeriod/2</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[54]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">time_interval</span> <span class="o">=</span> <span class="n">solutions</span><span class="o">.</span><span class="n">intrinsics</span><span class="p">[</span><span class="s2">&quot;Time&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Convert the start and stop time of the electric period range to nanoseconds</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[55]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">start_time</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span>
    <span class="n">unit_converter</span><span class="p">(</span>
        <span class="n">values</span><span class="o">=</span><span class="n">m2d</span><span class="o">.</span><span class="n">variable_manager</span><span class="o">.</span><span class="n">design_variables</span><span class="p">[</span><span class="s2">&quot;ElectricPeriod&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">numeric_value</span>
        <span class="o">/</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">unit_system</span><span class="o">=</span><span class="s2">&quot;Time&quot;</span><span class="p">,</span>
        <span class="n">input_units</span><span class="o">=</span><span class="s2">&quot;s&quot;</span><span class="p">,</span>
        <span class="n">output_units</span><span class="o">=</span><span class="s2">&quot;ns&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="s2">&quot;ns&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">stop_time</span> <span class="o">=</span> <span class="n">Quantity</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">start_time</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Find the indices corresponding to the start and stop times</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[56]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert Quantity objects to numeric values (time_intrinsics are in ns)</span>
<span class="n">numeric_start</span> <span class="o">=</span> <span class="n">start_time</span><span class="o">.</span><span class="n">value</span>
<span class="n">numeric_stop</span> <span class="o">=</span> <span class="n">stop_time</span><span class="o">.</span><span class="n">value</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[57]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Use numpy.searchsorted to find the indices in the numpy array</span>
<span class="n">index_start_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time_interval</span><span class="p">,</span> <span class="n">numeric_start</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">))</span>
<span class="n">index_stop_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time_interval</span><span class="p">,</span> <span class="n">numeric_stop</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[58]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Clamp indices to valid range</span>
<span class="n">index_start_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">index_start_time</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_interval</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">index_stop_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">index_stop_time</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_interval</span><span class="p">)))</span>
</pre></div>
</div>
</div>
</section>
<section id="Extract-the-torque-values-within-the-specified-time-range">
<h2>Extract the torque values within the specified time range<a class="headerlink" href="#Extract-the-torque-values-within-the-specified-time-range" title="Link to this heading">#</a></h2>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[59]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Ensure torque values are a numpy array for slicing</span>
<span class="n">torque_values</span> <span class="o">=</span> <span class="n">solutions</span><span class="o">.</span><span class="n">get_expression_data</span><span class="p">(</span><span class="n">formula</span><span class="o">=</span><span class="s2">&quot;Real&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">time_electric_period</span> <span class="o">=</span> <span class="n">time_interval</span><span class="p">[</span><span class="n">index_start_time</span><span class="p">:</span><span class="n">index_stop_time</span><span class="p">]</span>
<span class="n">torque_electric_period</span> <span class="o">=</span> <span class="n">torque_values</span><span class="p">[</span><span class="n">index_start_time</span><span class="p">:</span><span class="n">index_stop_time</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Plot the torque values within the specified time range with matplotlib</p>
<p>Plot the graph</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[60]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time_electric_period</span><span class="p">,</span> <span class="n">torque_electric_period</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[60]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[&lt;matplotlib.lines.Line2D at 0x16bc0f85180&gt;]
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../../../_images/examples_low_frequency_motor_aedt_motor_pm_synchronous_119_1.png" src="../../../../_images/examples_low_frequency_motor_aedt_motor_pm_synchronous_119_1.png" />
</div>
</div>
<p>Labels</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[61]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (ns)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Torque (Nm)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[61]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0, 0.5, &#39;Torque (Nm)&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../../../_images/examples_low_frequency_motor_aedt_motor_pm_synchronous_121_1.png" src="../../../../_images/examples_low_frequency_motor_aedt_motor_pm_synchronous_121_1.png" />
</div>
</div>
<p>Title</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[62]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Torque vs Time for Half Electric Period&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[62]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0.5, 1.0, &#39;Torque vs Time for Half Electric Period&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../../../_images/examples_low_frequency_motor_aedt_motor_pm_synchronous_123_1.png" src="../../../../_images/examples_low_frequency_motor_aedt_motor_pm_synchronous_123_1.png" />
</div>
</div>
<p>Uncomment the following line to display the matplotlib plot</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[63]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># plt.show()</span>
</pre></div>
</div>
</div>
</section>
<section id="Release-AEDT">
<h2>Release AEDT<a class="headerlink" href="#Release-AEDT" title="Link to this heading">#</a></h2>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">m2d</span><span class="o">.</span><span class="n">save_project</span><span class="p">()</span>
<span class="n">m2d</span><span class="o">.</span><span class="n">release_desktop</span><span class="p">()</span>
<span class="c1"># Wait 3 seconds to allow AEDT to shut down before cleaning the temporary directory.</span>
<span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
PyAEDT INFO: Project PM_Motor Saved correctly
PyAEDT INFO: Desktop has been released and closed.
</pre></div></div>
</div>
</section>
<section id="Clean-up">
<h2>Clean up<a class="headerlink" href="#Clean-up" title="Link to this heading">#</a></h2>
<p>All project files are saved in the folder <code class="docutils literal notranslate"><span class="pre">temp_folder.name</span></code>. If youâ€™ve run this example as a Jupyter notebook, you can retrieve those project files. The following cell removes all temporary files, including the project folder.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[65]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">temp_folder</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
</pre></div>
</div>
</div>
<script type="application/vnd.jupyter.widget-state+json">
{"state": {"6b3c8b785b48436ca06aa688c69d4a6f": {"model_name": "LayoutModel", "model_module": "@jupyter-widgets/base", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "2.0.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border_bottom": null, "border_left": null, "border_right": null, "border_top": null, "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": null, "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "padding": null, "right": null, "top": null, "visibility": null, "width": null}}, "fa295b667ce2496fbd6908dd6014eb8c": {"model_name": "HTMLStyleModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "HTMLStyleModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "2.0.0", "_view_name": "StyleView", "background": null, "description_width": "", "font_size": null, "text_color": null}}, "bca799681b6745338b59129d4e64760f": {"model_name": "HTMLModel", "model_module": "@jupyter-widgets/controls", "model_module_version": "2.0.0", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/controls", "_model_module_version": "2.0.0", "_model_name": "HTMLModel", "_view_count": null, "_view_module": "@jupyter-widgets/controls", "_view_module_version": "2.0.0", "_view_name": "HTMLView", "description": "", "description_allow_html": false, "layout": "IPY_MODEL_6b3c8b785b48436ca06aa688c69d4a6f", "placeholder": "\u200b", "style": "IPY_MODEL_fa295b667ce2496fbd6908dd6014eb8c", "tabbable": null, "tooltip": null, "value": "<iframe srcdoc=\"<!DOCTYPE html>\n<html>\n  <head>\n    <meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;/>\n    <meta name=&quot;viewport&quot; content=&quot;width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;>\n  </head>\n  <body>\n    <div class=&quot;content&quot;></div>\n<script type=&quot;text/javascript&quot;>\n!function(){var e={853:function(e,t,n){&quot;use strict&quot;;n.r(t),n.d(t,{initLocalFileLoader:function(){return XC},load:function(){return qC}});var r={};n.r(r),n.d(r,{add:function(){return J},adjoint:function(){return T},clone:function(){return d},copy:function(){return p},create:function(){return u},determinant:function(){return y},equals:function(){return oe},exactEquals:function(){return re},frob:function(){return Q},fromQuat:function(){return G},fromQuat2:function(){return L},fromRotation:function(){return R},fromRotationTranslation:function(){return D},fromRotationTranslationScale:function(){return _},fromRotationTranslationScaleOrigin:function(){return k},fromScaling:function(){return P},fromTranslation:function(){return O},fromValues:function(){return f},fromXRotation:function(){return M},fromYRotation:function(){return E},fromZRotation:function(){return V},frustum:function(){return U},getRotation:function(){return F},getScaling:function(){return N},getTranslation:function(){return B},identity:function(){return m},invert:function(){return v},lookAt:function(){return X},mul:function(){return ae},multiply:function(){return b},multiplyScalar:function(){return te},multiplyScalarAndAdd:function(){return ne},ortho:function(){return $},orthoNO:function(){return K},orthoZO:function(){return q},perspective:function(){return W},perspectiveFromFieldOfView:function(){return j},perspectiveNO:function(){return z},perspectiveZO:function(){return H},rotate:function(){return S},rotateX:function(){return A},rotateY:function(){return I},rotateZ:function(){return w},scale:function(){return C},set:function(){return g},str:function(){return Z},sub:function(){return ie},subtract:function(){return ee},targetTo:function(){return Y},translate:function(){return x},transpose:function(){return h}});var o={};n.r(o),n.d(o,{add:function(){return Ee},adjoint:function(){return he},clone:function(){return ce},copy:function(){return ue},create:function(){return se},determinant:function(){return ve},equals:function(){return Ne},exactEquals:function(){return Be},frob:function(){return Me},fromMat2d:function(){return Ie},fromMat4:function(){return le},fromQuat:function(){return we},fromRotation:function(){return Se},fromScaling:function(){return Ae},fromTranslation:function(){return Ce},fromValues:function(){return de},identity:function(){return fe},invert:function(){return me},mul:function(){return Fe},multiply:function(){return Te},multiplyScalar:function(){return De},multiplyScalarAndAdd:function(){return Le},normalFromMat4:function(){return Oe},projection:function(){return Pe},rotate:function(){return be},scale:function(){return xe},set:function(){return pe},str:function(){return Re},sub:function(){return _e},subtract:function(){return Ve},translate:function(){return ye},transpose:function(){return ge}});const a=document.querySelector(&quot;head&quot;);a&&[16,32,96,160,196].forEach((e=>{const t=document.createElement(&quot;link&quot;);t.setAttribute(&quot;rel&quot;,&quot;icon&quot;),t.setAttribute(&quot;href&quot;,`https://kitware.github.io/vtk-js/icon/favicon-${e}x${e}.png`),t.setAttribute(&quot;sizes&quot;,`${e}x${e}`),t.setAttribute(&quot;type&quot;,&quot;image/png&quot;),a.appendChild(t)}));var i=1e-6,s=&quot;undefined&quot;!=typeof Float32Array?Float32Array:Array;Math.random;var l=Math.PI/180;function c(e){return e*l}function u(){var e=new s(16);return s!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function d(e){var t=new s(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function p(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function f(e,t,n,r,o,a,i,l,c,u,d,p,f,g,m,h){var v=new s(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=i,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function g(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function m(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function h(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function T(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function y(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function b(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function x(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function C(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function S(e,t,n,r){var o,a,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<i?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(a=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+a,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+a,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+a,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function w(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function O(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function P(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function R(e,t,n){var r,o,a,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<i?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),a=1-(o=Math.cos(t)),e[0]=s*s*a+o,e[1]=l*s*a+c*r,e[2]=c*s*a-l*r,e[3]=0,e[4]=s*l*a-c*r,e[5]=l*l*a+o,e[6]=c*l*a+s*r,e[7]=0,e[8]=s*c*a+l*r,e[9]=l*c*a-s*r,e[10]=c*c*a+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function D(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function L(e,t){var n=new s(3),r=-t[0],o=-t[1],a=-t[2],i=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+i*i;return p>0?(n[0]=2*(l*i+d*r+c*a-u*o)/p,n[1]=2*(c*i+d*o+u*r-l*a)/p,n[2]=2*(u*i+d*a+l*o-c*r)/p):(n[0]=2*(l*i+d*r+c*a-u*o),n[1]=2*(c*i+d*o+u*r-l*a),n[2]=2*(u*i+d*a+l*o-c*r)),D(e,t,n),e}function B(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function N(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function F(e,t){var n=new s(3);N(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],i=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=i+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):i>d&&i>m?(v=2*Math.sqrt(1+i-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-i-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-i-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function _(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function k(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function G(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function U(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function z(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var W=z;function H(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function j(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function K(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var $=K;function q(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function X(e,t,n,r){var o,a,s,l,c,u,d,p,f,g,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<i&&Math.abs(v-S)<i&&Math.abs(T-A)<i?m(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=g=1/Math.hypot(d,p,f))-x*(p*=g),a=x*(d*=g)-y*f,s=y*p-b*d,(g=Math.hypot(o,a,s))?(o*=g=1/g,a*=g,s*=g):(o=0,a=0,s=0),l=p*s-f*a,c=f*o-d*s,u=d*a-p*o,(g=Math.hypot(l,c,u))?(l*=g=1/g,c*=g,u*=g):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=a,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+a*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function Y(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Z(e){return&quot;mat4(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;, &quot;+e[9]+&quot;, &quot;+e[10]+&quot;, &quot;+e[11]+&quot;, &quot;+e[12]+&quot;, &quot;+e[13]+&quot;, &quot;+e[14]+&quot;, &quot;+e[15]+&quot;)&quot;}function Q(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function J(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function te(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function ne(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function re(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function oe(e,t){var n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=i*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=i*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=i*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(a-C)<=i*Math.max(1,Math.abs(a),Math.abs(C))&&Math.abs(s-S)<=i*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=i*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=i*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=i*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=i*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=i*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=i*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=i*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=i*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=i*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=i*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=i*Math.max(1,Math.abs(T),Math.abs(L))}var ae=b,ie=ee;function se(){var e=new s(9);return s!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function le(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function ce(e){var t=new s(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ue(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function de(e,t,n,r,o,a,i,l,c){var u=new s(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=i,u[7]=l,u[8]=c,u}function pe(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function fe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function ge(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function he(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function ve(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function be(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function xe(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function Ce(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Se(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ie(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function Oe(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Pe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Re(e){return&quot;mat3(&quot;+e[0]+&quot;, &quot;+e[1]+&quot;, &quot;+e[2]+&quot;, &quot;+e[3]+&quot;, &quot;+e[4]+&quot;, &quot;+e[5]+&quot;, &quot;+e[6]+&quot;, &quot;+e[7]+&quot;, &quot;+e[8]+&quot;)&quot;}function Me(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Ee(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ve(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function De(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function Le(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Be(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Ne(e,t){var n=e[0],r=e[1],o=e[2],a=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=i*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=i*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=i*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(a-m)<=i*Math.max(1,Math.abs(a),Math.abs(m))&&Math.abs(s-h)<=i*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=i*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=i*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=i*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=i*Math.max(1,Math.abs(d),Math.abs(b))}var Fe=Te,_e=Ve,ke=n(730);const Ge=n(59)(),Ue={vtkObject:()=>null};function ze(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ge.console&&Ge.console.error&&Ge.console.error(&quot;Invalid VTK object&quot;),null;const t=Ue[e.vtkClass];if(!t)return Ge.console&&Ge.console.error&&Ge.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&&quot;object&quot;==typeof n[e]&&n[e].vtkClass&&(n[e]=ze(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}ze.register=function(e,t){Ue[e]=t};class We extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let He=0;const je=e=>{throw new Error(`Named parameter '${e}' is missing`)},Ke=Symbol(&quot;void&quot;),$e={};function qe(){}[&quot;log&quot;,&quot;debug&quot;,&quot;info&quot;,&quot;warn&quot;,&quot;error&quot;,&quot;time&quot;,&quot;timeEnd&quot;,&quot;group&quot;,&quot;groupEnd&quot;].forEach((e=>{$e[e]=qe})),Ge.console=console.hasOwnProperty(&quot;log&quot;)?console:$e;const Xe={debug:qe,error:Ge.console.error||qe,info:Ge.console.info||qe,log:Ge.console.log||qe,warn:Ge.console.warn||qe};function Ye(e,t){Xe[e]&&(Xe[e]=t||qe)}function Ze(){Xe.log(...arguments)}function Qe(){Xe.info(...arguments)}function Je(){Xe.debug(...arguments)}function et(){Xe.error(...arguments)}function tt(){Xe.warn(...arguments)}const nt={};function rt(e){nt[e]||(Xe.error(e),nt[e]=!0)}const ot=Object.create(null);ot.Float32Array=Float32Array,ot.Float64Array=Float64Array,ot.Uint8Array=Uint8Array,ot.Int8Array=Int8Array,ot.Uint16Array=Uint16Array,ot.Int16Array=Int16Array,ot.Uint32Array=Uint32Array,ot.Int32Array=Int32Array,ot.Uint8ClampedArray=Uint8ClampedArray;try{ot.BigInt64Array=BigInt64Array,ot.BigUint64Array=BigUint64Array}catch{}function at(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(ot[e]||Float64Array)(...n)}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(ot[e]||Float64Array).from(...n)}function st(e){return e.charAt(0).toUpperCase()+e.slice(1)}function lt(e){return st(&quot;_&quot;===e[0]?e.slice(1):e)}function ct(e){return e.charAt(0).toLowerCase()+e.slice(1)}function ut(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=[&quot;TB&quot;,&quot;GB&quot;,&quot;MB&quot;,&quot;KB&quot;];let o=Number(e),a=&quot;B&quot;;for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot; &quot;;const n=[];let r=e;for(;r>1e3;)n.push((&quot;000&quot;+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function pt(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function ft(e){return e&&e.isA?e.getState():e}function gt(e){setTimeout(e,0)}function mt(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function ht(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};pt(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++He),&quot;classHierarchy&quot;in t){if(!(t.classHierarchy instanceof We)){const e=new We;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new We(&quot;vtkObject&quot;);function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r&&r<e.getMTime()||(t.mtime=++He,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${st(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==[&quot;mtime&quot;].indexOf(i)||r||tt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||&quot;_&quot;===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(ft):function(e){return Object.values(ot).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&Je(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&Je(`Untouched keys: ${a.join(&quot;, &quot;)}`),e.modified()},e.toJSON=function(){return e.getState()},e}const vt={object(e,t,n){return function(){return{...t[n.name]}}}};function Tt(e,t,n){n.forEach((n=>{if(&quot;object&quot;==typeof n){const r=vt[n.type];e[`get${lt(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${lt(n)}`]=()=>t[n]}))}const yt={enum(e,t,n){const r=`_on${lt(n.name)}Changed`;return o=>{if(&quot;string&quot;==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw et(`Set Enum with invalid argument ${n}, ${o}`),new RangeError(&quot;Set Enum with invalid string argument&quot;)}if(&quot;number&quot;==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw et(`Set Enum outside numeric range ${n}, ${o}`),new RangeError(&quot;Set Enum outside numeric range&quot;)}return!1}throw et(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError(&quot;Set Enum with invalid argument (String/Number)&quot;)}},object(e,t,n){1===n.params?.length&&tt('Setter of type &quot;object&quot; with a single &quot;param&quot; field is not supported');const r=`_on${lt(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!ke(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function bt(e){if(&quot;object&quot;==typeof e){const t=yt[e.type];if(t)return(n,r)=>t(n,r,e);throw et(`No setter for field ${e}`),new TypeError(&quot;No setter for field&quot;)}return function(t,n){const r=`_on${lt(e)}Changed`;return function(o){if(n.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function xt(e,t,n){n.forEach((n=>{&quot;object&quot;==typeof n?e[`set${lt(n.name)}`]=bt(n)(e,t):e[`set${lt(n)}`]=bt(n)(e,t)}))}function Ct(e,t,n){Tt(e,t,n),xt(e,t,n)}function St(e,t,n){n.forEach((n=>{e[`get${lt(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${lt(n)}ByReference`]=()=>t[n]}))}function At(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${lt(n)}Changed`;e[`set${lt(n)}`]=function(){if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${lt(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;St(e,t,n),At(e,t,n,r,o)}function wt(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Ot(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?et(&quot;instance deleted - cannot call any method&quot;):r>=t.numberOfInputs?et(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)et(&quot;instance deleted - cannot call any method&quot;);else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=&quot; input ports. To add more input ports, use addInputConnection()&quot;,void et(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(et(&quot;instance deleted - cannot call any method&quot;),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(ze):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(ze):t.inputConnection=[],t.output?t.output=t.output.map(ze):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(ze):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):o(e,i())},e.addInputConnection=function(e){t.deleted?et(&quot;instance deleted - cannot call any method&quot;):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&!e.isDeleted()&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:&quot;Scalars&quot;;for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Pt=Symbol(&quot;Event abort&quot;);function Rt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${lt(n)}`]=function(){if(t.deleted)return void et(&quot;instance deleted - cannot call any method&quot;);const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Pt)break}},e[`on${lt(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return et(&quot;instance deleted - cannot call any method&quot;),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Mt(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&ze.register(t,n),n}function Et(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Vt(e){return e&&e.isA&&e.isA(&quot;vtkObject&quot;)}function Dt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Vt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Dt(e,t,n,r)})):Dt(o,t,n,r)}))}return n}function Lt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Bt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Nt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let Ft=1;const _t=&quot;__root__&quot;;function kt(e,t){Nt(e,t);const n=e.delete;t.proxyId=&quot;&quot;+Ft++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),Tt(e,t,[&quot;proxyId&quot;,&quot;proxyGroup&quot;,&quot;proxyName&quot;]),Ct(e,t,[&quot;proxyManager&quot;]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_t;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:_t]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${lt(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,_t),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,_t),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${lt(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${lt(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,gt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if(&quot;application&quot;===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,&quot;application&quot;),n.bind(e,o,i)}}}))}function Gt(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=lt(l),d=lt(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function Ut(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${lt(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&Tt(e,t,a)}function zt(e){let t=0,n=0,r=0,o=0;return&quot;detail&quot;in e&&(n=e.detail),&quot;wheelDelta&quot;in e&&(n=-e.wheelDelta/120),&quot;wheelDeltaY&quot;in e&&(n=-e.wheelDeltaY/120),&quot;wheelDeltaX&quot;in e&&(t=-e.wheelDeltaX/120),&quot;axis&quot;in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,&quot;deltaY&quot;in e&&(o=e.deltaY),&quot;deltaX&quot;in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Wt={algo:Ot,capitalize:st,chain:Et,debounce:Lt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Rt,EVENT_ABORT:Pt,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,get:Tt,getArray:St,getCurrentGlobalMTime:function(){return He},getStateArrayMapFunc:ft,isVtkObject:Vt,keystore:Nt,measurePromiseExecution:mt,moveToProtected:wt,newInstance:Mt,newTypedArray:at,newTypedArrayFrom:it,normalizeWheel:zt,obj:ht,proxy:kt,proxyPropertyMapping:Gt,proxyPropertyState:Ut,safeArrays:pt,set:xt,setArray:At,setGet:Ct,setGetArray:It,setImmediate:gt,setLoggerFunction:Ye,throttle:Bt,traverseInstanceTree:Dt,TYPED_ARRAYS:ot,uncapitalize:ct,VOID:Ke,vtkDebugMacro:Je,vtkErrorMacro:et,vtkInfoMacro:Qe,vtkLogMacro:Ze,vtkOnceErrorMacro:rt,vtkWarningMacro:tt,objectSetterMap:yt,requiredParam:je},Ht=Object.freeze({__proto__:null,requiredParam:je,VOID:Ke,setLoggerFunction:Ye,vtkLogMacro:Ze,vtkInfoMacro:Qe,vtkDebugMacro:Je,vtkErrorMacro:et,vtkWarningMacro:tt,vtkOnceErrorMacro:rt,TYPED_ARRAYS:ot,newTypedArray:at,newTypedArrayFrom:it,capitalize:st,_capitalize:lt,uncapitalize:ct,formatBytesToProperUnit:ut,formatNumbersWithThousandSeparator:dt,setImmediateVTK:gt,measurePromiseExecution:mt,obj:ht,get:Tt,set:xt,setGet:Ct,getArray:St,setArray:At,setGetArray:It,moveToProtected:wt,algo:Ot,EVENT_ABORT:Pt,event:Rt,newInstance:Mt,chain:Et,isVtkObject:Vt,traverseInstanceTree:Dt,debounce:Lt,throttle:Bt,keystore:Nt,proxy:kt,proxyPropertyMapping:Gt,proxyPropertyState:Ut,normalizeWheel:zt,default:Wt});const{vtkErrorMacro:jt}=Wt,Kt={renderable:null,myFactory:null,children:[],visited:!1};function $t(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kt,n),Wt.obj(e,t),Wt.event(e,t,&quot;event&quot;),t._renderableChildMap=new Map,Wt.get(e,t,[&quot;visited&quot;]),Wt.setGet(e,t,[&quot;_parent&quot;,&quot;renderable&quot;,&quot;myFactory&quot;]),Wt.getArray(e,t,[&quot;children&quot;]),Wt.moveToProtected(e,t,[&quot;parent&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkViewNode&quot;),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return jt(&quot;Cannot create view nodes without my own factory&quot;),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var qt={newInstance:Wt.newInstance($t,&quot;vtkViewNode&quot;),extend:$t,PASS_TYPES:[&quot;Build&quot;,&quot;Render&quot;]};const Xt={};function Yt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xt,n),Wt.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push(&quot;vtkViewNodeFactory&quot;),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Zt={newInstance:Wt.newInstance(Yt,&quot;vtkViewNodeFactory&quot;),extend:Yt};const Qt=Object.create(null);function Jt(e,t){Qt[e]=t}const en={};function tn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,en,n),t.overrides=Qt,Zt.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLViewNodeFactory&quot;)}(0,t)}var nn={newInstance:Wt.newInstance(tn,&quot;vtkOpenGLViewNodeFactory&quot;),extend:tn};const rn={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const on=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rn,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},Ct(e,t,[&quot;context&quot;,&quot;keyMatrixTime&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLCamera&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){p(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),le(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),me(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),h(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();p(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),h(t.keyMatrices.vcpc,t.keyMatrices.vcpc),b(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));Jt(&quot;vtkCamera&quot;,on);const{vtkDebugMacro:an}=Ht,sn={context:null,_openGLRenderWindow:null,selector:null};const ln=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sn,n),qt.extend(e,t,n),Tt(e,t,[&quot;shaderCache&quot;]),Ct(e,t,[&quot;selector&quot;]),wt(0,t,[&quot;openGLRenderWindow&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLRenderer&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(an(&quot;No lights are on, creating one.&quot;),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),&quot;vtkOpenGLRenderer&quot;);Jt(&quot;vtkRenderer&quot;,ln);const cn={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const un=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cn,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:fe(new Float64Array(9)),mcwc:m(new Float64Array(16))},Ct(e,t,[&quot;context&quot;]),Tt(e,t,[&quot;activeTextures&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor&quot;),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),p(t.keyMatrices.mcwc,t.renderable.getMatrix()),h(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?fe(t.keyMatrices.normalMatrix):(le(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),me(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));Jt(&quot;vtkActor&quot;,un);const dn={context:null,activeTextures:null};const pn=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dn,n),qt.extend(e,t,n),Ct(e,t,[&quot;context&quot;]),Tt(e,t,[&quot;activeTextures&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLActor2D&quot;),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA(&quot;vtkOpenGLTexture&quot;)?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function fn(){var e=new s(3);return s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function gn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function mn(e,t,n){var r=new s(3);return r[0]=e,r[1]=t,r[2]=n,r}function hn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function vn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function Tn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function yn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function bn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function xn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Cn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function Sn(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function An(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function On(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Pn(e,t){var n=e[0],r=e[1],o=e[2],a=t[0],s=t[1],l=t[2];return Math.abs(n-a)<=i*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(r-s)<=i*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=i*Math.max(1,Math.abs(o),Math.abs(l))}Jt(&quot;vtkActor2D&quot;,pn);var Rn=Tn,Mn=yn,En=(fn(),Math.sqrt(50)),Vn=Math.sqrt(10),Dn=Math.sqrt(2);function Ln(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=En?10:a>=Vn?5:a>=Dn?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=En?10:a>=Vn?5:a>=Dn?2:1)}function Bn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Nn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Bn,r=(t,n)=>Bn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const Fn=Nn(Bn),_n=Fn.right;Fn.left,Nn((function(e){return null===e?NaN:+e})).center;var kn=_n;function Gn(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function Un(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function zn(){}var Wn=.7,Hn=1/Wn,jn=&quot;\\\\s*([+-]?\\\\d+)\\\\s*&quot;,Kn=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*&quot;,$n=&quot;\\\\s*([+-]?(?:\\\\d*\\\\.)?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*&quot;,qn=/^#([0-9a-f]{3,8})$/,Xn=new RegExp(`^rgb\\\\(${jn},${jn},${jn}\\\\)$`),Yn=new RegExp(`^rgb\\\\(${$n},${$n},${$n}\\\\)$`),Zn=new RegExp(`^rgba\\\\(${jn},${jn},${jn},${Kn}\\\\)$`),Qn=new RegExp(`^rgba\\\\(${$n},${$n},${$n},${Kn}\\\\)$`),Jn=new RegExp(`^hsl\\\\(${Kn},${$n},${$n}\\\\)$`),er=new RegExp(`^hsla\\\\(${Kn},${$n},${$n},${Kn}\\\\)$`),tr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function nr(){return this.rgb().formatHex()}function rr(){return this.rgb().formatRgb()}function or(e){var t,n;return e=(e+&quot;&quot;).trim().toLowerCase(),(t=qn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ar(t):3===n?new lr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?ir(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?ir(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Xn.exec(e))?new lr(t[1],t[2],t[3],1):(t=Yn.exec(e))?new lr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Zn.exec(e))?ir(t[1],t[2],t[3],t[4]):(t=Qn.exec(e))?ir(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=Jn.exec(e))?gr(t[1],t[2]/100,t[3]/100,1):(t=er.exec(e))?gr(t[1],t[2]/100,t[3]/100,t[4]):tr.hasOwnProperty(e)?ar(tr[e]):&quot;transparent&quot;===e?new lr(NaN,NaN,NaN,0):null}function ar(e){return new lr(e>>16&255,e>>8&255,255&e,1)}function ir(e,t,n,r){return r<=0&&(e=t=n=NaN),new lr(e,t,n,r)}function sr(e,t,n,r){return 1===arguments.length?((o=e)instanceof zn||(o=or(o)),o?new lr((o=o.rgb()).r,o.g,o.b,o.opacity):new lr):new lr(e,t,n,null==r?1:r);var o}function lr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function cr(){return`#${fr(this.r)}${fr(this.g)}${fr(this.b)}`}function ur(){const e=dr(this.opacity);return`${1===e?&quot;rgb(&quot;:&quot;rgba(&quot;}${pr(this.r)}, ${pr(this.g)}, ${pr(this.b)}${1===e?&quot;)&quot;:`, ${e})`}`}function dr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function pr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function fr(e){return((e=pr(e))<16?&quot;0&quot;:&quot;&quot;)+e.toString(16)}function gr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new hr(e,t,n,r)}function mr(e){if(e instanceof hr)return new hr(e.h,e.s,e.l,e.opacity);if(e instanceof zn||(e=or(e)),!e)return new hr;if(e instanceof hr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new hr(i,s,l,e.opacity)}function hr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function vr(e){return(e=(e||0)%360)<0?e+360:e}function Tr(e){return Math.max(0,Math.min(1,e||0))}function yr(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function br(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Gn(zn,or,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:nr,formatHex:nr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return mr(this).formatHsl()},formatRgb:rr,toString:rr}),Gn(lr,sr,Un(zn,{brighter(e){return e=null==e?Hn:Math.pow(Hn,e),new lr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Wn:Math.pow(Wn,e),new lr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new lr(pr(this.r),pr(this.g),pr(this.b),dr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:cr,formatHex:cr,formatHex8:function(){return`#${fr(this.r)}${fr(this.g)}${fr(this.b)}${fr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:ur,toString:ur})),Gn(hr,(function(e,t,n,r){return 1===arguments.length?mr(e):new hr(e,t,n,null==r?1:r)}),Un(zn,{brighter(e){return e=null==e?Hn:Math.pow(Hn,e),new hr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Wn:Math.pow(Wn,e),new hr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new lr(yr(e>=240?e-240:e+120,o,r),yr(e,o,r),yr(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new hr(vr(this.h),Tr(this.s),Tr(this.l),dr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=dr(this.opacity);return`${1===e?&quot;hsl(&quot;:&quot;hsla(&quot;}${vr(this.h)}, ${100*Tr(this.s)}%, ${100*Tr(this.l)}%${1===e?&quot;)&quot;:`, ${e})`}`}}));var xr=e=>()=>e;function Cr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):xr(isNaN(e)?t:e)}var Sr=function e(t){var n=function(e){return 1==(e=+e)?Cr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):xr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=sr(e)).r,(t=sr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Cr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+&quot;&quot;}}return r.gamma=e,r}(1);function Ar(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=sr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+&quot;&quot;}}}function Ir(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Dr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function wr(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Or(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Pr(e,t){var n,r={},o={};for(n in null!==e&&&quot;object&quot;==typeof e||(e={}),null!==t&&&quot;object&quot;==typeof t||(t={}),t)n in e?r[n]=Dr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ar((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return br((n-r/t)*t,i,o,a,s)}})),Ar((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return br((n-r/t)*t,o,a,i,s)}}));var Rr=/[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,Mr=new RegExp(Rr.source,&quot;g&quot;);function Er(e,t){var n,r,o,a=Rr.lastIndex=Mr.lastIndex=0,i=-1,s=[],l=[];for(e+=&quot;&quot;,t+=&quot;&quot;;(n=Rr.exec(e))&&(r=Mr.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Or(n,r)})),a=Mr.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+&quot;&quot;}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join(&quot;&quot;)})}function Vr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Dr(e,t){var n,r=typeof t;return null==t||&quot;boolean&quot;===r?xr(t):(&quot;number&quot;===r?Or:&quot;string&quot;===r?(n=or(t))?(t=n,Sr):Er:t instanceof or?Sr:t instanceof Date?wr:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Vr:Array.isArray(t)?Ir:&quot;function&quot;!=typeof t.valueOf&&&quot;function&quot;!=typeof t.toString||isNaN(t)?Pr:Or)(e,t)}function Lr(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Br(e){return+e}var Nr=[0,1];function Fr(e){return e}function _r(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function kr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=_r(o,r),a=n(i,a)):(r=_r(r,o),a=n(a,i)),function(e){return a(r(e))}}function Gr(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=_r(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=kn(e,t,1,r)-1;return a[n](o[n](t))}}function Ur(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var zr,Wr=/^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;function Hr(e){if(!(t=Wr.exec(e)))throw new Error(&quot;invalid format: &quot;+e);var t;return new jr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function jr(e){this.fill=void 0===e.fill?&quot; &quot;:e.fill+&quot;&quot;,this.align=void 0===e.align?&quot;>&quot;:e.align+&quot;&quot;,this.sign=void 0===e.sign?&quot;-&quot;:e.sign+&quot;&quot;,this.symbol=void 0===e.symbol?&quot;&quot;:e.symbol+&quot;&quot;,this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?&quot;&quot;:e.type+&quot;&quot;}function Kr(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf(&quot;e&quot;))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function $r(e){return(e=Kr(Math.abs(e)))?e[1]:NaN}function qr(e,t){var n=Kr(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1];return o<0?&quot;0.&quot;+new Array(-o).join(&quot;0&quot;)+r:r.length>o+1?r.slice(0,o+1)+&quot;.&quot;+r.slice(o+1):r+new Array(o-r.length+2).join(&quot;0&quot;)}Hr.prototype=jr.prototype,jr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?&quot;0&quot;:&quot;&quot;)+(void 0===this.width?&quot;&quot;:Math.max(1,0|this.width))+(this.comma?&quot;,&quot;:&quot;&quot;)+(void 0===this.precision?&quot;&quot;:&quot;.&quot;+Math.max(0,0|this.precision))+(this.trim?&quot;~&quot;:&quot;&quot;)+this.type};var Xr={&quot;%&quot;:(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+&quot;&quot;,d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString(&quot;en&quot;).replace(/,/g,&quot;&quot;):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>qr(100*e,t),r:qr,s:function(e,t){var n=Kr(e,t);if(!n)return e+&quot;&quot;;var r=n[0],o=n[1],a=o-(zr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join(&quot;0&quot;):a>0?r.slice(0,a)+&quot;.&quot;+r.slice(a):&quot;0.&quot;+new Array(1-a).join(&quot;0&quot;)+Kr(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Yr(e){return e}var Zr,Qr,Jr,eo=Array.prototype.map,to=[&quot;y&quot;,&quot;z&quot;,&quot;a&quot;,&quot;f&quot;,&quot;p&quot;,&quot;n&quot;,&quot;\u00b5&quot;,&quot;m&quot;,&quot;&quot;,&quot;k&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;,&quot;Z&quot;,&quot;Y&quot;];function no(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Ln(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=En?o*=10:a>=Vn?o*=5:a>=Dn&&(o*=2),t<e?-o:o}(e,t,n);switch((r=Hr(null==r?&quot;,f&quot;:r)).type){case&quot;s&quot;:var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor($r(t)/3)))-$r(Math.abs(e)))}(a,i))||(r.precision=o),Jr(r,i);case&quot;&quot;:case&quot;e&quot;:case&quot;g&quot;:case&quot;p&quot;:case&quot;r&quot;:null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,$r(t)-$r(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-(&quot;e&quot;===r.type));break;case&quot;f&quot;:case&quot;%&quot;:null!=r.precision||isNaN(o=function(e){return Math.max(0,-$r(Math.abs(e)))}(a))||(r.precision=o-2*(&quot;%&quot;===r.type))}return Qr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Ln(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function ro(){var e=function(){var e,t,n,r,o,a,i=Nr,s=Nr,l=Dr,c=Fr;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==Fr&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Gr:kr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Or)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Br),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Lr,u()},d.clamp=function(e){return arguments.length?(c=!!e||Fr,u()):c!==Fr},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(Fr,Fr);return e.copy=function(){return t=e,ro().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},Ur.apply(e,arguments),no(e)}Zr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Yr:(t=eo.call(e.grouping,Number),n=e.thousands+&quot;&quot;,function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?&quot;&quot;:e.currency[0]+&quot;&quot;,a=void 0===e.currency?&quot;&quot;:e.currency[1]+&quot;&quot;,i=void 0===e.decimal?&quot;.&quot;:e.decimal+&quot;&quot;,s=void 0===e.numerals?Yr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(eo.call(e.numerals,String)),l=void 0===e.percent?&quot;%&quot;:e.percent+&quot;&quot;,c=void 0===e.minus?&quot;\u2212&quot;:e.minus+&quot;&quot;,u=void 0===e.nan?&quot;NaN&quot;:e.nan+&quot;&quot;;function d(e){var t=(e=Hr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;&quot;n&quot;===T?(m=!0,T=&quot;g&quot;):Xr[T]||(void 0===h&&(h=12),v=!0,T=&quot;g&quot;),(f||&quot;0&quot;===t&&&quot;=&quot;===n)&&(f=!0,t=&quot;0&quot;,n=&quot;=&quot;);var y=&quot;$&quot;===p?o:&quot;#&quot;===p&&/[boxX]/.test(T)?&quot;0&quot;+T.toLowerCase():&quot;&quot;,b=&quot;$&quot;===p?a:/[%p]/.test(T)?l:&quot;&quot;,x=Xr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if(&quot;c&quot;===T)S=x(e)+S,e=&quot;&quot;;else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case&quot;.&quot;:o=t=r;break;case&quot;0&quot;:0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&&quot;+&quot;!==d&&(A=!1),p=(A?&quot;(&quot;===d?d:c:&quot;-&quot;===d||&quot;(&quot;===d?&quot;&quot;:d)+p,S=(&quot;s&quot;===T?to[8+zr/3]:&quot;&quot;)+S+(A&&&quot;(&quot;===d?&quot;)&quot;:&quot;&quot;),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):&quot;&quot;;switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=&quot;&quot;),n){case&quot;<&quot;:e=p+e+S+w;break;case&quot;=&quot;:e=p+w+e+S;break;case&quot;^&quot;:e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+&quot;&quot;},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=Hr(e)).type=&quot;f&quot;,e)),r=3*Math.max(-8,Math.min(8,Math.floor($r(t)/3))),o=Math.pow(10,-r),a=to[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:&quot;,&quot;,grouping:[3],currency:[&quot;$&quot;,&quot;&quot;]}),Qr=Zr.format,Jr=Zr.formatPrefix;var oo=n(318);const ao=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],io=[1,0,0,0,1,0,0,0,1],so=1e-6,lo=1e-12,{vtkErrorMacro:co,vtkWarningMacro:uo}=Wt;let po=0;function fo(e){return()=>co(`vtkMath::${e} - NOT IMPLEMENTED`)}function go(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function mo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function ho(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function vo(e){return e/180*Math.PI}function To(e){return 180*e/Math.PI}const{round:yo,floor:bo,ceil:xo,min:Co,max:So}=Math;const Ao=fo(&quot;ceilLog2&quot;),Io=fo(&quot;factorial&quot;);function wo(e){let t=1;for(;t<e;)t*=2;return t}function Oo(e){return e===wo(e)}const Po=fo(&quot;gaussian&quot;);function Ro(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Mo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Eo(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Vo(e,t){return e[0]*=t,e[1]*=t,e}function Do(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function Lo(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Bo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function No(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function Fo(e){const t=No(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function _o(e){const t=No(e,3);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t,e[3]/=t),t}function ko(e,t){return e[0]*t[0]+e[1]*t[1]}function Go(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function Uo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function zo(e){const t=Uo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Wo(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function Ho(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function jo(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function Ko(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function $o(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function qo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:so;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Xo=qo;function Yo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Zo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Qo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function Jo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes(&quot;e&quot;))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split(&quot;e&quot;);let r=&quot;&quot;;return+n[1]+t>0&&(r=&quot;+&quot;),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=Jo(e[0],n),t[1]=Jo(e[1],n),t[2]=Jo(e[2],n),t}function ta(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=ho(t),x=ho(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Zo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return uo(&quot;vtkMath::Jacobi: Error extracting eigenfunctions&quot;),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<lo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,mo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function na(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];ta([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function ra(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=ho(3),r=ho(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(mo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,mo(t,3,1,2)),r[2]=2;let u=0;if($o(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=ho(4);if(na(t,d),Qo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&mo(t,3,r[1],1),0!==r[0]&&mo(t,3,r[0],0)}function oa(e,t,n){let r,o,a,i,s,l;if(ta([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for(Ko(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,go(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Bo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);Fo(e);const c=Bo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void Ko(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,go(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,go(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);$o(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),Ko(n,n)}else Yo(n)}function aa(e,t,n){let r,o,a,i,s,l,c,u=0;const d=ho(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return uo(&quot;Unable to factor linear system&quot;),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=lo)return uo(&quot;Unable to factor linear system&quot;),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function ia(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function sa(e,t,n){if(2===n){const n=ho(2),r=Wo(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=ho(n);return 0===aa(e,r,n)?0:(ia(e,r,t,n),1)}function la(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||ho(n),a=r||ho(n);if(0===aa(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,ia(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ca(e,t,n,r){if(e<n)return uo(&quot;Insufficient number of samples. Underdetermined.&quot;),0;let o,a,i;const s=ho(n*n),l=ho(n),c=ho(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(ta(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function ua(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function da(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function pa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function fa(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ga(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ma(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function ha(e,t){const n=[0,0,0];ma(e,n),fa(n,t)}function va(e,t){const n=[0,0,0];pa(e,n),ga(n,t)}function Ta(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ya(e){return!(e[1]-e[0]<0)}function ba(e,t,n){return e<t?t:e>n?n:e}function xa(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=ba(e[0],t[0],n[0]),r[1]=ba(e[1],t[1],n[1]),r[2]=ba(e[2],t[2],n[2]),r}const Ca=fo(&quot;GetScalarTypeFittingRange&quot;),Sa=fo(&quot;GetAdjustedScalarRange&quot;);const Aa=e=>!Number.isFinite(e),{isFinite:Ia,isNaN:wa}=Number,Oa=wa;function Pa(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ra(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ma(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Ea(e){return Math.round(255*e)}var Va,Da={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:vo,degreesFromRadians:To,round:yo,floor:bo,ceil:xo,ceilLog2:Ao,min:Co,max:So,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Oo,nearestPowerOfTwo:wo,factorial:Io,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=ho(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){oo(`${e}`,{global:!0}),po=e},getSeed:function(){return po},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Po,add:Ro,subtract:Mo,multiplyScalar:Eo,multiplyScalar2D:Vo,multiplyAccumulate:Do,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:Lo,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Bo,norm:No,normalize:Fo,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=Lo(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=Lo(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Eo(n,o),!0},projectVector2D:function(e,t,n){const r=ko(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=ko(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Vo(n,o),!0},distance2BetweenPoints:Go,angleBetweenVectors:function(e,t){const n=[0,0,0];return Bo(e,t,n),Math.atan2(No(n),Lo(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:ko,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:Uo,normalize2D:zo,determinant2x2:Wo,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(go(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,go(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Wo(s,u,l,d),f=-Wo(i,c,l,d),g=+Wo(i,c,s,u),m=-Wo(o,u,a,d),h=+Wo(r,c,a,d),v=-Wo(r,c,o,u),T=+Wo(o,s,a,l),y=-Wo(r,i,a,l),b=+Wo(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:Ho,multiply3x3_mat3:jo,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&co(&quot;Number of columns of A must match number of rows of B.&quot;);const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:Ko,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Wo(i,c,s,u),p=-Wo(a,l,s,u),f=+Wo(a,l,i,c),g=-Wo(r,c,o,u),m=+Wo(n,l,o,u),h=-Wo(n,l,r,c),v=+Wo(r,i,o,s),T=-Wo(n,a,o,s),y=+Wo(n,a,r,i),b=n*d+r*p+o*f;0===b&&uo(&quot;Matrix has 0 determinant&quot;),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Yo,identity:Zo,isIdentity:function(e){return Xo(e,ao,arguments.length>1&&void 0!==arguments[1]?arguments[1]:so)},isIdentity3x3:function(e){return Xo(e,io,arguments.length>1&&void 0!==arguments[1]?arguments[1]:so)},determinant3x3:$o,quaternionToMatrix3x3:Qo,areEquals:qo,areMatricesEqual:Xo,roundNumber:Jo,roundVector:ea,matrix3x3ToQuaternion:na,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:ra,diagonalize3x3:oa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=$o(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];ra(a,t),Ko(a,a),jo(a,t,r),oa(r,n,r),jo(t,r,t),Ko(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:sa,invertMatrix:la,luFactorLinearSystem:aa,luSolveLinearSystem:ia,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return ta(e,3,t,n)},jacobiN:ta,solveHomogeneousLeastSquares:ca,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return uo(&quot;Insufficient number of samples. Underdetermined.&quot;),0;const s=ho(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>lo&&(p=0,s[u]=0);if(p&&1===o)return uo(&quot;Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()&quot;),ca(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=ho(n),f=ca(e,t,n,l));const m=ho(n*n),h=ho(n*n),v=ho(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=la(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:ua,hsv2rgb:da,lab2xyz:pa,xyz2lab:fa,xyz2rgb:ga,rgb2xyz:ma,rgb2lab:ha,lab2rgb:va,uninitializeBounds:Ta,areBoundsInitialized:ya,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:ba,clampVector:xa,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Ca,getAdjustedScalarRange:Sa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=ho(3),a=ho(3),i=ho(3),s=ho(3),l=ho(3),c=ho(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=No(s),d=No(l),p=No(i),f=ho(3);Bo(o,a,f);const g=No(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*Lo(o,c)/h,T=p*p*Lo(s,a)/h,y=u*u*Lo(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Aa,isNan:wa,isNaN:wa,isFinite:Ia,createUninitializedBounds:Pa,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ra,floatToHex2:Ma,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;#&quot;}${e.map(Ma).join(&quot;&quot;)}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Ea).join(&quot;, &quot;)})`:`rgba(${Ea(e[0]||0)}, ${Ea(e[1]||0)}, ${Ea(e[2]||0)}, ${e[3]||0})`}};function La(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Ba(){var e=new s(4);return s!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Na(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function Fa(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Va=new s(4),s!=Float32Array&&(Va[0]=0,Va[1]=0,Va[2]=0,Va[3]=0);var _a=function(e,t,n,r){var o=new s(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};fn(),mn(1,0,0),mn(0,1,0),Ba(),Ba(),se();const ka={};function Ga(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ka,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;transform&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkImplicitFunction&quot;),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Wt.vtkErrorMacro(&quot;not implemented&quot;)}}(e,t)}var Ua={newInstance:Wt.newInstance(Ga,&quot;vtkImplicitFunction&quot;),extend:Ga};const za=1e-6,Wa=&quot;coincide&quot;,Ha=&quot;disjoint&quot;;function ja(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function Ka(e,t,n,r){const o=[];Mo(e,t,o);const a=Lo(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function $a(e,t,n){const r=Lo(e,t);let o=Lo(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function qa(e,t,n,r){const o=[];Mo(e,t,o);const a=Lo(n,o),i=Lo(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Xa(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Mo(t,e,a),Mo(n,e,i);const s=Lo(r,i),l=Lo(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*za:s*za,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Ya(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Bo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<za){const r=[];return Mo(e,n,r),0===Lo(t,r)?o.error=Wa:o.error=Ha,o}let s;s=i[0]>i[1]&&i[0]>i[2]?&quot;x&quot;:i[1]>i[2]?&quot;y&quot;:&quot;z&quot;;const l=[],c=-Lo(t,e),u=-Lo(r,n);switch(s){case&quot;x&quot;:l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case&quot;y&quot;:l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case&quot;z&quot;:l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Ro(l,a,o.l1),o.intersection=!0,o}const Za={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:ja,projectPoint:Ka,projectVector:$a,generalizedProjectPoint:qa,intersectWithLine:Xa,intersectWithPlane:Ya,DISJOINT:Ha,COINCIDE:Wa},Qa={normal:[0,0,1],origin:[0,0,0]};function Ja(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qa,n),Ua.extend(e,t,n),Wt.setGetArray(e,t,[&quot;normal&quot;,&quot;origin&quot;],3),function(e,t){t.classHierarchy.push(&quot;vtkPlane&quot;),e.distanceToPlane=e=>ja(e,t.origin,t.normal),e.projectPoint=(e,n)=>{Ka(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>$a(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{qa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Xa(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Ya(e,n,t.origin,t.normal)}(e,t)}var ei={newInstance:Wt.newInstance(Ja,&quot;vtkPlane&quot;),extend:Ja,...Za};const ti=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ni(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function ri(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function oi(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ai(e){return oi(e,ti)}function ii(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function si(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)ii(e,...t[n]);else for(let n=0;n<t.length;n+=3)ii(e,...t.slice(n,n+3));return e}function li(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ci(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function di(e,t){return null==t?function(e){const t=[0,0,0];let n=-1,r=0,o=0;for(let a=0;a<3;++a)o=e[2*a+1]-e[2*a],o>r&&(r=o,n=a),t[a]=o>0?1:0;if(n<0)return di(e,.5);for(let n=0;n<3;++n)if(!t[n]){const t=.005*r;e[2*n]-=t,e[2*n+1]+=t}return e}(e):(e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e)}function pi(e,t,n,r){return!!ri(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function fi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function gi(e,t){return e[2*t+1]-e[2*t]}function mi(e){return[gi(e,0),gi(e,1),gi(e,2)]}function hi(e){return e.slice(0,2)}function vi(e){return e.slice(2,4)}function Ti(e){return e.slice(4,6)}function yi(e){const t=mi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function bi(e){if(ri(e)){const t=mi(e);return t[0]*t[0]+t[1]*t[1]+t[2]*t[2]}return null}function xi(e){const t=bi(e);return null!==t?Math.sqrt(t):null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){return t[0]=[e[0],e[2],e[4]],t[1]=[e[0],e[2],e[5]],t[2]=[e[0],e[3],e[4]],t[3]=[e[0],e[3],e[5]],t[4]=[e[1],e[2],e[4]],t[5]=[e[1],e[2],e[5]],t[6]=[e[1],e[3],e[4]],t[7]=[e[1],e[3],e[5]],t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)In(r[e],r[e],t);return ai(n),si(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ti),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=Lo(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=Lo(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=Lo(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ei.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!ri(e)||!ri(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!ri(e)||!ri(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ei.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}function Ni(e,t){for(let e=0;e<3;++e)t[e]=t[e]<1?1:t[e];let n=t[0]*t[1]*t[2];for(;n>e;){for(let e=0;e<3;++e)t[e]=t[e]>1?t[e]-1:1;n=t[0]*t[1]*t[2]}}function Fi(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];t=t<=0?1:t;let o=0;const a=[0,0,0];let i=-1,s=0;const l=mi(e),c=l[0]+l[1]+l[2],u=c*(.001/3);for(let e=0;e<3;++e)l[e]>s&&(i=e,s=l[e]),l[e]>u?(a[e]=1,o++):a[e]=0;const d=Ci(e),p=Si(e);if(o<1)return n[0]=1,n[1]=1,n[2]=1,r[0]=d[0]-.5,r[1]=p[0]+.5,r[2]=d[1]-.5,r[3]=p[1]+.5,r[4]=d[2]-.5,r[5]=p[2]+.5,1;let f=t;f/=a[0]?l[0]/c:1,f/=a[1]?l[1]/c:1,f/=a[2]?l[2]/c:1,f**=1/o;for(let e=0;e<3;++e)n[e]=a[e]?Math.floor(f*l[e]/c):1,n[e]=n[e]<1?1:n[e];Ni(t,n);const g=.5*l[i]/n[i];for(let e=0;e<3;++e)a[e]?(r[2*e]=d[e],r[2*e+1]=p[e]):(r[2*e]=d[e]-g,r[2*e+1]=p[e]+g);return n[0]*n[1]*n[2]}function _i(e,t){if(e[0]>=t[0]&&e[0]<=t[1]&&e[1]>=t[2]&&e[1]<=t[3]&&e[2]>=t[4]&&e[2]<=t[5])return 0;const n=[0,0,0];return e[0]<t[0]?n[0]=t[0]-e[0]:e[0]>t[1]&&(n[0]=e[0]-t[1]),e[1]<t[2]?n[1]=t[2]-e[1]:e[1]>t[3]&&(n[1]=e[1]-t[3]),e[2]<t[4]?n[2]=t[4]-e[2]:e[2]>t[5]&&(n[2]=e[2]-t[5]),Lo(n,n)}class ki{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ti))}getBounds(){return this.bounds}equals(e){return ni(this.bounds,e)}isValid(){return ri(this.bounds)}setBounds(e){return oi(this.bounds,e)}reset(){return ai(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return ii(this.bounds,...t)}addPoints(e){return si(this.bounds,e)}addBounds(e,t,n,r,o,a){return li(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ci(this.bounds,e,t,n)}setMaxPoint(e,t,n){return ui(this.bounds,e,t,n)}inflate(e){return di(this.bounds,e)}scale(e,t,n){return pi(this.bounds,e,t,n)}getCenter(){return fi(this.bounds)}getLength(e){return gi(this.bounds,e)}getLengths(){return mi(this.bounds)}getMaxLength(){return yi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getDiagonalLength2(){return bi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return hi(this.bounds)}getYRange(){return vi(this.bounds)}getZRange(){return Ti(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}computeDivisions(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return Fi(this.bounds,e,t,n)}distance2ToBounds(e){return _i(e,this.bounds)}}var Gi={newInstance:function(e){const t=e&&e.bounds;return new ki(t)},equals:ni,isValid:ri,setBounds:oi,reset:ai,addPoint:ii,addPoints:si,addBounds:li,setMinPoint:ci,setMaxPoint:ui,inflate:di,scale:pi,scaleAboutCenter:function(e,t,n,r){if(!ri(e))return!1;const o=fi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],pi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:fi,getLength:gi,getLengths:mi,getMaxLength:yi,getDiagonalLength:xi,getDiagonalLength2:bi,getMinPoint:Ci,getMaxPoint:Si,getXRange:hi,getYRange:vi,getZRange:Ti,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},computeDivisions:Fi,clampDivisions:Ni,distance2ToBounds:_i,INIT_BOUNDS:ti},Ui={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:zi}=Ui;function Wi(e){return()=>Wt.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Hi={allocatedRenderTime:10,coordinateSystem:zi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wt.obj(e,t),Wt.get(e,t,[&quot;estimatedRenderTime&quot;,&quot;allocatedRenderTime&quot;]),Wt.setGet(e,t,[&quot;_parentProp&quot;,&quot;coordinateSystem&quot;,&quot;dragable&quot;,&quot;pickable&quot;,&quot;renderTimeMultiplier&quot;,&quot;useBounds&quot;,&quot;visibility&quot;]),Wt.moveToProtected(e,t,[&quot;parentProp&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkProp&quot;),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=Wi(&quot;pick&quot;),e.hasKey=Wi(&quot;hasKey&quot;),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(zi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(zi.DISPLAY)}(e,t)}var Ki={newInstance:Wt.newInstance(ji,&quot;vtkProp&quot;),extend:ji,...Ui};const $i={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Gi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function qi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$i,n),Ki.extend(e,t,n),t.matrixMTime={},Wt.obj(t.matrixMTime),Wt.get(e,t,[&quot;isIdentity&quot;]),Wt.getArray(e,t,[&quot;orientation&quot;]),Wt.setGetArray(e,t,[&quot;origin&quot;,&quot;position&quot;,&quot;scale&quot;],3),Wt.setGet(e,t,[&quot;properties&quot;]),t.matrix=m(new Float64Array(16)),t.rotation=m(new Float64Array(16)),t.userMatrix=m(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push(&quot;vtkProp3D&quot;),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Ba();F(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>i?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[To(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return F(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(A(t.rotation,t.rotation,vo(n)),e.modified())},e.rotateY=n=>{0!==n&&(I(t.rotation,t.rotation,vo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(w(t.rotation,t.rotation,vo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=vo(n),s=Ba();Na(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),b(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=G(new Float64Array(16),n);b(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],m(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setOrientationFromQuaternion=n=>{const r=u();return G(r,n),!Xo(r,t.rotation)&&(t.rotation=r,e.modified(),!0)},e.setUserMatrix=n=>!Xo(t.userMatrix,n)&&(p(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){m(t.matrix),t.userMatrix&&b(t.matrix,t.matrix,t.userMatrix),x(t.matrix,t.matrix,t.origin),x(t.matrix,t.matrix,t.position),b(t.matrix,t.matrix,t.rotation),C(t.matrix,t.matrix,t.scale),x(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),h(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Gi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Wt.vtkDebugMacro(&quot;Recomputing bounds...&quot;),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);h(r,t.matrix),Gi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Gi.getCenter(t.bounds),e.getLength=()=>Gi.getLength(t.bounds),e.getXRange=()=>Gi.getXRange(t.bounds),e.getYRange=()=>Gi.getYRange(t.bounds),e.getZRange=()=>Gi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.getProperties=()=>(0===t.properties.length&&(t.properties[0]=e.makeProperty?.()),t.properties),e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Xi={newInstance:Wt.newInstance(qi,&quot;vtkProp3D&quot;),extend:qi};const Yi={FLAT:0,GOURAUD:1,PHONG:2},Zi={POINTS:0,WIREFRAME:1,SURFACE:2};var Qi={Shading:Yi,Representation:Zi,Interpolation:Yi};const{Representation:Ji,Interpolation:es}=Qi;function ts(e){return()=>Wt.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const ns={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:es.GOURAUD,representation:Ji.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;lighting&quot;,&quot;interpolation&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;metallic&quot;,&quot;roughness&quot;,&quot;normalStrength&quot;,&quot;emission&quot;,&quot;baseIOR&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;opacity&quot;,&quot;edgeVisibility&quot;,&quot;lineWidth&quot;,&quot;pointSize&quot;,&quot;backfaceCulling&quot;,&quot;frontfaceCulling&quot;,&quot;representation&quot;,&quot;diffuseTexture&quot;,&quot;metallicTexture&quot;,&quot;roughnessTexture&quot;,&quot;normalTexture&quot;,&quot;ambientOcclusionTexture&quot;,&quot;emissionTexture&quot;,&quot;ORMTexture&quot;,&quot;RMTexture&quot;]),Wt.setGetArray(e,t,[&quot;ambientColor&quot;,&quot;specularColor&quot;,&quot;diffuseColor&quot;,&quot;edgeColor&quot;],3),function(e,t){t.classHierarchy.push(&quot;vtkProperty&quot;),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=ts(&quot;ComputeCompositeColor&quot;),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=ts(&quot;AddShaderVariable&quot;),e.setInterpolationToFlat=()=>e.setInterpolation(es.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(es.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(es.PHONG),e.getInterpolationAsString=()=>Wt.enumToString(es,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Ji.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Ji.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Ji.POINTS),e.getRepresentationAsString=()=>Wt.enumToString(Ji,t.representation)}(e,t)}var os={newInstance:Wt.newInstance(rs,&quot;vtkProperty&quot;),extend:rs,...Qi};const as={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,as,n),Xi.extend(e,t,n),t.boundsMTime={},Wt.obj(t.boundsMTime),Wt.setGet(e,t,[&quot;backfaceProperty&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;,&quot;mapper&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkActor&quot;);const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=os.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var ss={newInstance:Wt.newInstance(is,&quot;vtkActor&quot;),extend:is};const ls={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},cs={VOID:&quot;&quot;,CHAR:&quot;Int8Array&quot;,SIGNED_CHAR:&quot;Int8Array&quot;,UNSIGNED_CHAR:&quot;Uint8Array&quot;,UNSIGNED_CHAR_CLAMPED:&quot;Uint8ClampedArray&quot;,SHORT:&quot;Int16Array&quot;,UNSIGNED_SHORT:&quot;Uint16Array&quot;,INT:&quot;Int32Array&quot;,UNSIGNED_INT:&quot;Uint32Array&quot;,FLOAT:&quot;Float32Array&quot;,DOUBLE:&quot;Float64Array&quot;};var us={DefaultDataType:cs.FLOAT,DataTypeByteSize:ls,VtkDataTypes:cs};const{vtkErrorMacro:ds}=Ht,{DefaultDataType:ps}=us;function fs(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function gs(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return fs(r,0,1)}return fs(e,t<0?0:t,n)}function ms(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function hs(e){return Object.prototype.toString.call(e).slice(8,-1)}const vs={computeRange:gs,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:fs,getDataType:hs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=No(r,t);a>n&&(n=a)}return n}},Ts={name:&quot;&quot;,numberOfComponents:1,dataType:ps,rangeTuple:[0,0]};function ys(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,Ts,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn(&quot;vtkDataArray.newInstance: no dataType provided, converting to Float32Array&quot;),!t.empty&&!t.values&&!t.size)throw new TypeError(&quot;Cannot create vtkDataArray object without: size > 0, values&quot;);if(t.values?Array.isArray(t.values)&&(t.values=it(t.dataType,t.values)):t.values=at(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=hs(t.values)),ht(e,t),xt(e,t,[&quot;name&quot;,&quot;numberOfComponents&quot;]),t.size%t.numberOfComponents!=0)throw new RangeError(&quot;model.size is not a multiple of model.numberOfComponents&quot;);!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=at(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push(&quot;vtkDataArray&quot;),e.dataChange=()=>{t.ranges=null,e.modified()},e.allocate=t=>{n(e.getNumberOfTuples()+t)},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>(e.resize(0),e),e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ms(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=gs(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ms(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>bs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=hs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ds(&quot;numberOfComponents must match&quot;);const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const bs=Mt(ys,&quot;vtkDataArray&quot;);var xs={newInstance:bs,extend:ys,...vs,...us};const Cs={clippingPlanes:[]};var Ss=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cs,n),Wt.obj(e,t),Wt.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push(&quot;vtkAbstractMapper&quot;),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA(&quot;vtkPlane&quot;)&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Wt.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},As=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Gi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),Ss(e,t,n),Wt.setGet(e,t,[&quot;viewSpecificProperties&quot;]),function(e,t){e.getBounds=()=>(Wt.vtkErrorMacro(&quot;vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED&quot;),Pa()),e.getCenter=()=>{const n=e.getBounds();return t.center=Gi.isValid(n)?Gi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Gi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Is,vtkWarningMacro:ws}=Wt,Os={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Ps(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Os,n),Wt.obj(e,t),function(e,t){t.classHierarchy.push(&quot;vtkFieldData&quot;);const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:ze(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.getArrays().map((e=>({data:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>&quot;number&quot;==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():&quot;&quot;},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Is(&quot;Unhandled case in passData&quot;);else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=xs.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Wt.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),ws(&quot;Unexpected case in interpolateData&quot;)}else t.insertTuples(s.getTuples());else Is(&quot;Unhandled case in interpolateData&quot;);else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=xs.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Wt.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var Rs={newInstance:Wt.newInstance(Ps,&quot;vtkFieldData&quot;),extend:Ps};const Ms={DEFAULT:0,SINGLE:1,DOUBLE:2};var Es={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Ms,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:&quot;vtkGhostType&quot;};const{AttributeTypes:Vs,AttributeCopyOperations:Ds}=Es,{vtkWarningMacro:Ls}=Wt,Bs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ns(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bs,n),Rs.extend(e,t,n),Wt.setGet(e,t,[&quot;activeScalars&quot;,&quot;activeNormals&quot;,&quot;activeTCoords&quot;,&quot;activeVectors&quot;,&quot;activeTensors&quot;,&quot;activeGlobalIds&quot;,&quot;activePedigreeIds&quot;]),t.arrays||(t.arrays={}),function(e,t){const n=[&quot;Scalars&quot;,&quot;Vectors&quot;,&quot;Normals&quot;,&quot;TCoords&quot;,&quot;Tensors&quot;,&quot;GlobalIds&quot;,&quot;PedigreeIds&quot;];function r(e){let t=n.find((t=>Vs[t.toUpperCase()]===e||&quot;number&quot;!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push(&quot;vtkDataSetAttributes&quot;);const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&&quot;PEDIGREEIDS&quot;===a.toUpperCase()&&!n.isA(&quot;vtkDataArray&quot;))return Ls(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Ls(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if(&quot;PEDIGREEIDS&quot;!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA(&quot;vtkDataArray&quot;))return Ls(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Ls(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ds.PASSDATA][Vs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ds.PASSDATA][Vs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ds).filter((e=>&quot;ALLCOPY&quot;!==e)).forEach((e=>{t.copyAttributeFlags[Ds[e]]=Object.keys(Vs).filter((e=>&quot;NUM_ATTRIBUTES&quot;!==e)).reduce(((e,t)=>(e[Vs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ds.COPYTUPLE][Vs.GLOBALIDS]=!1,t.copyAttributeFlags[Ds.INTERPOLATE][Vs.GLOBALIDS]=!1,t.copyAttributeFlags[Ds.COPYTUPLE][Vs.PEDIGREEIDS]=!1},e.initialize=Wt.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||&quot;vtkDataArray&quot;!==t.dataArrays[n].type||e.addArray(xs.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Fs={newInstance:Wt.newInstance(Ns,&quot;vtkDataSetAttributes&quot;),extend:Ns,...Es};const _s=[&quot;pointData&quot;,&quot;cellData&quot;,&quot;fieldData&quot;],ks={};function Gs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ks,n),Wt.obj(e,t),Wt.setGet(e,t,_s),Wt.getArray(e,t,[&quot;bounds&quot;],6),function(e,t){t.classHierarchy.push(&quot;vtkDataSet&quot;),_s.forEach((e=>{t[e]?t[e]=ze(t[e]):t[e]=Fs.newInstance()})),e.computeBounds=()=>{if(t.modifiedTime&&t.computeTime&&t.modifiedTime>t.computeTime||!t.computeTime){const n=e.getPoints();n?.getNumberOfPoints()?Gi.setBounds(t.bounds,n.getBoundsByReference()):t.bounds=Da.createUninitializedBounds(),t.computeTime=Wt.getCurrentGlobalMTime()}},e.getLength2=()=>{const t=e.getBoundsByReference();return t&&6===t.length?Gi.getDiagonalLength2(t):0},e.getLength=()=>Math.sqrt(e.getLength2()),e.getCenter=()=>{const t=e.getBoundsByReference();return t&&6===t.length?Gi.getCenter(t):[0,0,0]},e.getCellBounds=t=>{const n=e.getCell(t);return n?n.getBounds():Da.createUninitializedBounds()},e.getBounds=Wt.chain((()=>e.computeBounds),e.getBounds),e.getBoundsByReference=Wt.chain((()=>e.computeBounds),e.getBoundsByReference);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),_s.forEach((n=>{t[n]=Fs.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))};const r=e.getMTime;e.getMTime=()=>_s.reduce(((e,n)=>Math.max(e,t[n]?.getMTime()??e)),r()),e.initialize=()=>(_s.forEach((e=>t[e]?.initialize())),e)}(e,t)}var Us={newInstance:Wt.newInstance(Gs,&quot;vtkDataSet&quot;),extend:Gs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const zs={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var Ws={StructuredType:zs};const{StructuredType:Hs}=Ws;var js={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Hs.EMPTY:3===t?Hs.XYZ_GRID:2===t?e[0]===e[1]?Hs.YZ_PLANE:e[2]===e[3]?Hs.XZ_PLANE:Hs.XY_PLANE:1===t?e[0]<e[1]?Hs.X_LINE:e[2]<e[3]?Hs.Y_LINE:Hs.Z_LINE:Hs.SINGLE_POINT},...Ws};const{vtkErrorMacro:Ks}=Wt,$s={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:zs.EMPTY};function qs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$s,n),Us.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=fe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Wt.get(e,t,[&quot;indexToWorld&quot;,&quot;worldToIndex&quot;]),Wt.setGetArray(e,t,[&quot;origin&quot;,&quot;spacing&quot;],3),Wt.setGetArray(e,t,[&quot;direction&quot;],9),Wt.getArray(e,t,[&quot;extent&quot;],6),function(e,t){t.classHierarchy.push(&quot;vtkImageData&quot;),e.setExtent=function(){if(t.deleted)return Ks(&quot;instance deleted - cannot call any method&quot;),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=js.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ks(&quot;instance deleted - cannot call any method&quot;);else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ks(&quot;Bad dimension specification&quot;);n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ks(&quot;Requesting a point from an empty image.&quot;),null;const o=new Float64Array(3);switch(t.dataDescription){case zs.EMPTY:return null;case zs.SINGLE_POINT:break;case zs.X_LINE:o[0]=n;break;case zs.Y_LINE:o[1]=n;break;case zs.Z_LINE:o[2]=n;break;case zs.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case zs.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case zs.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case zs.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ks(&quot;Invalid dataDescription&quot;)}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Gi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Gi.inflate([...t.extent],.5),e.computeTransforms=()=>{O(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],C(t.indexToWorld,t.indexToWorld,t.spacing),v(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return In(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return In(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Gi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Gi.transformBounds(e,t.worldToIndex,n)},t._onOriginChanged=e.computeTransforms,t._onDirectionChanged=e.computeTransforms,t._onSpacingChanged=e.computeTransforms,e.computeTransforms(),e.getCenter=()=>Gi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Gi.computeCornerPoints(r,o,a),ea(o,o),ea(a,a);const i=e.getDimensions();xa(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),xa(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ks(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ks(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)};const n=e.initialize;e.initialize=()=>(e.set({direction:fe(t.direction),spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:zs.EMPTY}),n())}(e,t)}var Xs={newInstance:Wt.newInstance(qs,&quot;vtkImageData&quot;),extend:qs};const Ys={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var Zs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:Ys,Scale:{LINEAR:0,LOG10:1}},Qs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Js,Scale:el,VectorMode:tl}=Zs,{VtkDataTypes:nl}=xs,{ColorMode:rl}=Qs,{vtkErrorMacro:ol}=Wt;function al(e){return e}function il(e){return Math.floor(255*e+.5)}const sl={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:tl.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:el.LINEAR};function ll(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sl,n),Wt.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Wt.setGet(e,t,[&quot;vectorSize&quot;,&quot;vectorComponent&quot;,&quot;vectorMode&quot;,&quot;alpha&quot;,&quot;indexedLookup&quot;]),Wt.setArray(e,t,[&quot;mappingRange&quot;],2),Wt.getArray(e,t,[&quot;mappingRange&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkScalarsToColors&quot;),e.setVectorModeToMagnitude=()=>e.setVectorMode(tl.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(tl.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(tl.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)ol(&quot;Values and annotations do not have the same number of tuples so ignoring&quot;);else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===rl.DEFAULT&&(t.getDataType()===nl.UNSIGNED_CHAR||t.getDataType()===nl.UNSIGNED_CHAR_CLAMPED)||n===rl.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:&quot;vtkDataArray&quot;,name:&quot;temp&quot;,numberOfComponents:4,dataType:nl.UNSIGNED_CHAR},i=Wt.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=xs.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Js.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Js.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===tl.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==tl.MAGNITUDE||1!==c&&1!==s||(i=tl.COMPONENT));let u=0;switch(l>0&&(u=l),i){case tl.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case tl.RGBCOLORS:break;case tl.MAGNITUDE:default:{const o=xs.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=il(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===nl.UNSIGNED_CHAR)return n;const i=xs.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:nl.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=al;switch(n.getDataType()!==nl.FLOAT&&n.getDataType()!==nl.DOUBLE||(s=il),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return ol(&quot;Cannot convert colors&quot;),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==rl.DEFAULT||n.getDataType()!==nl.UNSIGNED_CHAR)&&r!==rl.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var cl={newInstance:Wt.newInstance(ll,&quot;vtkScalarsToColors&quot;),extend:ll,...Zs};const{vtkErrorMacro:ul}=Wt,dl={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function pl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,dl,n),cl.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Wt.obj(t.buildTime),t.opaqueFlagBuildTime={},Wt.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Wt.obj(t.insertTime,{mtime:0}),Wt.get(e,t,[&quot;buildTime&quot;]),Wt.setGet(e,t,[&quot;numberOfColors&quot;,&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;]),Wt.setArray(e,t,[&quot;alphaRange&quot;,&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;],2),Wt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),Wt.getArray(e,t,[&quot;hueRange&quot;,&quot;saturationRange&quot;,&quot;valueRange&quot;,&quot;alphaRange&quot;,&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkLookupTable&quot;),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Oa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===Ys.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===Ys.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,da(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return ul(&quot;Expected 4 components for RGBA colors&quot;),!1;if(n.getDataType()!==cs.UNSIGNED_CHAR)return ul(&quot;Expected unsigned char values for RGBA colors&quot;),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var fl={newInstance:Wt.newInstance(pl,&quot;vtkLookupTable&quot;),extend:pl};const gl={Off:0,PolygonOffset:1};let ml=gl.PolygonOffset,hl=gl.Off;const vl=[&quot;VTK_RESOLVE_OFF&quot;,&quot;VTK_RESOLVE_POLYGON_OFFSET&quot;];function Tl(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=hl===e;return hl=e,t}var yl={Resolve:gl,getResolveCoincidentTopologyAsString:function(){return vl[hl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return ml},getResolveCoincidentTopology:function(){return hl},setResolveCoincidentTopology:Tl,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=ml===e;return ml=e,t},setResolveCoincidentTopologyToDefault:function(){return Tl(gl.Off)},setResolveCoincidentTopologyToOff:function(){return Tl(gl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return Tl(gl.PolygonOffset)}};function bl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Wt.objectSetterMap.object(e,t,{name:n.key,params:[&quot;factor&quot;,&quot;offset&quot;]})}))}const xl=[&quot;Polygon&quot;,&quot;Line&quot;,&quot;Point&quot;],Cl={modified:()=>{}};bl(Cl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},xl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var Sl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Wt.setGet(e,t,[&quot;resolveCoincidentTopology&quot;]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(yl).forEach((t=>{e[t]=yl[t]})),Object.keys(Cl).filter((e=>&quot;modified&quot;!==e)).forEach((t=>{e[t]=Cl[t]})),bl(e,t.topologyOffset,xl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=Cl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=Cl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=Cl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:Cl,otherStaticMethods:yl,CATEGORIES:xl,Resolve:gl};const Al={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Il={PassTypes:Al};const{FieldAssociations:wl}=Us,{staticOffsetAPI:Ol,otherStaticMethods:Pl}=Sl,{ColorMode:Rl,ScalarMode:Ml,GetArray:El}=Qs,{VectorMode:Vl}=Zs,{VtkDataTypes:Dl}=xs;function Ll(e){return()=>Wt.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Bl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Nl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Fl=new WeakMap;const _l={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function kl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_l,n),As(e,t,n),Wt.get(e,t,[&quot;areScalarsMappedFromCells&quot;,&quot;colorCoordinates&quot;,&quot;colorMapColors&quot;,&quot;colorTextureMap&quot;,&quot;numberOfColorsInRange&quot;,&quot;selectionWebGLIdsToVTKIds&quot;]),Wt.setGet(e,t,[&quot;colorByArrayName&quot;,&quot;arrayAccessMode&quot;,&quot;colorMode&quot;,&quot;fieldDataTupleId&quot;,&quot;interpolateScalarsBeforeMapping&quot;,&quot;lookupTable&quot;,&quot;populateSelectionSettings&quot;,&quot;renderTime&quot;,&quot;scalarMode&quot;,&quot;scalarVisibility&quot;,&quot;static&quot;,&quot;useLookupTableScalarRange&quot;,&quot;customShaderAttributes&quot;]),Wt.setGetArray(e,t,[&quot;scalarRange&quot;],2),Sl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push(&quot;vtkMapper&quot;),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Pa(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=fl.newInstance()},e.getColorModeAsString=()=>Wt.enumToString(Rl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Wt.enumToString(Ml,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ml.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ml.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ml.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ml.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===El.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ml.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===El.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ml.USE_FIELD_DATA){const t=e.getFieldData();i=r===El.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Bl(y,g)}const C=xs.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Xs.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Vl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join(&quot;/&quot;),c=Fl.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=xs.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Nl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=Number(v[I+e]);t+=n*n}e=Math.sqrt(t)}else e=Number(v[I+t]);if(r&&(e=Math.log10(e)),I+=y,Oa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Nl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Fl.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===Rl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===Rl.DEFAULT&&e.getDataType()===Dl.UNSIGNED_CHAR||t.colorMode===Rl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=Ll(&quot;AcquireInvertibleLookupTable&quot;),e.valueToColor=Ll(&quot;ValueToColor&quot;),e.colorToValue=Ll(&quot;ColorToValue&quot;),e.useInvertibleColorFor=Ll(&quot;UseInvertibleColorFor&quot;),e.clearInvertibleColor=Ll(&quot;ClearInvertibleColor&quot;),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(Al.ID_LOW24),o=e.getRawPixelBuffer(Al.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===wl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===wl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===Al.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(Al.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===Al.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(Al.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Gl={newInstance:Wt.newInstance(kl,&quot;vtkMapper&quot;),extend:kl,...Ol,...Pl,...Qs};const{isVtkObject:Ul}=Wt;function zl(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function Wl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Hl={extractCellSizes:zl,getNumberOfCells:Wl};function jl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};xs.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:cs.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push(&quot;vtkCellArray&quot;);const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=Wl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=zl(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{let r;r=Ul(n)?n.getPointsIds():n;const o=e.getNumberOfCells();return e.insertNextTuples([r.length,...r]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(r.length),o},e.getMaxCellSize=()=>e.getCellSizes().reduce(((e,t)=>Math.max(e,t)),0)}(e,t)}var Kl={newInstance:Wt.newInstance(jl,&quot;vtkCellArray&quot;),extend:jl,...Hl};const{vtkErrorMacro:$l}=Wt,ql={empty:!0,numberOfComponents:3,dataType:cs.FLOAT,bounds:[1,-1,1,-1,1,-1]};function Xl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ql,n),xs.extend(e,t,n),Wt.getArray(e,t,[&quot;bounds&quot;],6),function(e,t){let n=0;t.classHierarchy.push(&quot;vtkPoints&quot;),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Wt.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.insertPoint=(t,n)=>e.insertTuple(t,n);const r=e.getBounds;e.getBounds=()=>(n<t.mtime&&e.computeBounds(),r());const o=e.getBoundsByReference;e.getBoundsByReference=()=>(n<t.mtime&&e.computeBounds(),o()),e.computeBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);t.bounds[4]=o[0],t.bounds[5]=o[1]}else if(2===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0}else $l(`getBounds called on an array with components of ${e.getNumberOfComponents()}`),Ta(t.bounds);n=Wt.getCurrentGlobalMTime()},e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var Yl={newInstance:Wt.newInstance(Xl,&quot;vtkPoints&quot;),extend:Xl};const Zl={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Ql(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zl,n),Wt.obj(e,t),t.points||(t.points=Yl.newInstance()),Wt.get(e,t,[&quot;points&quot;,&quot;pointsIds&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkCell&quot;),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Wt.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>t.points.getBounds(),e.getLength2=()=>{const t=Gi.getLengths(e.getBounds());return t[0]*t[0]+t[1]*t[1]+t[2]*t[2]},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Wt.vtkErrorMacro(&quot;vtkCell.evaluatePosition is not implemented.&quot;)}}(e,t)}var Jl={newInstance:Wt.newInstance(Ql,&quot;vtkCell&quot;),extend:Ql};const ec={array:null,maxId:0,extend:0};function tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ec,n),Wt.obj(e,t),function(e,t){t.classHierarchy.push(&quot;vtkCellLinks&quot;),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA(&quot;vtkPolyData&quot;)){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Jl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Jl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var nc={newInstance:Wt.newInstance(tc,&quot;vtkCellLinks&quot;),extend:tc};const rc=0,oc=1,ac=2,ic=3,sc=4,lc=5,cc=6,uc=7,dc=9,pc=21,fc=41,gc=42,mc=[&quot;vtkEmptyCell&quot;,&quot;vtkVertex&quot;,&quot;vtkPolyVertex&quot;,&quot;vtkLine&quot;,&quot;vtkPolyLine&quot;,&quot;vtkTriangle&quot;,&quot;vtkTriangleStrip&quot;,&quot;vtkPolygon&quot;,&quot;vtkPixel&quot;,&quot;vtkQuad&quot;,&quot;vtkTetra&quot;,&quot;vtkVoxel&quot;,&quot;vtkHexahedron&quot;,&quot;vtkWedge&quot;,&quot;vtkPyramid&quot;,&quot;vtkPentagonalPrism&quot;,&quot;vtkHexagonalPrism&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkQuadraticEdge&quot;,&quot;vtkQuadraticTriangle&quot;,&quot;vtkQuadraticQuad&quot;,&quot;vtkQuadraticTetra&quot;,&quot;vtkQuadraticHexahedron&quot;,&quot;vtkQuadraticWedge&quot;,&quot;vtkQuadraticPyramid&quot;,&quot;vtkBiQuadraticQuad&quot;,&quot;vtkTriQuadraticHexahedron&quot;,&quot;vtkQuadraticLinearQuad&quot;,&quot;vtkQuadraticLinearWedge&quot;,&quot;vtkBiQuadraticQuadraticWedge&quot;,&quot;vtkBiQuadraticQuadraticHexahedron&quot;,&quot;vtkBiQuadraticTriangle&quot;,&quot;vtkCubicLine&quot;,&quot;vtkQuadraticPolygon&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkConvexPointSet&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkParametricCurve&quot;,&quot;vtkParametricSurface&quot;,&quot;vtkParametricTriSurface&quot;,&quot;vtkParametricQuadSurface&quot;,&quot;vtkParametricTetraRegion&quot;,&quot;vtkParametricHexRegion&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;UnknownClass&quot;,&quot;vtkHigherOrderEdge&quot;,&quot;vtkHigherOrderTriangle&quot;,&quot;vtkHigherOrderQuad&quot;,&quot;vtkHigherOrderPolygon&quot;,&quot;vtkHigherOrderTetrahedron&quot;,&quot;vtkHigherOrderWedge&quot;,&quot;vtkHigherOrderPyramid&quot;,&quot;vtkHigherOrderHexahedron&quot;],hc={getClassNameFromTypeId:function(e){return e<mc.length?mc[e]:&quot;UnknownClass&quot;},getTypeIdFromClassName:function(e){return mc.findIndex(e)},isLinear:function(e){return e<pc||e===fc||e===gc},hasSubCells:function(e){return e===cc||e===sc||e===ac}},vc={size:0,maxId:-1,extend:1e3};function Tc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vc,n),Wt.obj(e,t),Wt.get(e,t,[&quot;size&quot;,&quot;maxId&quot;,&quot;extend&quot;]),Wt.getArray(e,t,[&quot;typeArray&quot;,&quot;locationArray&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkCellTypes&quot;),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=rc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var yc={newInstance:Wt.newInstance(Tc,&quot;vtkCellTypes&quot;),extend:Tc,...hc};const bc={NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2};var xc={IntersectionState:bc};const{IntersectionState:Cc}=xc;function Sc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=Lo(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Go(i,e),o}function Ac(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Mo(t,e,i),Mo(r,n,s),Mo(n,e,l);const c=[Lo(i,i),-Lo(i,s),-Lo(i,s),Lo(s,s)],u=[];if(u[0]=Lo(i,l),u[1]=-Lo(s,l),0===sa(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=Sc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return Cc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?Cc.YES_INTERSECTION:Cc.NO_INTERSECTION}const Ic={distanceToLine:Sc,intersection:Ac},wc={orientations:null};function Oc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wc,n),Jl.extend(e,t,n),Wt.setGet(e,t,[&quot;orientations&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkLine&quot;),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=Ac(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===Cc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Go(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=Sc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=Sc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=Sc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=Sc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,a,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(a=u*g+d*m+p*h+f*v)<0&&(a=-a,g=-g,m=-m,h=-h,v=-v),1-a>i?(o=Math.acos(a),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Pc={newInstance:Wt.newInstance(Oc,&quot;vtkLine&quot;),extend:Oc,...Ic,...xc};const Rc={};function Mc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rc,n),Us.extend(e,t,n),Wt.setGet(e,t,[&quot;points&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkPointSet&quot;),t.points?t.points=ze(t.points):t.points=Yl.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=Yl.newInstance(),t.points.shallowCopy(e.getPoints())};const r=e.getMTime;e.getMTime=()=>{const e=r();return Math.max(e,t.points?.getMTime()??e)};const o=e.initialize;e.initialize=()=>(t.points?.initialize(),o())}(e,t)}var Ec={newInstance:Wt.newInstance(Mc,&quot;vtkPointSet&quot;),extend:Mc};const Vc={orientations:null,distanceFunction:function(e,t){var n=t[0]-e[0],r=t[1]-e[1],o=t[2]-e[2];return Math.hypot(n,r,o)}};function Dc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vc,n),Jl.extend(e,t,n),Wt.setGet(e,t,[&quot;orientations&quot;,&quot;distanceFunction&quot;]),t.distancesTime={},Wt.obj(t.distancesTime,{mtime:0}),function(e,t){t.classHierarchy.push(&quot;vtkPolyLine&quot;);const n=Pc.newInstance();n.getPoints().setNumberOfPoints(2),e.getCellDimension=()=>1,e.intersectWithLine=(r,o,a,i,s,l,c)=>{const u={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null},d=e.getNumberOfPoints()-1;let p=Number.MAX_VALUE;for(let e=0;e<d;e++){const d=[0,0,0];n.getPoints().getData().set(t.points.getData().subarray(3*e,3*(e+2)));const f=n.intersectWithLine(a,i,s,l,c);if(1===f.intersect&&f.t<=u.t+s&&f.t>=r&&f.t<=o){u.intersect=1;const t=n.getParametricDistance(d);if(t<p||t===p&&f.t<u.t){u.subId=e,u.t=f.t,p=t;for(let e=0;e<3;e++)l[e],d[e]}}}return u},e.evaluateLocation=(e,r,o,a)=>(n.getPoints().getData().set(t.points.getData().subarray(3*e,3*(e+2))),n.evaluateLocation(r,o,a)),e.evaluateOrientation=(e,r,o,a)=>(t.orientations?n.setOrientations([t.orientations[e],t.orientations[e+1]]):n.setOrientations(null),n.evaluateOrientation(r,o,a)),e.getDistancesToFirstPoint=()=>{const n=t.distancesTime.getMTime();if(n<t.points.getMTime()||n<e.getMTime()){const n=e.getNumberOfPoints();if(t.distances?t.distances.length=n:t.distances=new Array(n),n>0){const e=new Array(3),a=new Array(3);let i=0;t.distances[0]=i,t.points.getPoint(0,e);for(let s=1;s<n;++s)t.points.getPoint(s,a),i+=t.distanceFunction(e,a),t.distances[s]=i,o=a,(r=e)[0]=o[0],r[1]=o[1],r[2]=o[2]}t.distancesTime.modified()}var r,o;return t.distances},e.findPointIdAtDistanceFromFirstPoint=t=>{const n=e.getDistancesToFirstPoint();if(n.length<2)return-1;let r=0,o=n.length-1;if(t<n[r]||t>n[o]||0===n[o])return-1;for(;o-r>1;){const e=Math.floor((r+o)/2);n[e]<=t?r=e:o=e}return r}}(e,t)}var Lc={newInstance:Wt.newInstance(Dc,&quot;vtkPolyLine&quot;),extend:Dc};const Bc={elements:[]};function Nc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bc,n),Wt.obj(e,t),function(e,t){t.classHierarchy.push(&quot;vtkPriorityQueue&quot;),e.push=(e,n)=>{const r=t.elements.findIndex((t=>t.priority>e));t.elements.splice(r,0,{priority:e,element:n})},e.pop=()=>t.elements.length>0?t.elements.shift().element:null,e.deleteById=e=>{t.elements=t.elements.filter((t=>{let{element:n}=t;return n.id!==e}))},e.length=()=>t.elements.length}(e,t)}var Fc={newInstance:Wt.newInstance(Nc,&quot;vtkPriorityQueue&quot;),extend:Nc};const _c=1e-6,kc=1.1920929e-7,Gc={FAILURE:-1,OUTSIDE:0,INSIDE:1,INTERSECTION:2,ON_LINE:3};function Uc(e,t,n,r,o){return(r[e]-n[e])*(o[t]-n[t])-(o[e]-n[e])*(r[t]-n[t])}const zc={PolygonWithPointIntersectionState:Gc,pointInPolygon:function(e,t,n,r){if(e[0]<n[0]||e[0]>n[1]||e[1]<n[2]||e[1]>n[3]||e[2]<n[4]||e[2]>n[5])return Gc.OUTSIDE;if(Fo(r)<=kc)return Gc.FAILURE;let o=1e-8*((n[1]-n[0])*(n[1]-n[0])+(n[3]-n[2])*(n[3]-n[2])+(n[5]-n[4])*(n[5]-n[4]));o*=o,o=0===o?kc:o;const a=[],i=[];for(let n=0;n<t.length;){if(a[0]=t[n++],a[1]=t[n++],a[2]=t[n++],Go(e,a)<=o)return Gc.INSIDE;const{distance:r,t:s}=Pc.distanceToLine(e,a,i);if(r<=o&&s>0&&s<1)return Gc.INSIDE}let s,l;Math.abs(r[0])>Math.abs(r[1])?Math.abs(r[0])>Math.abs(r[2])?(s=1,l=2):(s=0,l=1):Math.abs(r[1])>Math.abs(r[2])?(s=0,l=2):(s=0,l=1);let c=0;for(let n=0;n<t.length;)a[0]=t[n++],a[1]=t[n++],a[2]=t[n++],n<t.length?(i[0]=t[n],i[1]=t[n+1],i[2]=t[n+2]):(i[0]=t[0],i[1]=t[1],i[2]=t[2]),a[l]<=e[l]?i[l]>e[l]&&Uc(s,l,a,i,e)>0&&++c:i[l]<=e[l]&&Uc(s,l,a,i,e)<0&&--c;return 0===c?Gc.OUTSIDE:Gc.INSIDE},getBounds:function(e,t,n){const r=e.length,o=[];t.getPoint(e[0],o),n[0]=o[0],n[1]=o[0],n[2]=o[1],n[3]=o[1],n[4]=o[2],n[5]=o[2];for(let a=1;a<r;a++)t.getPoint(e[a],o),Gi.addPoint(n,...o);const a=Gi.getLengths(n);return Lo(a,a)},getNormal:function(e,t,n){n.length=3,n[0]=0,n[1]=0,n[2]=0;const r=[];let o=[],a=[];const i=[],s=[];t.getPoint(e[0],r),t.getPoint(e[1],o);for(let l=2;l<e.length;l++){t.getPoint(e[l],a),Mo(a,o,i),Mo(r,o,s);const c=[0,0,0];Bo(i,s,c),Ro(n,c,n),[o,a]=[a,o]}return Fo(n)},computeCentroid:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[0,0,0];n[0]=0,n[1]=0,n[2]=0;const r=e.length,o=[];for(let a=0;a<r;a++)t.getPoint(e[a],o),n[0]+=o[0],n[1]+=o[1],n[2]+=o[2];return n[0]/=r,n[1]/=r,n[2]/=r,n}};function Wc(e,t){function n(e){const n=[0,0,0],r=[0,0,0],o=[0,0,0],a=[0,0,0];Mo(e.point,e.previous.point,n),Mo(e.next.point,e.point,r),Mo(e.previous.point,e.next.point,o),Bo(n,r,a);const i=Lo(a,t.normal);if(i<=0)return-1;const s=No(n)+No(r)+No(o);return s*s/i}function r(e){if(t.pointCount<=3)return!0;const n=e.previous,r=e.next,o=[0,0,0];Mo(r.point,n.point,o);const a=[0,0,0];if(Bo(o,t.normal,a),Fo(a),0===No(a))return!1;let i=ei.evaluate(a,n.point,r.next.point),s=i>_c?1:i<-1e-6?-1:0,l=s<0?1:0;for(let e=r.next.next;e.id!==n.id;e=e.next){const t=e.previous;i=ei.evaluate(a,n.point,e.point);const o=i>_c?1:i<-1e-6?-1:0;if(o!==s){if(l||(l=o<=0?1:0),Pc.intersection(n.point,r.point,e.point,t.point,[0],[0])===bc.YES_INTERSECTION)return!1;s=o}}return 1===l}function o(e,r){t.pointCount-=1;const o=e.previous,a=e.next;t.tris=t.tris.concat(e.point),t.tris=t.tris.concat(a.point),t.tris=t.tris.concat(o.point),o.next=a,a.previous=o,r.deleteById(o.id),r.deleteById(a.id);const i=n(o);i>0&&r.push(i,o);const s=n(a);s>0&&r.push(s,a),e.id===t.firstPoint.id&&(t.firstPoint=a)}t.classHierarchy.push(&quot;vtkPolygon&quot;),e.triangulate=()=>t.firstPoint?function(){!function(){const e=[0,0,0],n=[0,0,0];t.normal=[0,0,0];const r=[...t.firstPoint.point];let o=t.firstPoint;for(let a=0;a<t.pointCount;a++){Mo(o.point,r,e),Mo(o.next.point,r,n);const a=[0,0,0];Bo(e,n,a),Ro(t.normal,a,t.normal),o=o.next}Fo(t.normal)}();const e=Fc.newInstance();let a=t.firstPoint;for(let r=0;r<t.pointCount;r++){const t=n(a);t>0&&e.push(t,a),a=a.next}for(;t.pointCount>2&&e.length()>0;)if(t.pointCount===e.length())o(e.pop(),e);else{const t=e.pop();r(t)&&o(t,e)}return t.pointCount<=2}():null,e.setPoints=e=>{t.pointCount=e.length,t.firstPoint={id:0,point:e[0],next:null,previous:null};let n=t.firstPoint;for(let r=1;r<t.pointCount;r++)n.next={id:r,point:e[r],next:null,previous:n},n=n.next;t.firstPoint.previous=n,n.next=t.firstPoint},e.getPointArray=()=>t.tris}const Hc={firstPoint:null,pointCount:0,tris:[]};function jc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hc,n),Wt.obj(e,t),Wc(e,t)}var Kc={newInstance:Wt.newInstance(jc,&quot;vtkPolygon&quot;),extend:jc,...zc};function $c(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function qc(e,t,n,r){$c(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}function Xc(e){e[0]=-1,e[1]=1,e[2]=0,e[3]=-1,e[4]=0,e[5]=1}const Yc={computeNormalDirection:$c,computeNormal:qc,interpolationDerivs:Xc,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];qc(e,t,n,d),qc(r,o,a,p);const f=-Lo(d,e),g=-Lo(p,r),m=[Lo(p,e)+g,Lo(p,t)+g,Lo(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[Lo(d,r)+f,Lo(d,o)+f,Lo(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=Lo(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Bo(d,p,[]);Fo(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ei.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=Lo(a.x,S)-Lo(C,S));const s=ei.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=Lo(s.x,S)-Lo(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Do(C,S,P,l),Do(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Zc={};function Qc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zc,n),Jl.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkTriangle&quot;),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(qc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ei.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Go(u,d),h=Go(d,p),v=Go(p,u);t.line||(t.line=Pc.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=Lo(n,e)/v,i[1]=Lo(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),$c(l,c,u,d),ei.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Wo(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Wo(f,m)/h,r[1]=Wo(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Go(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Go(e,u),b=Pc.distanceToLine(e,l,u,t,S),x=Pc.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Go(e,l),b=Pc.distanceToLine(e,l,u,t,S),x=Pc.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Go(e,c),b=Pc.distanceToLine(e,c,u,t,S),x=Pc.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Pc.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Pc.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Pc.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n},e.derivatives=(e,n,r,o,a)=>{const i=t.points.getPoint(0),s=t.points.getPoint(1),l=t.points.getPoint(2),c=[],u=[],d=[],p=[];qc(i,s,l,c),Mo(s,i,u),Mo(l,i,p),Bo(c,u,d);const f=Fo(u);if(f<=0||Fo(d)<=0){for(let e=0;e<o;e++)for(let t=0;t<3;t++)a[e*o+t]=0;return}const g=[0,0],m=[f,0],h=[Lo(p,u),Lo(p,d)],v=new Array(6);Xc(v);const T=[m[0]-g[0],m[1]-g[1],h[0]-g[0],h[1]-g[1]],y=Wt.newTypedArray(ot.Float64Array,4);la(T,y,2);for(let e=0;e<o;e++){let t=0,n=0;for(let a=0;a<3;a++)t+=v[a]*r[o*a+e],n+=v[3+a]*r[o*a+e];const i=t*y[0]+n*y[1],s=t*y[2]+n*y[3];a[3*e]=i*u[0]+s*d[0],a[3*e+1]=i*u[1]+s*d[1],a[3*e+2]=i*u[2]+s*d[2]}},e.cellBoundary=(e,n,r)=>{const o=n[0]-n[1],a=.5*(1-n[0])-n[1],i=2*n[0]+n[1]-1;return o>=0&&a>=0?(r[0]=t.pointsIds[0],r[1]=t.pointsIds[1]):a<0&&i>=0?(r[0]=t.pointsIds[1],r[1]=t.pointsIds[2]):(r[0]=t.pointsIds[2],r[1]=t.pointsIds[0]),!(n[0]<0||n[1]<0||n[0]>1||n[1]>1||1-n[0]-n[1]<0)}}(e,t)}var Jc={newInstance:Wt.newInstance(Qc,&quot;vtkTriangle&quot;),extend:Qc,...Yc};const eu={};function tu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,eu,n),Jl.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkQuad&quot;),e.getCellDimension=()=>2,e.getCellType=()=>dc,e.getNumberOfEdges=()=>4,e.getNumberOfFaces=()=>0,e.intersectWithLine=(e,n,r,o,a)=>{let i,s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};const l=t.points.getPoint(0,[]),c=t.points.getPoint(1,[]),u=t.points.getPoint(2,[]),d=t.points.getPoint(3,[]),p=Go(l,u),f=Go(c,d);if(p===f){let e,n=0,r=0;for(let o=0;o<4;o++)e=t.pointsIds[o],e>n&&(n=e,r=o);i=0===r||2===r?0:1}else i=p<f?0:1;let g,m=null;t.triangle?m=t.triangle.getPoints():(t.triangle=Jc.newInstance(),m=Yl.newInstance(),m.setNumberOfPoints(3),t.triangle.initialize(m));const h=[0,0,0],v=[0,0,0];let T;const y=[0,0,0],b=[0,0,0];let x,C;switch(i){case 0:m.setPoint(0,...l),m.setPoint(1,...c),m.setPoint(2,...u),g=t.triangle.intersectWithLine(e,n,r,h,v),m.setPoint(0,...u),m.setPoint(1,...d),m.setPoint(2,...l),T=t.triangle.intersectWithLine(e,n,r,y,b),x=g.intersect&&T.intersect?g.t<=T.t:g.intersect,C=g.intersect&&T.intersect?T.t<g.t:T.intersect,x?(s=g,o[0]=h[0],o[1]=h[1],o[2]=h[2],a[0]=v[0]+v[1],a[1]=v[1],a[2]=v[2]):C&&(s=T,o[0]=y[0],o[1]=y[1],o[2]=y[2],a[0]=1-(b[0]+b[1]),a[1]=1-b[1],a[2]=b[2]);break;case 1:m.setPoint(0,...l),m.setPoint(1,...c),m.setPoint(2,...d),g=t.triangle.intersectWithLine(e,n,r,h,v),m.setPoint(0,...u),m.setPoint(1,...d),m.setPoint(2,...c),T=t.triangle.intersectWithLine(e,n,r,y,b),x=g.intersect&&T.intersect?g.t<=T.t:g.intersect,C=g.intersect&&T.intersect?T.t<g.t:T.intersect,x?(s=g,o[0]=h[0],o[1]=h[1],o[2]=h[2],a[0]=v[0],a[1]=v[1],a[2]=v[2]):C&&(s=T,o[0]=y[0],o[1]=y[1],o[2]=y[2],a[0]=1-b[0],a[1]=1-b[1],a[2]=b[2])}return s},e.interpolationFunctions=(e,t)=>{const n=1-e[0],r=1-e[1];t[0]=n*r,t[1]=e[0]*r,t[2]=e[0]*e[1],t[3]=n*e[1]},e.evaluateLocation=(n,r,o)=>{const a=[];e.interpolationFunctions(n,o),r[0]=0,r[1]=0,r[2]=0;for(let e=0;e<4;e++){t.points.getPoint(e,a);for(let t=0;t<3;t++)r[t]+=a[t]*o[e]}}}(e,t)}var nu={newInstance:Wt.newInstance(tu,&quot;vtkQuad&quot;),extend:tu};const{vtkErrorMacro:ru}=Wt;function ou(e){return()=>ru(`vtkTriangleStrip.${e} - NOT IMPLEMENTED`)}const au={decomposeStrip:function(e,t){if(!Array.isArray(e)||e.length<3)return void ru(&quot;decomposeStrip - Invalid points array&quot;);let n=e[0],r=e[1];for(let o=0;o<e.length-2;o++){const a=e[o+2];o%2?t.insertNextCell([r,n,a]):t.insertNextCell([n,r,a]),n=r,r=a}}},iu={line:null,triangle:null,tris:null};function su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,iu,n),Jl.extend(e,t,n),t.line||(t.line=Pc.newInstance()),t.triangle||(t.triangle=Jc.newInstance()),function(e,t){t.classHierarchy.push(&quot;vtkTriangleStrip&quot;);const n=e.initialize;e.initialize=(e,r)=>{t.triangle.initialize(e,r),n(e,r)},e.getCellType=()=>cc,e.getCellDimension=()=>2,e.getNumberOfEdges=()=>t.pointsIds.length,e.getNumberOfFaces=()=>0,e.evaluatePosition=(e,n,r,o,a)=>{const i=[0,0,0];let s=Number.MAX_VALUE,l=0;const c=[],u=[],d=[];r[2]=0,u[0]=0,u[1]=0,u[2]=0;const p=t.triangle.getPoints();p.setNumberOfPoints(3);const f=t.triangle.getPointsIds().length;for(let e=0;e<f;e++)a[e]=0;for(let o=0;o<f-2;o++){const a=[];p.getPoint(o,a);const f=[];p.getPoint(o+1,f);const g=[];p.getPoint(o+2,g),p.setData(Float32Array.from([...a,...f,...g]),3);const m=t.triangle.evaluatePosition(e,d,i,c),h=m.dist2;m.evaluation>=0&&(h<s||h===s&&0===l)&&(l=m,n&&(n[0]=d[0],n[1]=d[1],n[2]=d[2]),r[0]=i[0],r[1]=i[1],s=h,u[0]=c[0],u[1]=c[1],u[2]=c[2])}return o[0]=s,a[0]=u[0],a[1]=u[1],a[2]=u[2],l},e.evaluateLocation=(e,n,r,o)=>{const a=[[0,1,2],[1,0,2]],i=e%2,s=t.pointsIds.length;for(let e=0;e<s;e++)o[e]=0;const l=1-n[0]-n[1];o[e]=l,o[e+1]=n[0],o[e+2]=n[1];const c=[];t.points.getPoint(e+a[i][0],c);const u=[];t.points.getPoint(e+a[i][1],u);const d=[];t.points.getPoint(e+a[i][2],d);for(let t=0;t<3;t++)r[t]=c[t]*o[e]+u[t]*o[e+1]+d[t]*o[e+2]},e.cellBoundary=(e,n,r)=>{const o=[[0,1,2],[1,0,2]],a=e%2,i=t.triangle.getPointsIds();return i[0]=t.pointsIds[o[a][0]],i[1]=t.pointsIds[o[a][1]],i[2]=t.pointsIds[o[a][2]],t.triangle.cellBoundary(0,n,r)},e.getEdge=e=>{let n,r;const o=t.pointsIds.length;return 0===e?(n=0,r=1):e===o-1?(n=e-1,r=e):(n=e-1,r=e+1),t.line.getPointsIds()[0]=t.pointsIds[n],t.line.getPointsIds()[1]=t.pointsIds[r],t.line.getPoints().setPoint(0,t.points.getPoint(n)),t.line.getPoints().setPoint(1,t.points.getPoint(r)),t.line},e.intersectWithLine=(e,n,r,o,a)=>{const i=t.pointsIds.length-2,s=t.triangle.getPoints();s.setNumberOfPoints(3);for(let l=0;l<i;l++){const i=[];t.points.getPoint(t.pointsIds[l],i);const c=[];t.points.getPoint(t.pointsIds[l+1],c);const u=[];t.points.getPoint(t.pointsIds[l+2],u),s.setData(Float32Array.from([...i,...c,...u]),3);const d=t.triangle.intersectWithLine(e,n,r,o,a);if(d.intersect)return d}return!1},e.triangulate=()=>{const e=t.points.getNumberOfPoints()-2;t.tris=new Array(3*e);const n=[[0,1,2],[1,0,2]];for(let r=0;r<e;r++){const e=r%2;for(let o=0;o<3;o++)t.tris[3*r+o]=r+n[e][o]}return!0},e.getPointArray=()=>t.tris,e.derivatives=(e,n,r,o,a)=>{const i=[];t.points.getPoint(e,i);const s=[];t.points.getPoint(e+1,s);const l=[];t.points.getPoint(e+2,l);const c=t.triangle.getPoints();c.setPoint(0,...i),c.setPoint(1,...s),c.setPoint(2,...l),t.triangle.derivatives(0,n,r,o,a)},e.getParametricCenter=e=>(e[0]=.333333,e[1]=.333333,e[2]=0,Math.floor((t.pointsIds.length-2)/2)),e.contour=(e,t,n,r,o,a,i,s,l,c,u)=>ou(&quot;contour&quot;)(),e.clip=(e,t,n,r,o,a,i,s,l,c)=>ou(&quot;clip&quot;)()}(e,t)}var lu={newInstance:Wt.newInstance(su,&quot;vtkTriangleStrip&quot;),extend:su,...au};const cu=[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;],{vtkWarningMacro:uu}=Wt,du={[ic]:Pc,[dc]:nu,[sc]:Pc,[lc]:Jc,[cc]:lu,[sc]:Lc,[uc]:Kc},pu={};function fu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pu,n),Ec.extend(e,t,n),Wt.get(e,t,[&quot;cells&quot;,&quot;links&quot;]),Wt.setGet(e,t,[&quot;verts&quot;,&quot;lines&quot;,&quot;polys&quot;,&quot;strips&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkPolyData&quot;),cu.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\\w|[A-Z]|\\b\\w)/g,(e=>e.toUpperCase())).replace(/\\s+/g,&quot;&quot;)}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=ze(t[n]):t[n]=Kl.newInstance()})),e.getNumberOfCells=()=>cu.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),cu.forEach((n=>{t[n]=Kl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))};const r=e.getMTime;e.getMTime=()=>cu.reduce(((e,n)=>Math.max(e,t[n]?.getMTime()??e)),r());const o=e.initialize;e.initialize=()=>(cu.forEach((e=>t[e]?.initialize())),o()),e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?ac:oc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?sc:ic,1===t&&uu(&quot;Building VTK_LINE &quot;,n,&quot; with only one point, but VTK_LINE needs at least two points. Check the input.&quot;),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=lc;break;case 4:l[n]=dc;break;default:l[n]=uc}t<3&&uu(&quot;Building VTK_TRIANGLE &quot;,n,&quot; with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.&quot;),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(cc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=yc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=nc.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case oc:case ac:o=t.verts;break;case ic:case sc:o=t.lines;break;case lc:case dc:case uc:o=t.polys;break;case cc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||du[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o},e.getMaxCellSize=()=>cu.reduce(((e,n)=>Math.max(e,t[n]?.getMaxCellSize?.()??0)),0)}(e,t)}var gu={newInstance:Wt.newInstance(fu,&quot;vtkPolyData&quot;),extend:fu};const mu={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function hu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mu,n),Wt.obj(e,t),Wt.algo(e,t,6,0),Wt.get(e,t,[&quot;canvas&quot;,&quot;image&quot;,&quot;jsImageData&quot;,&quot;imageBitmap&quot;,&quot;imageLoaded&quot;,&quot;resizable&quot;]),Wt.setGet(e,t,[&quot;repeat&quot;,&quot;edgeClamp&quot;,&quot;interpolate&quot;,&quot;mipLevel&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkTexture&quot;),e.imageLoaded=()=>{t.image.removeEventListener(&quot;load&quot;,e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener(&quot;load&quot;,e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext(&quot;2d&quot;).getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext(&quot;2d&quot;);return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var vu={newInstance:Wt.newInstance(hu,&quot;vtkTexture&quot;),extend:hu,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:&quot;\\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\\n\\n    @compute @workgroup_size(8, 8)\\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\\n      let texelCoord = vec2<i32>(global_id.xy);\\n      let outputSize = textureDimensions(outputTexture);\\n\\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\\n        return;\\n      }\\n\\n      let inputSize = textureDimensions(inputTexture);\\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\\n\\n      // Compute the floating-point source coordinate\\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\\n\\n      // Get integer coordinates for the four surrounding texels\\n      let x0 = i32(floor(srcCoord.x));\\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\\n      let y0 = i32(floor(srcCoord.y));\\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\\n\\n      // Compute the weights\\n      let wx = srcCoord.x - f32(x0);\\n      let wy = srcCoord.y - f32(y0);\\n\\n      // Fetch the four texels\\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\\n\\n      // Bilinear interpolation\\n      let color = mix(\\n        mix(c00, c10, wx),\\n        mix(c01, c11, wx),\\n        wy\\n      );\\n\\n      textureStore(outputTexture, texelCoord, color);\\n    }\\n  &quot;}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:&quot;float&quot;}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:&quot;rgba8unorm&quot;,access:&quot;write-only&quot;}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:&quot;filtering&quot;}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:&quot;ComputeMipmapPipeline&quot;,layout:a,compute:{module:r,entryPoint:&quot;main&quot;}}),s=e.createSampler({magFilter:&quot;linear&quot;,minFilter:&quot;linear&quot;});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:&quot;MipmapGenerateCommandEncoder&quot;}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const Tu=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],yu=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],bu=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],xu=[0,1,0,1,0,1,0,1,2,2,2,2],Cu=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Su=new Float64Array(3),Au=new Float64Array(3),Iu=new Float64Array(3),wu=new Float64Array(3),Ou=new Float64Array(3),Pu=new Float64Array(3),Ru=new Float64Array(16);function Mu(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Eu(e){const t=[],n=[];for(let r=0;r<3;r++){const o=ro().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const Vu=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Wt.obj(e,t),t.tmPolyData=gu.newInstance(),t.tmMapper=Gl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=ss.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Wt.setGet(e,t,[&quot;renderable&quot;]),Wt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;tmActor&quot;,&quot;ticks&quot;]),t.forceUpdate=!1,t.lastRedrawTime={},Wt.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Wt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Su[0]=c[3*n],Su[1]=c[3*n+1],Su[2]=c[3*n+2],In(Iu,Su,r),Iu[0]+=.1,In(Au,Iu,o),Tn(Ou,Au,Su),Iu[0]-=.1,Iu[1]+=.1,In(Au,Iu,o),Tn(Pu,Au,Su);for(let e=0;e<3;e++)Ou[e]/=.05*u[0],Pu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Su[0]=c[3*n],Su[1]=c[3*n+1],Su[2]=c[3*n+2],a[0]<-.5?bn(Iu,Ou,a[0]*i-l.width):a[0]>.5?bn(Iu,Ou,a[0]*i):bn(Iu,Ou,a[0]*i-l.width/2),vn(Su,Su,Iu),bn(Iu,Pu,a[1]*i-l.height/2),vn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,bn(Iu,Ou,l.width),vn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,bn(Iu,Pu,l.height),vn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,bn(Iu,Ou,l.width),Tn(Su,Su,Iu),s.points[3*d]=Su[0],s.points[3*d+1]=Su[1],s.points[3*d+2]=Su[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);h(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);v(Ru,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Su[0]=f[3*u],Su[1]=f[3*u+1],Su[2]=f[3*u+2],In(Iu,Su,n),Su[0]=f[3*u+3],Su[1]=f[3*u+4],Su[2]=f[3*u+5],In(wu,Su,n),Tn(Iu,Iu,wu);const r=[Iu[0],Iu[1]];zo(r),e.createPolyDataForOneLabel(g[d],u,n,Ru,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,Ru,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const m=xs.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(m),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),&quot;vtkCubeAxesActorHelper&quot;);function Du(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ss.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Gi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:Eu,...n,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:18,fontFamily:&quot;serif&quot;,...n?.axisTextStyle},tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:14,fontFamily:&quot;serif&quot;,...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=[&quot;X-Axis&quot;,&quot;Y-Axis&quot;,&quot;Z-Axis&quot;],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.tmTexture=vu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Gl.newInstance(),t.polyData=gu.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=ss.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=gu.newInstance(),Wt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;boundsScaleFactor&quot;,&quot;faceVisibilityAngle&quot;,&quot;gridLines&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;]),Wt.setGetArray(e,t,[&quot;dataBounds&quot;],6),Wt.setGetArray(e,t,[&quot;axisLabels&quot;],3),Wt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;camera&quot;,&quot;tmTexture&quot;,&quot;textValues&quot;,&quot;textPolyData&quot;,&quot;tickCounts&quot;,&quot;gridActor&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkCubeAxesActor&quot;),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();h(e,e);let n=!1;const r=Gi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Su[s]=t.dataBounds[a]-.1*r*Tu[a][s],Su[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Su[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),In(Iu,Su,e),Su[s]=t.dataBounds[a],In(wu,Su,e),Tn(Iu,wu,Iu),Cn(Iu,Iu),i=Iu[2]>o,t.camera.getParallelProjection()||(Cn(wu,wu),i=Sn(wu,Iu)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Cu[t][0]].length+2*r[Cu[t][1]].length,a+=r[Cu[t][0]].length+r[Cu[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=bu[e][0],l[3*u+2]=bu[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Cu[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][0]]=o[r],s[3*c+Cu[n][1]]=t.dataBounds[2*Cu[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][0]]=o[r],s[3*c+Cu[n][1]]=t.dataBounds[2*Cu[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Cu[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][1]]=o[r],s[3*c+Cu[n][0]]=t.dataBounds[2*Cu[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Cu[n][1]]=o[r],s[3*c+Cu[n][0]]=t.dataBounds[2*Cu[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[xu[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=yu[a][e];if(1===n[d]){const e=xu[d],n=3*bu[d][0],p=3*bu[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Cu[a][0]]=.5*(t.dataBounds[2*Cu[a][0]]+t.dataBounds[2*Cu[a][0]+1]),s[3*l+Cu[a][1]]=.5*(t.dataBounds[2*Cu[a][1]]+t.dataBounds[2*Cu[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[yu[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){Mu(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}Mu(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=wo(n),r=wo(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{Mu(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Gi.setBounds(t.bounds,t.gridActor.getBounds()),Gi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Wt.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var Lu={newInstance:Wt.newInstance(Du,&quot;vtkCubeAxesActor&quot;),extend:Du,newCubeAxesActorHelper:Vu,defaultGenerateTicks:Eu};const Bu={};const Nu=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bu,n),qt.extend(e,t,n),t.CubeAxesActorHelper=Lu.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLCubeAxesActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),&quot;vtkOpenGLCubeAxesActor&quot;);Jt(&quot;vtkCubeAxesActor&quot;,Nu);const Fu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var _u={ObjectType:Fu};const{ObjectType:ku}=_u,Gu={objectType:ku.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function Uu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gu,n),Wt.obj(e,t),Wt.get(e,t,[&quot;_openGLRenderWindow&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),Wt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),function(e,t){function n(e){switch(e){case ku.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case ku.TEXTURE_BUFFER:if(&quot;TEXTURE_BUFFER&quot;in t.context)return t.context.TEXTURE_BUFFER;case ku.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push(&quot;vtkOpenGLBufferObject&quot;);let r=null,o=null,a=!0,i=&quot;&quot;;e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i=&quot;Trying to upload array buffer to incompatible buffer.&quot;,!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var zu={newInstance:Wt.newInstance(Uu),extend:Uu,..._u};function Wu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:Hu}=Wt;const ju={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function Ku(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ju,n),zu.extend(e,t,n),Wt.setGet(e,t,[&quot;colorBO&quot;,&quot;elementCount&quot;,&quot;stride&quot;,&quot;colorBOStride&quot;,&quot;vertexOffset&quot;,&quot;normalOffset&quot;,&quot;tCoordOffset&quot;,&quot;tCoordComponents&quot;,&quot;colorOffset&quot;,&quot;colorComponents&quot;,&quot;customData&quot;]),Wt.get(e,t,[&quot;coordShift&quot;,&quot;coordScale&quot;,&quot;coordShiftAndScaleEnabled&quot;,&quot;inverseShiftAndScaleMatrix&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLCellArrayBufferObject&quot;),e.setType(Fu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=zu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===Zi.POINTS||&quot;verts&quot;===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===Zi.WIREFRAME||&quot;lines&quot;===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=Wu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,Fu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,Fu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Pn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Pn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(On(e,[0,0,0])&&On(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);xn(n,t);const r=new Float64Array(16);return _(r,Ba(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):Hu(&quot;Wrong type for coordScale, expected vec3 or null&quot;):Hu(&quot;Wrong type for coordShift, expected vec3 or null&quot;)}}(e,t)}var $u={newInstance:Wt.newInstance(Ku),extend:Ku};const{vtkErrorMacro:qu}=Wt,Xu={shaderType:&quot;Unknown&quot;,source:&quot;&quot;,error:&quot;&quot;,handle:0,dirty:!1,context:null};function Yu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xu,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;shaderType&quot;,&quot;source&quot;,&quot;error&quot;,&quot;handle&quot;,&quot;context&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkShader&quot;),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||&quot;Unknown&quot;===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e=&quot;Fragment&quot;===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return qu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Zu={newInstance:Wt.newInstance(Yu,&quot;vtkShader&quot;),extend:Yu};const{vtkErrorMacro:Qu}=Wt,Ju={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:&quot;&quot;,handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function ed(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ju,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Zu.newInstance(),t.vertexShader.setShaderType(&quot;Vertex&quot;),t.fragmentShader=Zu.newInstance(),t.fragmentShader.setShaderType(&quot;Fragment&quot;),t.geometryShader=Zu.newInstance(),t.geometryShader.setShaderType(&quot;Geometry&quot;),Wt.obj(e,t),Wt.get(e,t,[&quot;lastCameraMTime&quot;]),Wt.setGet(e,t,[&quot;error&quot;,&quot;handle&quot;,&quot;compiled&quot;,&quot;bound&quot;,&quot;md5Hash&quot;,&quot;vertexShader&quot;,&quot;fragmentShader&quot;,&quot;geometryShader&quot;,&quot;linked&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkShaderProgram&quot;),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Qu(`Links failed: ${t.error}`),0):(Qu(t.error),0):(Qu(t.fragmentShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),Qu(t.fragmentShader.getError()),0):(Qu(t.vertexShader.getSource().split(&quot;\\n&quot;).map(((e,t)=>`${t}: ${e}`)).join(&quot;\\n&quot;)),Qu(t.vertexShader.getError()),0),e.cleanup=()=>{&quot;Unknown&quot;!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error=&quot;Program has not been initialized, and/or does not have shaders.&quot;,!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Qu(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError(&quot;Invalid number of values for array&quot;);return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Qu(&quot;attempt to find uniform when the shader program is not linked&quot;),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Qu(&quot;attempt to find uniform when the shader program is not linked&quot;),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error=&quot;Shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===n.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error=&quot;Could not create shader program.&quot;,!1;t.handle=e,t.linked=!1}return&quot;Vertex&quot;===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),&quot;Fragment&quot;===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error=&quot;shader object was not initialized, cannot attach it.&quot;,!1;if(&quot;Unknown&quot;===e.getShaderType())return t.error=&quot;Shader object is of type Unknown and cannot be used.&quot;,!1;switch(0===t.handle&&(t.error=&quot;This shader program has not been initialized yet.&quot;),e.getShaderType()){case&quot;Vertex&quot;:return t.vertexShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case&quot;Fragment&quot;:return t.fragmentShaderHandle!==e.getHandle()?(t.error=&quot;The supplied shader was not attached to this program.&quot;,!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var td={newInstance:Wt.newInstance(ed,&quot;vtkShaderProgram&quot;),extend:ed,substitute:function(e,t,n,r){const o=&quot;string&quot;==typeof n?n:n.join(&quot;\\n&quot;),a=!1===r?t:new RegExp(t,&quot;g&quot;),i=e.replace(a,o);return{replace:i!==o,result:i}}};const nd={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function rd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nd,n),t.buffers=[],Wt.obj(e,t),Wt.get(e,t,[&quot;supported&quot;]),Wt.setGet(e,t,[&quot;forceEmulation&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLVertexArrayObject&quot;),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;)),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension(&quot;OES_vertex_array_object&quot;),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==Fu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var od={newInstance:Wt.newInstance(rd,&quot;vtkOpenGLVertexArrayObject&quot;),extend:rd};const ad={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},id={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function sd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,id,n),Wt.obj(e,t),t.shaderSourceTime={},Wt.obj(t.shaderSourceTime),t.attributeUpdateTime={},Wt.obj(t.attributeUpdateTime),Wt.setGet(e,t,[&quot;program&quot;,&quot;shaderSourceTime&quot;,&quot;VAO&quot;,&quot;attributeUpdateTime&quot;,&quot;CABO&quot;,&quot;primitiveType&quot;,&quot;pointPicking&quot;]),t.program=td.newInstance(),t.VAO=od.newInstance(),t.CABO=$u.newInstance(),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLHelper&quot;),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===Zi.POINTS||n===ad.Points?t.context.POINTS:e===Zi.WIREFRAME||n===ad.Lines||n===ad.TrisEdges||n===ad.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f(&quot;viewportSize&quot;,o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf(&quot;lineWidthStepSize&quot;,t/Math.ceil(t)),e.getProgram().setUniformf(&quot;halfLineWidth&quot;,n)}t.primitiveType===ad.Points||r.getProperty().getRepresentation()===Zi.POINTS?e.getProgram().setUniformf(&quot;pointSize&quot;,r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf(&quot;pointSize&quot;,e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=td.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform float pointSize;&quot;]).result,a=td.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot;  gl_PointSize = pointSize;&quot;],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=td.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;//VTK::PositionVC::Dec&quot;,&quot;uniform vec2 viewportSize;&quot;,&quot;uniform float lineWidthStepSize;&quot;,&quot;uniform float halfLineWidth;&quot;]).result,a=td.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;//VTK::PositionVC::Impl&quot;,&quot; if (halfLineWidth > 0.0)&quot;,&quot;   {&quot;,&quot;   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;&quot;,&quot;   vec4 tmpPos = gl_Position;&quot;,&quot;   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;&quot;,&quot;   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];&quot;,&quot;   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];&quot;,&quot;   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);&quot;,&quot;   }&quot;]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===ad.Points?2:t.primitiveType===ad.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var ld={newInstance:Wt.newInstance(sd),extend:sd,primTypes:ad};const cd={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},ud={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var dd={Wrap:cd,Filter:ud};const pd=new Float32Array(1),fd=new Int32Array(pd.buffer);var gd={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){pd[0]=e;const t=fd[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let md;const{Wrap:hd,Filter:vd}=dd,{VtkDataTypes:Td}=xs,{vtkDebugMacro:yd,vtkErrorMacro:bd,vtkWarningMacro:xd,requiredParam:Cd}=Ht,{toHalf:Sd}=gd;function Ad(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push(&quot;vtkOpenGLTexture&quot;),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;)),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(vd.LINEAR),e.setMagnificationFilter(vd.LINEAR)):(e.setMinificationFilter(vd.NEAREST),e.setMagnificationFilter(vd.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(hd.REPEAT),e.setWrapS(hd.REPEAT),e.setWrapT(hd.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Td.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:Td.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(vd.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==vd.LINEAR&&t.magnificationFilter!==vd.LINEAR||(void 0===md&&(md=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement(&quot;canvas&quot;);a.width=e,a.height=e;const i=a.getContext(&quot;webgl2&quot;);if(!i)return!1;const s=i.getExtension(&quot;EXT_texture_norm16&quot;);if(!s)return!1;const l=`#version 300 es\\n    void main() {\\n      gl_PointSize = ${e.toFixed(1)};\\n      gl_Position = vec4(0, 0, 0, 1);\\n    }\\n  `,c=&quot;#version 300 es\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n\\n    uniform sampler2D u_image;\\n\\n    out vec4 color;\\n\\n    void main() {\\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\\n        color = vec4(vec3(intColor.rrr), 1);\\n    }\\n    &quot;,u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension(&quot;WEBGL_lose_context&quot;);return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),md))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Oo(r)||!Oo(o))){const i=t.context.getExtension(&quot;OES_texture_half_float&quot;),s=wo(r),l=wo(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?gd.toHalf(gd.fromHalf(e[u][l+s+t])*h*(1-v)+gd.fromHalf(e[u][l+p+t])*h*v+gd.fromHalf(e[u][c+s+t])*m*(1-v)+gd.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==Td.UNSIGNED_SHORT&&e!==Td.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension(&quot;OES_texture_float_linear&quot;)&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:xd(&quot;impossible case&quot;),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||yd(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension(&quot;OES_texture_float_linear&quot;)&&xd(&quot;Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.&quot;),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(yd(&quot;Unsupported internal texture type!&quot;),yd(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case Td.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&Td.SHORT:return t.context.SHORT;case r()&&!o&&Td.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&Td.SHORT:case o&&Td.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case Td.FLOAT:case Td.VOID:default:return t.context.FLOAT}switch(n){case Td.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case Td.FLOAT:case Td.VOID:default:if(t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))return t.context.FLOAT;{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);if(e&&t.context.getExtension(&quot;OES_texture_half_float_linear&quot;))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case vd.NEAREST:return t.context.NEAREST;case vd.LINEAR:return t.context.LINEAR;case vd.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case vd.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case vd.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case vd.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case hd.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case hd.REPEAT:return t.context.REPEAT;case hd.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==Td.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==Td.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension(&quot;OES_texture_half_float&quot;);c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=Sd(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=Cd(&quot;width&quot;),height:o=Cd(&quot;height&quot;),numComps:a=Cd(&quot;numComps&quot;),dataType:i=Cd(&quot;dataType&quot;),data:c=Cd(&quot;data&quot;),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return bd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=Cd(&quot;width&quot;),height:o=Cd(&quot;height&quot;),numComps:a=Cd(&quot;numComps&quot;),dataType:i=Cd(&quot;dataType&quot;),data:c=Cd(&quot;data&quot;)}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return bd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=at(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=Cd(&quot;width&quot;),height:o=Cd(&quot;height&quot;),dataType:a=Cd(&quot;dataType&quot;),data:i=Cd(&quot;data&quot;)}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===Td.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):(bd(&quot;Failed to determine texture parameters.&quot;),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(Td.UNSIGNED_CHAR),e.getInternalFormat(Td.UNSIGNED_CHAR,4),e.getFormat(Td.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return bd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Oo(n.width)&&Oo(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(wo(n.width),wo(n.height));i=e.width,s=e.height;const t=e.getContext(&quot;2d&quot;);t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(Td.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Td.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(Td.UNSIGNED_CHAR),e.getInternalFormat(Td.UNSIGNED_CHAR,4),e.getFormat(Td.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(Td.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(Td.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):(bd(&quot;Failed to determine texture parameters.&quot;),!1)),e.create2DFilterableFromRaw=function(){let{width:t=Cd(&quot;width&quot;),height:n=Cd(&quot;height&quot;),numComps:r=Cd(&quot;numComps&quot;),dataType:o=Cd(&quot;dataType&quot;),data:a=Cd(&quot;data&quot;),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:xs.newInstance({numberOfComponents:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=Cd(&quot;width&quot;),height:n=Cd(&quot;height&quot;),dataArray:r=Cd(&quot;dataArray&quot;),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===Td.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===Td.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===Td.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===Td.FLOAT||i&&(n===Td.SHORT||n===Td.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=Cd(&quot;width&quot;),height:c=Cd(&quot;height&quot;),depth:u=Cd(&quot;depth&quot;),numComps:d=Cd(&quot;numComps&quot;),dataType:p=Cd(&quot;dataType&quot;),data:f=Cd(&quot;data&quot;),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=Td.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return bd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!ke(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=Cd(&quot;width&quot;),height:n=Cd(&quot;height&quot;),depth:r=Cd(&quot;depth&quot;),numComps:o=Cd(&quot;numComps&quot;),dataType:a=Cd(&quot;dataType&quot;),data:i=Cd(&quot;data&quot;),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:xs.newInstance({numberOfComponents:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=Cd(&quot;width&quot;),height:r=Cd(&quot;height&quot;),depth:o=Cd(&quot;depth&quot;),dataArray:a=Cd(&quot;dataArray&quot;),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=Td.UNSIGNED_CHAR;if(d===Td.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)?(y=Td.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=Td.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return bd(&quot;Failed to determine texture parameters.&quot;),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===Td.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=wo(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=wo(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===Td.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Id={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:hd.CLAMP_TO_EDGE,wrapT:hd.CLAMP_TO_EDGE,wrapR:hd.CLAMP_TO_EDGE,minificationFilter:vd.NEAREST,magnificationFilter:vd.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function wd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Id,n),qt.extend(e,t,n),t.sendParametersTime={},ht(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},ht(t.textureBuildTime,{mtime:0}),xt(e,t,[&quot;format&quot;,&quot;openGLDataType&quot;]),Ct(e,t,[&quot;keyMatrixTime&quot;,&quot;minificationFilter&quot;,&quot;magnificationFilter&quot;,&quot;wrapS&quot;,&quot;wrapT&quot;,&quot;wrapR&quot;,&quot;generateMipmap&quot;,&quot;oglNorm16Ext&quot;]),Tt(e,t,[&quot;width&quot;,&quot;height&quot;,&quot;volumeInfo&quot;,&quot;components&quot;,&quot;handle&quot;,&quot;target&quot;,&quot;allocatedGPUMemoryInBytes&quot;]),wt(0,t,[&quot;openGLRenderWindow&quot;]),Ad(e,t)}const Od=Mt(wd,&quot;vtkOpenGLTexture&quot;);var Pd={newInstance:Od,extend:wd,...dd};Jt(&quot;vtkTexture&quot;,Od);var Rd=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexMC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\nvoid main()\\n{\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::PrimID::Impl\\n\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,Md=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyDataFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the polydata mappers fragment shader\\n\\nuniform int PrimitiveIDOffset;\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// optional color passed in from the vertex shader, vertexColor\\n//VTK::Color::Dec\\n\\n// optional surface normal declaration\\n//VTK::Normal::Dec\\n\\n// extra lighting parameters\\n//VTK::Light::Dec\\n\\n// define vtkImageLabelOutlineOn\\n//VTK::ImageLabelOutlineOn\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// Depth Peeling Support\\n//VTK::DepthPeeling::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// label outline \\n//VTK::LabelOutline::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n//VTK::LabelOutlineHelperFunction\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  //VTK::Color::Impl\\n\\n  // Generate the normal if we are not passed in one\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Light::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,Ed=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=td.substitute(e,&quot;//VTK::Coincident::Dec&quot;,[&quot;uniform float cfactor;&quot;,&quot;uniform float coffset;&quot;]).result,t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(0!==a.factor?(e=td.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=td.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=td.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;&quot;).result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=td.substitute(e,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));&quot;,&quot;//VTK::UniformFlow::Impl&quot;],!1).result,e=td.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;&quot;).result):e=td.substitute(e,&quot;//VTK::Depth::Impl&quot;,&quot;gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;&quot;).result),n.Fragment=e}}},Vd=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=td.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&&quot;&quot;!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&&quot;&quot;!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:Dd}=Us,{primTypes:Ld}=ld,{Representation:Bd,Shading:Nd}=os,{ScalarMode:Fd}=Gl,{Filter:_d,Wrap:kd}=Pd,{vtkErrorMacro:Gd}=Ht,Ud={type:&quot;StartEvent&quot;},zd={type:&quot;EndEvent&quot;},{CoordinateSystem:Wd}=Ki;const Hd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:Al.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function jd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hd,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.primitives=[],t.primTypes=Ld,t.tmpMat3=fe(new Float64Array(9)),t.tmpMat4=m(new Float64Array(16));for(let e=Ld.Start;e<Ld.End;e++)t.primitives[e]=ld.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);Ct(e,t,[&quot;context&quot;]),t.VBOBuildTime={},ht(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},ht(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper&quot;),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType(&quot;vtkOpenGLActor&quot;),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Ld.Start;e<Ld.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=Rd,e.Fragment=Md,e.Geometry=&quot;&quot;},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let l=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;,&quot;uniform vec3 ambientColorUniform;&quot;,&quot;uniform vec3 diffuseColorUniform;&quot;];s&&(l=l.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let c=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];s&&(c=c.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),c=c.concat([&quot;  ambientColor = ambientColorUniform;&quot;,&quot;  diffuseColor = diffuseColorUniform;&quot;,&quot;  opacity = opacityUniform;&quot;]),s&&(c=c.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=td.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=td.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=td.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=td.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=td.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  ambientColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat([&quot;uniform float opacityUniformBF; // the fragment opacity&quot;,&quot;uniform float ambientIntensityBF; // the material ambient&quot;,&quot;uniform float diffuseIntensityBF; // the material diffuse&quot;,&quot;uniform vec3 ambientColorUniformBF; // ambient material color&quot;,&quot;uniform vec3 diffuseColorUniformBF; // diffuse material color&quot;]),s?(l=l.concat([&quot;uniform float specularIntensityBF; // the material specular intensity&quot;,&quot;uniform vec3 specularColorUniformBF; // intensity weighted color&quot;,&quot;uniform float specularPowerUniformBF;&quot;]),c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  specularColor = specularIntensityBF * specularColorUniformBF;&quot;,&quot;  specularPower = specularPowerUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])):c=c.concat([&quot;if (gl_FrontFacing == false) {&quot;,&quot;  ambientColor = ambientIntensityBF * ambientColorUniformBF;&quot;,&quot;  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;&quot;,&quot;  opacity = opacityUniformBF; }&quot;])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat([&quot;uniform samplerBuffer texture1;&quot;])),i=td.substitute(i,&quot;//VTK::Color::Impl&quot;,c).result):i=td.substitute(i,&quot;//VTK::Color::Impl&quot;,c.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result,i=td.substitute(i,&quot;//VTK::Color::Dec&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),i=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);let s=[];switch(a){case 0:o=td.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 1:o=td.substitute(o,&quot;//VTK::Light::Impl&quot;,[&quot;  float df = max(0.0, normalVCVSOutput.z);&quot;,&quot;  float sf = pow(df, specularPower);&quot;,&quot;  vec3 diffuseL = df * diffuseColor;&quot;,&quot;  vec3 specularL = sf * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=td.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,&quot;    {&quot;,`    float sf = sign(df)*pow(max(1e-5,\\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\\n                                                  normalize(-vertexVC.xyz))),\\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=td.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=td.substitute(o,&quot;//VTK::Light::Dec&quot;,s).result,s=[&quot;vec3 diffuseL = vec3(0,0,0);&quot;,&quot;  vec3 specularL = vec3(0,0,0);&quot;,&quot;  vec3 vertLightDirectionVC;&quot;,&quot;  float attenuation;&quot;,&quot;  float df;&quot;];for(let e=0;e<i;++e)s=s.concat([&quot;  attenuation = 1.0;&quot;,`  if (lightPositional${e} == 0)`,&quot;    {&quot;,`      vertLightDirectionVC = lightDirectionVC${e};`,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,&quot;    float distanceVC = length(vertLightDirectionVC);&quot;,&quot;    vertLightDirectionVC = normalize(vertLightDirectionVC);&quot;,&quot;    attenuation = 1.0 /&quot;,`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,&quot;    // per OpenGL standard cone angle is 90 or less for a spot light&quot;,`    if (lightConeAngle${e} <= 90.0)`,&quot;      {&quot;,`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,&quot;      // if inside the cone&quot;,`      if (coneDot >= cos(radians(lightConeAngle${e})))`,&quot;        {&quot;,`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,&quot;        }&quot;,&quot;      else&quot;,&quot;        {&quot;,&quot;        attenuation = 0.0;&quot;,&quot;        }&quot;,&quot;      }&quot;,&quot;    }&quot;,&quot;    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));&quot;,`    diffuseL += ((df) * lightColor${e});`,&quot;    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)&quot;,&quot;      {&quot;,`      float sf = sign(df)*attenuation*pow(max(1e-5,\\n                                                           dot(reflect(lightDirectionVC${e},\\n                                                                       normalVCVSOutput),\\n                                                               normalize(-vertexVC.xyz))),\\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,&quot;    }&quot;]);s=s.concat([&quot;  diffuseL = diffuseL * diffuseColor;&quot;,&quot;  specularL = specularL * specularColor;&quot;,&quot;  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);&quot;,&quot;  //VTK::Light::Impl&quot;]),o=td.substitute(o,&quot;//VTK::Light::Impl&quot;,s,!1).result;break;default:Gd(&quot;bad light complexity&quot;)}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=td.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=td.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * normalMC;&quot;]).result,o=td.substitute(o,&quot;//VTK::Normal::Dec&quot;,[&quot;in vec3 normalVCVSOutput[];&quot;,&quot;out vec3 normalVCGSOutput;&quot;]).result,o=td.substitute(o,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCGSOutput = normalVCVSOutput[i];&quot;]).result,a=td.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;varying vec3 normalVCVSOutput;&quot;]).result,a=td.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalVCVSOutput);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.haveCellNormals?(a=td.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform mat3 normalMatrix;&quot;,&quot;uniform samplerBuffer textureN;&quot;]).result,a=td.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput = normalize(normalMatrix *&quot;,&quot;    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);&quot;,&quot;  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }&quot;]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=td.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=td.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;vec3 normalVCVSOutput;&quot;,&quot;  if (abs(fdx.x) > 0.0)&quot;,&quot;    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }&quot;,&quot;  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}&quot;]).result):(a=td.substitute(a,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;&quot;]).result,a=td.substitute(a,&quot;//VTK::UniformFlow::Impl&quot;,[&quot;  vec3 fdx = dFdx(vertexVC.xyz);&quot;,&quot;  vec3 fdy = dFdy(vertexVC.xyz);&quot;,&quot;  //VTK::UniformFlow::Impl&quot;]).result,a=td.substitute(a,&quot;//VTK::Normal::Impl&quot;,[&quot;  fdx = normalize(fdx);&quot;,&quot;  fdy = normalize(fdy);&quot;,&quot;  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));&quot;,&quot;  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;,&quot;  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }&quot;]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(o=td.substitute(o,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,o=td.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCVSOutput = MCVCMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,o=td.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,a=td.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,[&quot;in vec4 vertexVCVSOutput[];&quot;,&quot;out vec4 vertexVCGSOutput;&quot;]).result,a=td.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vertexVCGSOutput = vertexVCVSOutput[i];&quot;]).result,i=td.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=td.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;&quot;]).result):(o=td.substitute(o,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,o=td.substitute(o,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=td.substitute(n,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=td.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result,r=td.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=td.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=td.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,a&&a.length>=1)switch(i){case 1:o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}}else switch(n=td.substitute(n,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;&quot;).result,r=td.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec3 tcoordVCVSOutput[];&quot;,&quot;out vec3 tcoordVCGSOutput;&quot;]).result,r=td.substitute(r,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;).result,o=td.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;varying vec3 tcoordVCVSOutput;&quot;,&quot;uniform samplerCube texture1;&quot;]).result,i){case 1:o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;]).result;break;case 2:o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.r;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.r;&quot;,&quot;  opacity = opacity * tcolor.g;&quot;]).result;break;default:o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);&quot;,&quot;  ambientColor = ambientColor*tcolor.rgb;&quot;,&quot;  diffuseColor = diffuseColor*tcolor.rgb;&quot;,&quot;  opacity = opacity * tcolor.a;&quot;]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=td.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=td.substitute(o,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=td.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,a=td.substitute(a,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==gl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===Bd.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===Ld.Points||o.getRepresentation()===Bd.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===Ld.Lines||o.getRepresentation()===Bd.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==Ld.Tris&&e!==Ld.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==Ld.TrisEdges&&e!==Ld.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===Dd.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=td.substitute(o,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform int picking;&quot;,&quot;//VTK::Picking::Dec&quot;]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==Al.ID_LOW24&&t.lastSelectionState!==Al.ID_HIGH24||(a=td.substitute(a,&quot;//VTK::Picking::Dec&quot;,[&quot;flat out int vertexIDVSOutput;\\n&quot;,&quot;uniform int VertexIDOffset;\\n&quot;]).result,a=td.substitute(a,&quot;//VTK::Picking::Impl&quot;,&quot;  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\\n&quot;).result,o=td.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;flat in int vertexIDVSOutput;\\n&quot;).result,o=td.substitute(o,&quot;//VTK::Picking::Impl&quot;,[&quot;  int idx = vertexIDVSOutput;&quot;,&quot;//VTK::Picking::Impl&quot;]).result),t.lastSelectionState){case Al.ID_LOW24:o=td.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);&quot;).result;break;case Al.ID_HIGH24:o=td.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);&quot;).result;break;default:o=td.substitute(o,&quot;//VTK::Picking::Dec&quot;,&quot;uniform vec3 mapperIndex;&quot;).result,o=td.substitute(o,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=td.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=td.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===Nd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;),h=t.lastBoundBO.getReferenceByName(&quot;lastLightCount&quot;);return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&n.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),n.getProgram().isUniformUsed(&quot;VertexIDOffset&quot;)&&n.getProgram().setUniformi(&quot;VertexIDOffset&quot;,t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||Gd(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;normalMC&quot;)&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;normalMC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||Gd(&quot;Error setting normalMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;normalMC&quot;),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||Gd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||Gd(&quot;Error setting tcoordMC in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),n.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),&quot;scalarColor&quot;,n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Gd(&quot;Error setting scalarColor in shader VAO.&quot;):n.getVAO().removeAttributeArray(&quot;scalarColor&quot;),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?p(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(h(i,i),b(i,i,a),h(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,r)}t.internalColorTexture&&n.getProgram().isUniformUsed(&quot;texture1&quot;)&&n.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi(&quot;picking&quot;,i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],Fo(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],Fo(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();h(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);In(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),g=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===Wd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();m(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,b(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4)}else s.setUniformMatrix(&quot;MCPCMatrix&quot;,n([l.wcpc,g.mcwc,p],r,t.tmpMat4));s.isUniformUsed(&quot;MCVCMatrix&quot;)&&s.setUniformMatrix(&quot;MCVCMatrix&quot;,n([l.wcvc,g.mcwc,p],r,t.tmpMat4)),s.isUniformUsed(&quot;normalMatrix&quot;)&&s.setUniformMatrix3x3(&quot;normalMatrix&quot;,n([l.normalMatrix,g.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed(&quot;cameraParallel&quot;)&&s.setUniformi(&quot;cameraParallel&quot;,c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf(&quot;opacityUniform&quot;,i),o.setUniform3fArray(&quot;ambientColorUniform&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniform&quot;,l),o.setUniformf(&quot;ambient&quot;,c),o.setUniformf(&quot;diffuse&quot;,u);const f=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray(&quot;specularColorUniform&quot;,g),o.setUniformf(&quot;specularPowerUniform&quot;,p),o.setUniformf(&quot;specular&quot;,d),o.isUniformUsed(&quot;ambientIntensityBF&quot;)){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf(&quot;ambientIntensityBF&quot;,c),o.setUniformf(&quot;diffuseIntensityBF&quot;,u),o.setUniformf(&quot;opacityUniformBF&quot;,i),o.setUniform3fArray(&quot;ambientColorUniformBF&quot;,s),o.setUniform3fArray(&quot;diffuseColorUniformBF&quot;,l),f<1)return;o.setUniformf(&quot;specularIntensityBF&quot;,d),o.setUniform3fArray(&quot;specularColorUniformBF&quot;,g),o.setUniformf(&quot;specularPowerUniformBF&quot;,p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===Dd.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():Al.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===Bd.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===Dd.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===Al.ID_LOW24||t.lastSelectionState===Al.ID_HIGH24);for(let i=Ld.Start;i<Ld.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===Ld.TrisEdges||i===Ld.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(Ud),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(zd),!t.currentInput)return void Gd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==Fd.USE_CELL_DATA&&a!==Fd.USE_CELL_FIELD_DATA&&a!==Fd.USE_FIELD_DATA&&r.getPointData().getScalars()||a===Fd.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==Nd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Pd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(_d.NEAREST),e.setMagnificationFilter(_d.NEAREST),e.setWrapS(kd.CLAMP_TO_EDGE),e.setWrapT(kd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:&quot;verts&quot;,cells:r.getVerts()},{inRep:&quot;lines&quot;,cells:r.getLines()},{inRep:&quot;polys&quot;,cells:r.getPolys()},{inRep:&quot;strips&quot;,cells:r.getStrips()},{inRep:&quot;polys&quot;,cells:r.getPolys()},{inRep:&quot;strips&quot;,cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===Bd.SURFACE;for(let n=Ld.Start;n<Ld.End;n++)n!==Ld.TrisEdges&&n!==Ld.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,Bd.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const Kd=Mt(jd,&quot;vtkOpenGLPolyDataMapper&quot;);var $d={newInstance:Kd,extend:jd};Jt(&quot;vtkMapper&quot;,Kd);const qd=1,{primTypes:Xd}=ld,{Filter:Yd,Wrap:Zd}=Pd,{vtkErrorMacro:Qd}=Ht,Jd={type:&quot;StartEvent&quot;},ep={type:&quot;EndEvent&quot;},tp={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const np=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tp,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.primitives=[],t.primTypes=Xd,t.tmpMat4=m(new Float64Array(16));for(let e=Xd.Start;e<Xd.End;e++)t.primitives[e]=ld.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);Ct(e,t,[&quot;context&quot;]),t.VBOBuildTime={},ht(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLPolyDataMapper2D&quot;),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType(&quot;vtkOpenGLActor2D&quot;),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model Coordinates\\n// WC - WC world coordinates\\n// VC - View Coordinates\\n// DC - Display Coordinates\\n\\nin vec4 vertexWC;\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nuniform mat4 WCVCMatrix;  // World to view matrix\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  gl_Position = WCVCMatrix*vertexWC;\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::PositionVC::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkPolyData2DFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nuniform int PrimitiveIDOffset;\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// Scalar coloring\\n//VTK::Color::Dec\\n\\n// Depth Peeling\\n//VTK::DepthPeeling::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Apple Bug\\n//VTK::PrimID::Dec\\n\\nvoid main()\\n{\\n  // Apple Bug\\n  //VTK::PrimID::Impl\\n\\n  //VTK::Color::Impl\\n  //VTK::TCoord::Impl\\n\\n  //VTK::DepthPeeling::Impl\\n  //VTK::Picking::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Xd.Start;e<Xd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{if(e.invokeEvent(Jd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(ep),!t.currentInput)return void Qd(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors(),a=n.getProperty().getRepresentation();let i=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(i=null);let s=!1;if(t.renderable.getColorCoordinates()){i=t.renderable.getColorCoordinates(),s=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=Pd.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Yd.NEAREST),e.setMagnificationFilter(Yd.NEAREST),e.setWrapS(Zd.CLAMP_TO_EDGE),e.setWrapT(Zd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${a}B${r.getMTime()}C${o?o.getMTime():1}D${i?i.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=Yl.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const c={points:n,tcoords:i,colors:o,cellOffset:0,useTCoordsPerCell:s,haveCellScalars:t.renderable.getAreScalarsMappedFromCells(),customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};c.cellOffset+=t.primitives[Xd.Points].getCABO().createVBO(r.getVerts(),&quot;verts&quot;,a,c),c.cellOffset+=t.primitives[Xd.Lines].getCABO().createVBO(r.getLines(),&quot;lines&quot;,a,c),c.cellOffset+=t.primitives[Xd.Tris].getCABO().createVBO(r.getPolys(),&quot;polys&quot;,a,c),c.cellOffset+=t.primitives[Xd.TriStrips].getCABO().createVBO(r.getStrips(),&quot;strips&quot;,a,c),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=Xd.Start;a<Xd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment,s=[&quot;uniform vec3 diffuseColorUniform;&quot;,&quot;uniform float opacityUniform;&quot;],l=[&quot;vec3 diffuseColor = diffuseColorUniform;&quot;,&quot;float opacity = opacityUniform;&quot;];0!==t.lastBoundBO.getCABO().getColorComponents()?(s=s.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),o=td.substitute(o,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 scalarColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,o=td.substitute(o,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput =  scalarColor;&quot;]).result,a=td.substitute(a,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,a=td.substitute(a,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,i=td.substitute(i,&quot;//VTK::Color::Impl&quot;,l.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])).result):t.renderable.getAreScalarsMappedFromCells()&&(l=l.concat([&quot;  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);&quot;,&quot;  diffuseColor = texColor.rgb;&quot;,&quot;  opacity = opacity*texColor.a;&quot;])),l=l.concat([&quot;gl_FragData[0] = vec4(diffuseColor, opacity);&quot;]),i=td.substitute(i,&quot;//VTK::Color::Dec&quot;,s).result,i=td.substitute(i,&quot;//VTK::Color::Impl&quot;,l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=td.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordMC;&quot;,&quot;out float tcoordVCVSOutput;&quot;]).result,n=td.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=td.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput[];\\n&quot;,&quot;out float tcoordVCGSOutput;&quot;]).result,r=td.substitute(r,[&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=td.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in float tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));&quot;]).result):2===a&&(n=td.substitute(n,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordMC;&quot;,&quot;out vec2 tcoordVCVSOutput;&quot;]).result,n=td.substitute(n,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCVSOutput = tcoordMC;&quot;]).result,r=td.substitute(r,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput[];\\n&quot;,&quot;out vec2 tcoordVCGSOutput;&quot;]).result,r=td.substitute(r,&quot;//VTK::TCoord::Impl&quot;,[&quot;tcoordVCGSOutput = tcoordVCVSOutput[i];&quot;]).result,o=td.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;in vec2 tcoordVCVSOutput;&quot;,&quot;uniform sampler2D texture1;&quot;]).result,o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);&quot;]).result),t.renderable.getAreScalarsMappedFromCells()&&(r=td.substitute(r,&quot;//VTK::PrimID::Impl&quot;,[&quot;gl_PrimitiveID = gl_PrimitiveIDIn;&quot;]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=td.substitute(r,&quot;//VTK::Picking::Dec&quot;,[&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,r=td.substitute(r,&quot;//VTK::Picking::Impl&quot;,&quot;  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];&quot;).result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed(&quot;PrimitiveIDOffset&quot;)&&e.getProgram().setUniformi(&quot;PrimitiveIDOffset&quot;,t.primitiveIDOffset),e.getProgram().isAttributeUsed(&quot;vertexWC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;vertexWC&quot;,e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Qd(&quot;Error setting vertexWC in shader VAO.&quot;)),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Qd(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;tcoordMC&quot;,e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Qd(&quot;Error setting tcoordMC in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;tcoordMC&quot;),e.getProgram().isAttributeUsed(&quot;scalarColor&quot;)&&e.getCABO().getColorComponents()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;scalarColor&quot;,e.getCABO().getColorOffset(),e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Qd(&quot;Error setting scalarColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;scalarColor&quot;),t.internalColorTexture&&e.getProgram().isUniformUsed(&quot;texture1&quot;)&&t.internalColorTexture.getTextureUnit()>-1&&e.getProgram().setUniformi(&quot;texture1&quot;,t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray(&quot;mapperIndex&quot;,a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi(&quot;picking&quot;,a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity();t.setUniformf(&quot;opacityUniform&quot;,o);const a=n.getColor();t.setUniform3fArray(&quot;diffuseColorUniform&quot;,a)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=yo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=yo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=yo(c[0]-(d[0]-l[0])*p[0]),g=yo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-g;let b=-g+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=m(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===qd?-1:1,x[15]=1,h(x,x),a.setUniformMatrix(&quot;WCVCMatrix&quot;,(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),&quot;vtkOpenGLPolyDataMapper2D&quot;);Jt(&quot;vtkMapper2D&quot;,np);var rp={Orientation:{HORIZONTAL:&quot;horizontal&quot;,VERTICAL:&quot;vertical&quot;,AUTO:&quot;auto&quot;}};const{VectorMode:op}=cl,{Orientation:ap}=rp;function ip(e,t,n){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor;const r=t.fontSize??n;e.font=`${t.fontStyle} ${r}px ${t.fontFamily}`}function sp(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),void 0===i.fontSize&&(i.fontSize=Math.max(24*a,12)),void 0===s.fontSize&&(e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10));const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();let u=!1;if(u=t.orientation===ap.VERTICAL||t.orientation!==ap.HORIZONTAL&&e.getLastAspectRatio()>1,u)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function lp(e,t){return e=>{const t=e.getLastTickBounds(),n=ro().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const cp=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;axisTitlePixelOffset&quot;,&quot;tickLabelPixelOffset&quot;,&quot;renderable&quot;,&quot;topTitle&quot;,&quot;ticks&quot;,&quot;tickStrings&quot;,&quot;tickPositions&quot;]),Wt.get(e,t,[&quot;lastSize&quot;,&quot;lastAspectRatio&quot;,&quot;lastTickBounds&quot;,&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;,&quot;barActor&quot;,&quot;tmActor&quot;]),Wt.getArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;]),Wt.setArray(e,t,[&quot;boxPosition&quot;,&quot;boxSize&quot;],2),t.forceUpdate=!1,t.lastRebuildTime={},Wt.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement(&quot;canvas&quot;),t.tmContext=t.tmCanvas.getContext(&quot;2d&quot;),t._tmAtlas=new Map,t.barMapper=Gl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=gu.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=ss.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=gu.newInstance(),t.tmMapper=Gl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=vu.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=ss.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push(&quot;vtkScalarBarActorHelper&quot;),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;;const n={},r=new Map;let o=0,a=1;ip(t.tmContext,t.axisTextStyle,18);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,ip(t.tmContext,t.tickTextStyle,14);const l=[...e.getTickStrings(),&quot;NaN&quot;,&quot;Below&quot;,&quot;Above&quot;];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=wo(o),a=wo(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline=&quot;bottom&quot;,t.tmContext.textAlign=&quot;left&quot;,t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{const r=e.textStyle===t.axisTextStyle?18:14;ip(t.tmContext,e.textStyle,r),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s(&quot;NaN&quot;,[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s(&quot;Below&quot;,[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s(&quot;ticks&quot;,t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s(&quot;Above&quot;,[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p=&quot;vertical&quot;===a?[1,0]:[0,1];&quot;vertical&quot;===a?(d[0]=l.width,d[1]=-l.height,&quot;middle&quot;===o[0]?n[1]-=l.width/2:&quot;right&quot;===o[0]&&(n[1]-=l.width),&quot;middle&quot;===o[1]?n[0]+=l.height/2:&quot;top&quot;===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,&quot;middle&quot;===o[0]?n[0]-=l.width/2:&quot;right&quot;===o[0]&&(n[0]-=l.width),&quot;middle&quot;===o[1]?n[1]-=l.height/2:&quot;top&quot;===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?[&quot;right&quot;,&quot;middle&quot;]:[&quot;middle&quot;,&quot;bottom&quot;];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;top&quot;],&quot;vertical&quot;,[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,[&quot;middle&quot;,&quot;bottom&quot;],&quot;horizontal&quot;,[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];&quot;ticks&quot;===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,&quot;horizontal&quot;,g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,&quot;horizontal&quot;,g,c)}const x=xs.newInstance({numberOfComponents:2,values:l,name:&quot;TextureCoordinates&quot;});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===op.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=xs.newInstance({numberOfComponents:i,values:c,name:&quot;Scalars&quot;});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),&quot;vtkScalarBarActorHelper&quot;);function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:&quot;Scalar Value&quot;,barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:void 0,fontFamily:&quot;serif&quot;},tickLabelPixelOffset:14,tickTextStyle:{fontColor:&quot;white&quot;,fontStyle:&quot;normal&quot;,fontSize:void 0,fontFamily:&quot;serif&quot;},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,orientation:null,...e}}(n)),t.autoLayout||(t.autoLayout=sp(0,t)),t.generateTicks||(t.generateTicks=lp()),ss.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Wt.setGet(e,t,[&quot;automated&quot;,&quot;autoLayout&quot;,&quot;axisTitlePixelOffset&quot;,&quot;axisLabel&quot;,&quot;scalarsToColors&quot;,&quot;tickLabelPixelOffset&quot;,&quot;generateTicks&quot;,&quot;drawNanAnnotation&quot;,&quot;drawBelowRangeSwatch&quot;,&quot;drawAboveRangeSwatch&quot;,&quot;orientation&quot;]),Wt.get(e,t,[&quot;axisTextStyle&quot;,&quot;tickTextStyle&quot;]),Wt.getArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;]),Wt.setArray(e,t,[&quot;barPosition&quot;,&quot;barSize&quot;,&quot;boxPosition&quot;,&quot;boxSize&quot;],2),function(e,t){t.classHierarchy.push(&quot;vtkScalarBarActor&quot;),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.setOrientationToHorizontal=()=>e.setOrientation(ap.HORIZONTAL),e.setOrientationToVertical=()=>e.setOrientation(ap.VERTICAL),e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(sp(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(lp())}}(e,t)}var dp={newInstance:Wt.newInstance(up,&quot;vtkScalarBarActor&quot;),extend:up,newScalarBarActorHelper:cp,...rp};const pp={};const fp=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pp,n),qt.extend(e,t,n),t.scalarBarActorHelper=dp.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLScalarBarActor&quot;),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),&quot;vtkOpenGLScalarBarActor&quot;);Jt(&quot;vtkScalarBarActor&quot;,fp);const{vtkErrorMacro:gp}=Ht,mp={context:null};const hp=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mp,n),qt.extend(e,t,n),t.openGLTexture=Pd.newInstance(),t.tris=ld.newInstance(),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:fe(new Float64Array(9)),mcwc:m(new Float64Array(16))},Ct(e,t,[&quot;context&quot;]),Tt(e,t,[&quot;activeTextures&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLSkybox&quot;),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi(&quot;sbtexture&quot;,n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(v(a,o.wcpc),t.tris.getProgram().setUniformMatrix(&quot;IMCPCMatrix&quot;,a),&quot;box&quot;===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f(&quot;camPos&quot;,e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=xs.newInstance({numberOfComponents:3,values:e});n.setName(&quot;points&quot;);const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=xs.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,&quot;polys&quot;,Zi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),&quot;box&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec3 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = wpos.xyz/wpos.w;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec3 TexCoords;\\n             uniform samplerCube sbtexture;\\n             uniform vec3 camPos;\\n             void main () {\\n               // skybox looks from inside out\\n               // which means we have to adjust\\n               // our tcoords. Otherwise text would\\n               // be flipped\\n               vec3 tc = normalize(TexCoords - camPos);\\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\\n               {\\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\\n               }\\n               else\\n               {\\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\\n               }\\n               gl_FragData[0] = textureCube(sbtexture, tc);\\n             }&quot;,&quot;&quot;)),&quot;background&quot;===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(&quot;//VTK::System::Dec\\n             attribute vec3 vertexMC;\\n             uniform mat4 IMCPCMatrix;\\n             varying vec2 TexCoords;\\n             void main () {\\n              gl_Position = vec4(vertexMC.xyz, 1.0);\\n              vec4 wpos = IMCPCMatrix * gl_Position;\\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\\n             }&quot;,&quot;//VTK::System::Dec\\n             //VTK::Output::Dec\\n             varying vec2 TexCoords;\\n             uniform sampler2D sbtexture;\\n             void main () {\\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\\n             }&quot;,&quot;&quot;)),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),&quot;vertexMC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||gp(&quot;Error setting vertexMC in shader VAO.&quot;));const e=t.renderable.getTextures();e.length||gp(&quot;vtkSkybox requires a texture map&quot;),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));Jt(&quot;vtkSkybox&quot;,hp);const{FieldAssociations:vp}=Us,Tp={fieldAssociation:vp.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function yp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tp,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;fieldAssociation&quot;,&quot;captureZValues&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkHardwareSelector&quot;),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var bp={newInstance:Wt.newInstance(yp,&quot;vtkHardwareSelector&quot;),extend:yp};const xp={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function Cp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xp,n),ht(e,t),t.colorBuffers&&et(&quot;you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.&quot;),t.colorBuffers=[],St(e,t,[&quot;colorBuffers&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkFramebuffer&quot;),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling saveCurrentBindings&quot;);const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling restorePreviousBindings&quot;);const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):et(&quot;you must set the OpenGLRenderWindow before calling create&quot;)},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void et(&quot;you must set the OpenGLRenderWindow before calling setColorBuffer&quot;);let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void et(&quot;you must set the OpenGLRenderWindow before calling removeColorBuffer&quot;);let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void et(&quot;Using multiple framebuffer attachments requires WebGL 2&quot;);r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else et(&quot;Attaching depth buffer textures to fbo requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling setDepthBuffer&quot;)},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else et(&quot;Attaching depth buffer textures to framebuffers requires WebGL 2&quot;);else et(&quot;you must set the OpenGLRenderWindow before calling removeDepthBuffer&quot;)},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void et(&quot;you must set the OpenGLRenderWindow before calling populateFrameBuffer&quot;);e.bind();const n=t.context,r=Pd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(ud.LINEAR),r.setMagnificationFilter(ud.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:cs.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var Sp={newInstance:Mt(Cp,&quot;vtkFramebuffer&quot;),extend:Cp};const Ap={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Ip(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ap,n),Wt.obj(e,t),t.properties={},Wt.setGet(e,t,[&quot;contentType&quot;,&quot;fieldType&quot;,&quot;properties&quot;,&quot;selectionList&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkSelectionNode&quot;),e.getBounds=()=>t.points.getBounds()}(e,t)}var wp={newInstance:Wt.newInstance(Ip,&quot;vtkSelectionNode&quot;),extend:Ip,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Op}=Il,{SelectionContent:Pp,SelectionField:Rp}=wp,{FieldAssociations:Mp}=Us,{vtkErrorMacro:Ep}=Wt;function Vp(e){return`${e.propID} ${e.compositeID}`}function Dp(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function Lp(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function Bp(e,t){let n=t;return n<<=24,n|=e,n}function Np(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=Lp(n[0],n[1],e.pixBuffer[Op.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=Lp(n[0],n[1],e.pixBuffer[Op.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Op.ID_LOW24]&&0===Dp(n[0],n[1],e.pixBuffer[Op.ID_LOW24],e.area))return a;const s=Lp(n[0],n[1],e.pixBuffer[Op.ID_LOW24],e.area),l=Lp(n[0],n[1],e.pixBuffer[Op.ID_HIGH24],e.area);return a.attributeID=Bp(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=Np(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=Np(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=Np(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=Np(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=Np(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function Fp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=wp.newInstance();switch(l.setContentType(Pp.INDICES),e){case Mp.FIELD_ASSOCIATION_CELLS:l.setFieldType(Rp.CELL);break;case Mp.FIELD_ASSOCIATION_POINTS:l.setFieldType(Rp.POINT);break;default:Ep(&quot;Unknown field association&quot;)}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const _p={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function kp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_p,n),bp.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Wt.setGetArray(e,t,[&quot;area&quot;],4),Wt.setGet(e,t,[&quot;_renderer&quot;,&quot;currentPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;maximumPointId&quot;,&quot;maximumCellId&quot;]),Wt.setGetArray(e,t,[&quot;propColorValue&quot;],3),Wt.moveToProtected(e,t,[&quot;renderer&quot;,&quot;openGLRenderWindow&quot;]),Wt.event(e,t,&quot;event&quot;),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLHardwareSelector&quot;),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=Sp.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===Mp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=Np(e,[n,t],0,u);if(r&&r.valid){const t=Vp(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return Fp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return Ep(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:&quot;StartEvent&quot;}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=Op.MIN_KNOWN_PASS;t.currentPass<=Op.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Op.ACTOR_PASS&&&quot;function&quot;==typeof n[0].requestDepth&&&quot;function&quot;==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=Op.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:&quot;EndEvent&quot;}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Op.ID_HIGH24){if(t.fieldAssociation===Mp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===Mp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Op.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if(&quot;function&quot;==typeof e[0].requestDepth&&&quot;function&quot;==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=Lp(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Op.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Op.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Wt.enumToString(Op,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=Lp(e[0],e[1],t.pixBuffer[Op.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=Lp(e[0],e[1],t.pixBuffer[Op.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Op.ID_LOW24]&&0===Dp(e[0],e[1],t.pixBuffer[Op.ID_LOW24],t.area))return a;const s=Lp(e[0],e[1],t.pixBuffer[Op.ID_LOW24],t.area),l=Lp(e[0],e[1],t.pixBuffer[Op.ID_HIGH24],t.area);return a.attributeID=Bp(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=Vp(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return Fp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var Gp={newInstance:Wt.newInstance(kp,&quot;vtkOpenGLHardwareSelector&quot;),extend:kp,...Il};const{vtkErrorMacro:Up}=Ht,{Representation:zp}=os,{ObjectType:Wp}=zu,{PassTypes:Hp}=Gp,jp={type:&quot;StartEvent&quot;},Kp={type:&quot;EndEvent&quot;};function $p(e,t,n){e[12]=(e[12]-t[0])*n[0],e[13]=(e[13]-t[1])*n[1],e[14]=(e[14]-t[2])*n[2],e[0]*=n[0],e[5]*=n[1],e[10]*=n[2]}const qp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const Xp=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qp,n),$d.extend(e,t,n),t.tmpMat3=fe(new Float64Array(9)),t.normalMatrix=fe(new Float64Array(9)),t.mcpcMatrix=m(new Float64Array(16)),t.mcvcMatrix=m(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},ht(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLGlyph3DMapper&quot;);const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(jp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(Kp),!t.currentInput)return void Up(&quot;No input!&quot;);if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension(&quot;ANGLE_instanced_arrays&quot;),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=td.substitute(n,&quot;//VTK::Normal::Dec&quot;,[&quot;attribute vec3 normalMC;&quot;,&quot;attribute mat3 gNormal;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;varying vec3 normalVCVSOutput;&quot;]).result,n=td.substitute(n,&quot;//VTK::Normal::Impl&quot;,[&quot;normalVCVSOutput = normalMatrix * gNormal * normalMC;&quot;]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderClip=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex,r=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();n=td.substitute(n,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,n=td.substitute(n,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    vec4 gVertex = gMatrix * vertexMC;&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], gVertex);&quot;,&quot;    }&quot;]).result,r=td.substitute(r,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,`varying float clipDistancesVSOutput[${e}];`]).result,r=td.substitute(r,&quot;//VTK::Clip::Impl&quot;,[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=n,e.Fragment=r}n.replaceShaderClip(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=[&quot;uniform float ambient;&quot;,&quot;uniform float diffuse;&quot;,&quot;uniform float specular;&quot;,&quot;uniform float opacityUniform; // the fragment opacity&quot;];a&&(i=i.concat([&quot;uniform vec3 specularColorUniform;&quot;,&quot;uniform float specularPowerUniform;&quot;]));let s=[&quot;vec3 ambientColor;&quot;,&quot;  vec3 diffuseColor;&quot;,&quot;  float opacity;&quot;];a&&(s=s.concat([&quot;  vec3 specularColor;&quot;,&quot;  float specularPower;&quot;])),s=s.concat([&quot;  opacity = opacityUniform;&quot;]),a&&(s=s.concat([&quot;  specularColor = specularColorUniform;&quot;,&quot;  specularPower = specularPowerUniform;&quot;])),t.drawingEdges||(i=i.concat([&quot;varying vec4 vertexColorVSOutput;&quot;]),n=td.substitute(n,&quot;//VTK::Color::Dec&quot;,[&quot;attribute vec4 gColor;&quot;,&quot;varying vec4 vertexColorVSOutput;&quot;]).result,n=td.substitute(n,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorVSOutput = gColor;&quot;]).result,r=td.substitute(r,&quot;//VTK::Color::Dec&quot;,[&quot;in vec4 vertexColorVSOutput[];&quot;,&quot;out vec4 vertexColorGSOutput;&quot;]).result,r=td.substitute(r,&quot;//VTK::Color::Impl&quot;,[&quot;vertexColorGSOutput = vertexColorVSOutput[i];&quot;]).result,s=s.concat([&quot;  diffuseColor = vertexColorVSOutput.rgb;&quot;,&quot;  ambientColor = vertexColorVSOutput.rgb;&quot;,&quot;  opacity = opacity*vertexColorVSOutput.a;&quot;])),o=td.substitute(o,&quot;//VTK::Color::Impl&quot;,s).result,o=td.substitute(o,&quot;//VTK::Color::Dec&quot;,i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;)>0?(n=td.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;vertexVCVSOutput = MCVCMatrix * gVertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result,n=td.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result):(n=td.substitute(n,&quot;//VTK::Camera::Dec&quot;,[&quot;attribute mat4 gMatrix;&quot;,&quot;uniform mat4 MCPCMatrix;&quot;]).result,n=td.substitute(n,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 gVertexMC = gMatrix * vertexMC;&quot;,&quot;  gl_Position = MCPCMatrix * gVertexMC;&quot;]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=td.substitute(n,&quot;//VTK::Picking::Dec&quot;,[&quot;attribute vec3 mapperIndexVS;&quot;,&quot;varying vec3 mapperIndexVSOutput;&quot;]).result,n=td.substitute(n,&quot;//VTK::Picking::Impl&quot;,&quot;  mapperIndexVSOutput = mapperIndexVS;&quot;).result,e.Vertex=n,t=td.substitute(t,&quot;//VTK::Picking::Dec&quot;,[&quot;varying vec3 mapperIndexVSOutput;&quot;,&quot;uniform vec3 mapperIndex;&quot;,&quot;uniform int picking;&quot;]).result,t=td.substitute(t,&quot;//VTK::Picking::Impl&quot;,[&quot;  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);&quot;,&quot;  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];&quot;]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3(&quot;normalMatrix&quot;,t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix(&quot;MCPCMatrix&quot;,t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix(&quot;MCVCMatrix&quot;,t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray(&quot;ambientColorUniform&quot;,t.tmpColor),u.setUniform3fArray(&quot;diffuseColorUniform&quot;,t.tmpColor)}c&&u.setUniform3fArray(&quot;mapperIndex&quot;,c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===zp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();Te(t.normalMatrix,s.normalMatrix,l.normalMatrix),b(t.mcpcMatrix,s.wcpc,l.mcwc),b(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===Hp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed(&quot;normalMatrix&quot;),v=g.isUniformUsed(&quot;MCVCMatrix&quot;);if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed(&quot;gMatrix&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,&quot;gMatrix&quot;,0,64,t.context.FLOAT,4,!1,1)||Up(&quot;Error setting gMatrix in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gMatrix&quot;),e.getProgram().isAttributeUsed(&quot;gNormal&quot;)?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,&quot;gNormal&quot;,0,36,t.context.FLOAT,3,!1,1)||Up(&quot;Error setting gNormal in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gNormal&quot;),e.getProgram().isAttributeUsed(&quot;gColor&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,&quot;gColor&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Up(&quot;Error setting gColor in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;gColor&quot;),e.getProgram().isAttributeUsed(&quot;mapperIndexVS&quot;)?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,&quot;mapperIndexVS&quot;,0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||Up(&quot;Error setting mapperIndexVS in shader VAO.&quot;):e.getVAO().removeAttributeArray(&quot;mapperIndexVS&quot;),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{const o=t.renderable.getMatrixArray(),a=t.renderable.getInputData(0).getPoints(),{useShiftAndScale:i,coordShift:s,coordScale:l}=Wu(a);if(t.hardwareSupport){const e=t.renderable.getNormalArray(),n=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=zu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=zu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=zu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=zu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),i){const e=o.buffer;for(let t=0;t<o.byteLength;t+=64)$p(new Float32Array(e,t,16),s,l)}if(t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(o,Wp.ARRAY_BUFFER),t.normalBuffer.upload(e,Wp.ARRAY_BUFFER),n?t.colorBuffer.upload(n.getData(),Wp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const r=o.length/16,a=new Uint8Array(4*r);for(let e=0;e<r;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,Wp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}if(n.buildBufferObjects(e,r),i)for(let e=ad.Start;e<ad.End;e++)t.primitives[e].getCABO().setCoordShiftAndScale(s,l)}}(e,t)}),&quot;vtkOpenGLGlyph3DMapper&quot;);Jt(&quot;vtkGlyph3DMapper&quot;,Xp);const{vtkErrorMacro:Yp}=Wt;class Zp{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Qp={};function Jp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qp,n),Wt.obj(e,t),Wt.algo(e,t,1,1),function(e,t){t.classHierarchy.push(&quot;vtkClosedPolyLineToSurfaceFilter&quot;),e.requestData=(e,t)=>{const n=e[0];if(!n)return void Yp(&quot;Invalid or missing input&quot;);const r=t[0]?.initialize()||gu.newInstance();r.shallowCopy(n);const o=new Zp,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(Kl.newInstance({values:c,name:&quot;faces&quot;})),t[0]=r}}(e,t)}var ef={newInstance:Wt.newInstance(Jp,&quot;vtkClosedPolyLineToSurfaceFilter&quot;),extend:Jp};const{vtkErrorMacro:tf}=Ht;function nf(e,t){t.classHierarchy.push(&quot;vtkCutter&quot;);const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void tf(&quot;Invalid or missing input&quot;);if(!t.cutFunction)return void tf(&quot;Missing cut function&quot;);const o=n[0]?.initialize()||gu.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=e.getPointData(),i=r.getNumberOfPoints(),s=[],l=[],c=[],u={},d=a.getNumberOfArrays();for(let e=0;e<d;e++)u[a.getArrayName(e)]=[];(!t.cutScalars||t.cutScalars.length<i)&&(t.cutScalars=new Float32Array(i));let p=0,f=0;for(;p<o.length;)t.cutScalars[f++]=t.cutFunction.evaluateFunction(o[p++],o[p++],o[p++]);const g=[],m=new Array(3),h=new Array(3),v=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error(&quot;Iterator is done&quot;);r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)v[e]=t.cutScalars[n.cell[e++]];const e=v[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(v[t]>0!==e){r=!1;break}if(r)continue;const i=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,s=v[e]>0;if(v[r]>0===s)continue;let l=e,c=r,u=v[c]-v[l];u<=0&&(l=r,c=e,u*=-1);let p=0;0!==u&&(p=(t.cutValue-v[l])/u);const f=n.cell[l],g=n.cell[c];m[0]=o[3*f],m[1]=o[3*f+1],m[2]=o[3*f+2],h[0]=o[3*g],h[1]=o[3*g+1],h[2]=o[3*g+2];const T=[m[0]+p*(h[0]-m[0]),m[1]+p*(h[1]-m[1]),m[2]+p*(h[2]-m[2])],y={};for(let e=0;e<d;e++){const t=a.getArrayByIndex(e),n=a.getArrayName(e),r=t.getData(),o=t.getNumberOfComponents(),i=new Array(o);for(let e=0;e<o;e++){const t=r[o*f+e],n=r[o*g+e];i.push(t+p*(n-t))}y[n]=i}i.push({pointEdge1:f,pointEdge2:g,intersectedPoint:T,intersectedArrays:y,newPointID:-1})}for(let e=0;e<i.length;e++){const t=i[e];let n=!1;for(let r=0;r<g.length;r++){const o=g[r],a=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(a||s){n=!0,i[e].newPointID=g[r].newPointID;break}}n||(s.push(t.intersectedPoint[0]),s.push(t.intersectedPoint[1]),s.push(t.intersectedPoint[2]),Object.keys(t.intersectedArrays).forEach((e=>{u[e].push(...t.intersectedArrays[e])})),i[e].newPointID=s.length/3-1,g.push(i[e]))}const p=i.length;2===p?l.push(p,i[0].newPointID,i[1].newPointID):p>2&&(c.push(p),i.forEach((e=>{c.push(e.newPointID)})))}n.getPoints().setData(it(r.getDataType(),s),3);const T=n.getPointData();for(let e=0;e<d;e++){const t=a.getArrayName(e),n=xs.newInstance({name:t,dataType:a.getArrayByIndex(e).getDataType(),values:u[t],numberOfComponents:a.getArrayByIndex(e).getNumberOfComponents()});T.addArray(n)}0!==l.length&&n.getLines().setData(Uint16Array.from(l)),0!==c.length&&n.getPolys().setData(Uint16Array.from(c))})(r,o),n[0]=o}}const rf={cutFunction:null,cutScalars:null,cutValue:0};function of(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rf,n),ht(e,t),Ot(e,t,1,1),Ct(e,t,[&quot;cutFunction&quot;,&quot;cutValue&quot;]),nf(e,t)}var af={newInstance:Mt(of,&quot;vtkCutter&quot;),extend:of};const sf=e=>e,lf=1e-6;class cf{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=m(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?c:sf}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);hn(n,e[0],e[1],e[2]),hn(r,t[0],t[1],t[2]),Cn(n,n),Cn(r,r);const a=Sn(n,r);return a>=1||(An(this.tmp,n,r),gn(this.tmp)<lf&&(An(this.tmp,[1,0,0],e),gn(this.tmp)<lf&&An(this.tmp,[0,1,0],e)),R(o,Math.acos(a),this.tmp),b(this.matrix,this.matrix,o)),this}rotate(e,t){return hn(this.tmp,...t),Cn(this.tmp,this.tmp),S(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return w(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return hn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return hn(this.tmp,e,t,n),C(this.matrix,this.matrix,this.tmp),this}multiply(e){return b(this.matrix,this.matrix,e),this}multiply3x3(e){return b(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return v(this.matrix,this.matrix),this}identity(){return m(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Xo(ao,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)hn(this.tmp,e[n],e[n+1],e[n+2]),In(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&p(this.matrix,e),this}}var uf=function(){return new cf(!0)},df=function(){return new cf(!1)};const pf=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],ff=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],gf={xLength:1,yLength:1,zLength:1,pointType:&quot;Float64Array&quot;,generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function mf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gf,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;xLength&quot;,&quot;yLength&quot;,&quot;zLength&quot;,&quot;generate3DTextureCoordinates&quot;,&quot;generateFaces&quot;,&quot;generateLines&quot;]),Wt.setGetArray(e,t,[&quot;center&quot;,&quot;rotations&quot;],3),Wt.setGetArray(e,t,[&quot;matrix&quot;],16),t._polys=Kl.newInstance({values:Uint16Array.from(ff)}),t._lineCells=Kl.newInstance({values:Uint16Array.from(pf)}),Wt.moveToProtected(e,t,[&quot;polys&quot;,&quot;lineCells&quot;]),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push(&quot;vtkCubeSource&quot;),e.requestData=(e,n)=>{const r=n[0]?.initialize()||gu.newInstance();n[0]=r;const o=Wt.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Wt.newTypedArray(t.pointType,72),i=xs.newInstance({name:&quot;Normals&quot;,values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Wt.newTypedArray(t.pointType,24*s),c=xs.newInstance({name:&quot;TextureCoordinates&quot;,values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&uf().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&df().translate(...t.center).apply(o),t.matrix){df().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];df().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()},e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))}}(e,t)}var hf={newInstance:Wt.newInstance(mf,&quot;vtkCubeSource&quot;),extend:mf};const{vtkErrorMacro:vf}=Wt,Tf={};function yf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Wt.obj(e,t),Wt.algo(e,t,1,1),t._cubeSource=hf.newInstance(),Wt.moveToProtected(e,t,[&quot;cubeSource&quot;,&quot;tmpOut&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkImageDataOutlineFilter&quot;);const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA(&quot;vtkImageData&quot;))return void vf(&quot;Invalid or missing input&quot;);const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):vf(&quot;Unable to fetch spatial extents of input image.&quot;)},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var bf={newInstance:Wt.newInstance(yf,&quot;vtkImageDataOutlineFilter&quot;),extend:yf};const{vtkWarningMacro:xf}=Wt;let Cf;const Sf={preMultiplyFlag:!1,matrix:[...ao]};function Af(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sf,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;preMultiplyFlag&quot;]),Wt.setGetArray(e,t,[&quot;matrix&quot;],16),function(e,t){t.classHierarchy.push(&quot;vtkAbstractTransform&quot;,&quot;vtkHomogeneousTransform&quot;,&quot;vtkTransform&quot;),e.transformPoint=(e,n)=>(In(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],In(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?b(n,t.matrix,e):b(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>b(o,t.matrix,r):()=>b(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>Cf({matrix:Da.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag}),e.translate=(n,r,o)=>{if(0===n&&0===r&&0===o)return;const a=u();O(a,[n,r,o]),t.preMultiplyFlag?b(t.matrix,t.matrix,a):b(t.matrix,a,t.matrix),e.modified()},e.rotateWXYZ=(n,r,o,a)=>{if(0===r&&0===o&&0===a)return void xf(&quot;No rotation applied, axis is zero vector.&quot;);if(0===n)return;const i=Da.radiansFromDegrees(n),s=Ba();Na(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),t.preMultiplyFlag?b(t.matrix,t.matrix,l):b(t.matrix,l,t.matrix),e.modified()},e.rotateX=t=>{e.rotateWXYZ(t,1,0,0)},e.rotateY=t=>{e.rotateWXYZ(t,0,1,0)},e.rotateZ=t=>{e.rotateWXYZ(t,0,0,1)},e.scale=(n,r,o)=>{if(1===n&&1===r&&1===o)return;const a=u();P(a,[n,r,o]),t.preMultiplyFlag?b(t.matrix,t.matrix,a):b(t.matrix,a,t.matrix),e.modified()},e.transformNormal=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const o=le(se(),t.matrix),a=se();me(a,o);const i=se();return ge(i,a),e.transformVector(n,r,i),Da.normalize(r),r},e.transformNormals=(n,r)=>{const o=n.getData(),a=r.getData(),i=[0,0,0],s=le(se(),t.matrix),l=se();me(l,s);const c=se();ge(c,l);for(let t=0;t<o.length;t+=3)i[0]=o[t],i[1]=o[t+1],i[2]=o[t+2],e.transformVector(i,i,c),Da.normalize(i),a[t]=i[0],a[t+1]=i[1],a[t+2]=i[2]},e.transformVector=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,(arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||le(se(),t.matrix)),n},e.transformVectors=(t,n)=>{const r=t.getData(),o=n.getData(),a=[0,0,0];for(let t=0;t<r.length;t+=3)a[0]=r[t],a[1]=r[t+1],a[2]=r[t+2],e.transformVector(a,a),Da.normalize(a),o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2]},e.transformPointsNormalsVectors=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;const c=t.getNumberOfPoints(),u=s?.length??0,d=new Float64Array(3),p=new Float64Array(3),f=new Float64Array(3),g=new Float64Array(3);let m=!1,h=!1,v=!1;const T=[];for(let y=0;y<c;y++){if(t.getPoint(y,d),p.set(d),e.transformPoint(d,d),n.setPoint(y,...d),Da.areEquals(p,d)||(m=!0),a){const t=a.getData(),n=i.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],f.set(d),e.transformVector(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],Da.areEquals(f,d)||(h=!0)}if(r){const t=r.getData(),n=o.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],g.set(d),e.transformNormal(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],Da.areEquals(g,d)||(v=!0)}if(s)for(let t=0;t<u;t++){const n=s[t].getData(),r=l[t].getData();d[0]=n[3*y],d[1]=n[3*y+1],d[2]=n[3*y+2],f.set(d),e.transformVector(d,d),r[3*y]=d[0],r[3*y+1]=d[1],r[3*y+2]=d[2],Da.arrayEqual(f,d)||T.includes(t)||T.push(t)}}m&&n.modified(),h&&i.modified(),v&&o.modified(),T.forEach((e=>l[e].modified()))}}(e,t)}Cf=Wt.newInstance(Af,&quot;vtkTransform&quot;);var If={newInstance:Cf,extend:Af};function wf(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??&quot;x&quot;)).join(&quot;/&quot;)}-${t}-${n}`:&quot;0&quot;}function Of(e,t){return`${t.getMTime()}`}const Pf={NEAREST:0,LINEAR:1};var Rf={InterpolationType:Pf};const{vtkErrorMacro:Mf}=Ht;function Ef(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const Vf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const Df=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vf,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.tris=ld.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},ht(t.VBOBuildTime),t.tmpMat4=m(new Float64Array(16)),t.outlineFilter=bf.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=gu.newInstance(),t.cutter=af.newInstance(),t.lineToSurfaceFilter=ef.newInstance(),t.transform=If.newInstance(),Tt(e,t,[&quot;scalarTextures&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageResliceMapper&quot;);const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==gl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void Mf(&quot;No input!&quot;);const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:&quot;EndEvent&quot;})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Pf.NEAREST?(a.setMinificationFilter(ud.NEAREST),a.setMagnificationFilter(ud.NEAREST)):(a.setMinificationFilter(ud.LINEAR),a.setMagnificationFilter(ud.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Pf.NEAREST?(t.colorTexture.setMinificationFilter(ud.NEAREST),t.colorTexture.setMagnificationFilter(ud.NEAREST),t.pwfTexture.setMinificationFilter(ud.NEAREST),t.pwfTexture.setMagnificationFilter(ud.NEAREST)):(t.colorTexture.setMinificationFilter(ud.LINEAR),t.colorTexture.setMagnificationFilter(ud.LINEAR),t.pwfTexture.setMinificationFilter(ud.LINEAR),t.pwfTexture.setMagnificationFilter(ud.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Of(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=wf(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=Pd.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:cs.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:cs.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=wf(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=Pd.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:cs.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:cs.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=xs.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName(&quot;points&quot;);const n=xs.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:Mf(&quot;Slab mode requested without normals&quot;)}t.tris.getCABO().createVBO(n,&quot;polys&quot;,Zi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed(&quot;vertexWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexWC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Mf(&quot;Error setting vertexWC in shader VAO.&quot;)),a.isAttributeUsed(&quot;normalWC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;normalWC&quot;,n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Mf(&quot;Error setting normalWC in shader VAO.&quot;)),a.isUniformUsed(&quot;slabThickness&quot;)&&a.setUniformf(&quot;slabThickness&quot;,t.renderable.getSlabThickness()),a.isUniformUsed(&quot;spacing&quot;)&&a.setUniform3fv(&quot;spacing&quot;,i.getSpacing()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabType&quot;)&&a.setUniformi(&quot;slabType&quot;,t.renderable.getSlabType()),a.isUniformUsed(&quot;slabTrapezoid&quot;)&&a.setUniformi(&quot;slabTrapezoid&quot;,t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed(&quot;WCTCMatrix&quot;)){const n=i.getDimensions();p(t.tmpMat4,i.getIndexToWorld()),x(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),C(t.tmpMat4,t.tmpMat4,n),v(t.tmpMat4,t.tmpMat4),e&&b(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix(&quot;WCTCMatrix&quot;,t.tmpMat4)}a.isUniformUsed(&quot;vboScaling&quot;)&&a.setUniform3fv(&quot;vboScaling&quot;,n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed(&quot;MCPCMatrix&quot;)&&(m(t.tmpMat4),l.setUniformMatrix(&quot;MCPCMatrix&quot;,Ef([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed(&quot;MCVCMatrix&quot;)&&(m(t.tmpMat4),l.setUniformMatrix(&quot;MCVCMatrix&quot;,Ef([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,u),o.setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\n// all variables that represent positions or directions have a suffix\\n// indicating the coordinate system they are in. The possible values are\\n// MC - Model coordinates\\n// WC - World coordinates\\n// VC - View coordinates\\n// DC - Display coordinates\\n// TC - Texture coordinates\\n\\n// frag position in VC\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvoid main()\\n{\\n  //VTK::PositionVC::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Picking::Impl\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkImageResliceMapperFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the gpu image mapper fragment shader\\n\\n// VC position of this fragment\\n//VTK::PositionVC::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\n// picking support\\n//VTK::Picking::Dec\\n\\n// handle coincident offsets\\n//VTK::Coincident::Dec\\n\\n//VTK::ZBuffer::Dec\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  // VC position of this fragment. This should not branch/return/discard.\\n  //VTK::PositionVC::Impl\\n\\n  // Place any calls that require uniform flow (e.g. dFdx) here.\\n  //VTK::UniformFlow::Impl\\n\\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\\n  //VTK::Depth::Impl\\n\\n  // Early depth peeling abort:\\n  //VTK::DepthPeeling::PreColor\\n\\n  //VTK::TCoord::Impl\\n\\n  if (gl_FragData[0].a <= 0.0)\\n    {\\n    discard;\\n    }\\n\\n  //VTK::DepthPeeling::Impl\\n\\n  //VTK::Picking::Impl\\n\\n  // handle coincident offsets\\n  //VTK::Coincident::Impl\\n\\n  //VTK::ZBuffer::Impl\\n\\n  //VTK::RenderPassFragmentShader::Impl\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=td.substitute(e,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,e=td.substitute(e,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=td.substitute(o,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform mat4 WCTCMatrix;&quot;,&quot;out vec3 fragTexCoord;&quot;]).result,o=td.substitute(o,&quot;//VTK::TCoord::Impl&quot;,[&quot;fragTexCoord = (WCTCMatrix * vertexWC).xyz;&quot;]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=[&quot;in vec3 fragTexCoord;&quot;,`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,&quot;uniform mat4 WCTCMatrix;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;];if(u.push(&quot;vec4 rawSampleTexture(vec3 pos) {&quot;),t.multiTexturePerVolumeEnabled){u.push(&quot;vec4 rawSample;&quot;);for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push(&quot;return rawSample;&quot;,&quot;}&quot;)}else u.push(&quot;return texture(volumeTexture[0], pos);&quot;,&quot;}&quot;);if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:u=u.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:Mf(&quot;Unsupported number of independent coordinates.&quot;)}}s>0&&(u=u.concat([&quot;uniform vec3 spacing;&quot;,&quot;uniform float slabThickness;&quot;,&quot;uniform int slabType;&quot;,&quot;uniform int slabTrapezoid;&quot;,&quot;uniform vec3 vboScaling;&quot;]),u=u.concat([&quot;vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)&quot;,&quot;{&quot;,&quot;  vec4 retVal = vec4(1.0);&quot;,&quot;  if (slabType == 0) // min&quot;,&quot;  {&quot;,&quot;    retVal = min(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 1) // max&quot;,&quot;  {&quot;,&quot;    retVal = max(currVal, valToComp);&quot;,&quot;  }&quot;,&quot;  else if (slabType == 3) // sum&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  else // mean&quot;,&quot;  {&quot;,&quot;    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); &quot;,&quot;  }&quot;,&quot;  return retVal;&quot;,&quot;}&quot;])),i=td.substitute(i,&quot;//VTK::TCoord::Dec&quot;,u).result;let d=[&quot;if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;,&quot;vec4 tvalue = rawSampleTexture(fragTexCoord);&quot;];if(s>0&&(d=d.concat([&quot;// Get the first and last samples&quot;,&quot;int numSlices = 1;&quot;,&quot;float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;&quot;,&quot;vec3 normalxspacing = scaling * normalWCVSOutput;&quot;,&quot;float distTraveled = length(normalxspacing);&quot;,&quot;int trapezoid = 0;&quot;,&quot;while (distTraveled < slabThickness * 0.5)&quot;,&quot;{&quot;,&quot;  distTraveled += length(normalxspacing);&quot;,&quot;  float fnumSlices = float(numSlices);&quot;,&quot;  if (distTraveled > slabThickness * 0.5)&quot;,&quot;  {&quot;,&quot;    // Before stepping outside the slab, sample at the boundaries&quot;,&quot;    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;&quot;,&quot;    trapezoid = slabTrapezoid;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = rawSampleTexture(fragTCoordNeg);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;&quot;,&quot;  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))&quot;,&quot;  {&quot;,&quot;    vec4 newVal = rawSampleTexture(fragTCoordPos);&quot;,&quot;    tvalue = compositeValue(tvalue, newVal, trapezoid);&quot;,&quot;    numSlices += 1;&quot;,&quot;  }&quot;,&quot;}&quot;,&quot;// Finally, if slab type is *mean*, divide the sum by the numSlices&quot;,&quot;if (slabType == 2)&quot;,&quot;{&quot;,&quot;  tvalue = tvalue / float(numSlices);&quot;,&quot;}&quot;])),c){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:d=d.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:Mf(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(l){case 1:d=d.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:d=d.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:d=d.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=[&quot;attribute vec4 vertexWC;&quot;];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat([&quot;attribute vec3 normalWC;&quot;,&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),a=td.substitute(a,&quot;//VTK::PositionVC::Dec&quot;,c).result;let u=[&quot;gl_Position = MCPCMatrix * vertexWC;&quot;];l>0&&(u=u.concat([&quot;normalWCVSOutput = normalWC;&quot;,&quot;vertexWCVSOutput = vertexWC;&quot;])),a=td.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,u).result,a=td.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result;let d=[];l>0&&(d=d.concat([&quot;varying vec3 normalWCVSOutput;&quot;,&quot;varying vec4 vertexWCVSOutput;&quot;])),s=td.substitute(s,&quot;//VTK::PositionVC::Dec&quot;,d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e=&quot;&quot;;const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=se();n&&(e=e.concat(`Image${n.getMTime()}`),pe(t,...n.getDirection()),me(t,t));const r=[...s.getNormal()];wn(r,r,t),[o,a]=function(e){Da.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=Da.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ei.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();Da.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=gu.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=xs.newInstance({numberOfComponents:3,values:d,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=gu.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();Da.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=xs.newInstance({numberOfComponents:3,values:a,name:&quot;Normals&quot;});t.resliceGeom.getPointData().setNormals(i)}else Mf(&quot;Something went wrong.&quot;,&quot;A default slice plane should have been created in the beginning of&quot;,&quot;updateResliceGeometry.&quot;);t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Et((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),&quot;vtkOpenGLImageResliceMapper&quot;);Jt(&quot;vtkImageResliceMapper&quot;,Df);var Lf={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:Bf}=Ht,{SlicingMode:Nf}=Lf;function Ff(e){const t=e.split(&quot;\\n&quot;),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const _f={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineOpacityTexture:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const kf=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_f,n),qt.extend(e,t,n),Ed(e,t,n),Vd(e,t,n),t.tris=ld.newInstance(),t.imagemat=m(new Float64Array(16)),t.imagematinv=m(new Float64Array(16)),t.projectionToWorld=m(new Float64Array(16)),t.idxToView=m(new Float64Array(16)),t.idxNormalMatrix=fe(new Float64Array(9)),t.modelToView=m(new Float64Array(16)),t.projectionToView=m(new Float64Array(16)),Ct(e,t,[]),t.VBOBuildTime={},ht(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray,t._labelOutlineOpacity].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push(&quot;vtkOpenGLImageMapper&quot;),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA(&quot;vtkImageMapper&quot;)&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==gl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=Rd,e.Fragment=Md,e.Geometry=&quot;&quot;},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=td.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=td.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result,a=td.substitute(a,&quot;//VTK::TCoord::Impl&quot;,&quot;tcoordVCVSOutput = tcoordMC;&quot;).result,a=td.substitute(a,&quot;//VTK::TCoord::Dec&quot;,&quot;attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;&quot;).result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=[&quot;varying vec2 tcoordVCVSOutput;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;];if(o.getProperty().getUseLabelOutline()&&(c=c.concat([&quot;uniform sampler2D labelOutlineTexture1;&quot;,&quot;uniform sampler2D labelOutlineOpacityTexture1;&quot;])),l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:c=c.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:Bf(&quot;Unsupported number of independent coordinates.&quot;)}}if(i=td.substitute(i,&quot;//VTK::TCoord::Dec&quot;,c).result,!0===o.getProperty().getUseLabelOutline()&&(i=td.substitute(i,&quot;//VTK::LabelOutline::Dec&quot;,[&quot;uniform float vpWidth;&quot;,&quot;uniform float vpHeight;&quot;,&quot;uniform float vpOffsetX;&quot;,&quot;uniform float vpOffsetY;&quot;,&quot;uniform mat4 PCWCMatrix;&quot;,&quot;uniform mat4 vWCtoIDX;&quot;,&quot;uniform ivec3 imageDimensions;&quot;,&quot;uniform int sliceAxis;&quot;]).result,i=td.substitute(i,&quot;//VTK::ImageLabelOutlineOn&quot;,&quot;#define vtkImageLabelOutlineOn&quot;).result,i=td.substitute(i,&quot;//VTK::LabelOutlineHelperFunction&quot;,[&quot;#ifdef vtkImageLabelOutlineOn&quot;,&quot;vec3 fragCoordToIndexSpace(vec4 fragCoord) {&quot;,&quot;  vec4 pcPos = vec4(&quot;,&quot;    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,&quot;,&quot;    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,&quot;,&quot;    (fragCoord.z - 0.5) * 2.0,&quot;,&quot;    1.0);&quot;,&quot;&quot;,&quot;  vec4 worldCoord = PCWCMatrix * pcPos;&quot;,&quot;  vec4 vertex = (worldCoord/worldCoord.w);&quot;,&quot;&quot;,&quot;  vec3 index = (vWCtoIDX * vertex).xyz;&quot;,&quot;&quot;,&quot;  // half voxel fix for labelmapOutline&quot;,&quot;  return (index + vec3(0.5)) / vec3(imageDimensions);&quot;,&quot;}&quot;,&quot;vec2 getSliceCoords(vec3 coord, int axis) {&quot;,&quot;  if (axis == 0) return coord.yz;&quot;,&quot;  if (axis == 1) return coord.xz;&quot;,&quot;  if (axis == 2) return coord.xy;&quot;,&quot;}&quot;,&quot;#endif&quot;]).result),l){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];let t=[&quot;vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);&quot;];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, opacity);&quot;]);break;case 2:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:t=t.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:Bf(&quot;Unsupported number of independent coordinates.&quot;)}i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,t).result}else switch(s){case 1:i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[...Ff(&quot;\\n                #ifdef vtkImageLabelOutlineOn\\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\\n                  bool pixelOnBorder = false;\\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\\n                  float opacityToUse = scalarOpacity * opacity;\\n                  int segmentIndex = int(centerValue * 255.0);\\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  float outlineOpacity = texture2D(labelOutlineOpacityTexture1, vec2(textureCoordinate, 0.5)).r;\\n                  int actualThickness = int(textureValue * 255.0);\\n\\n                  if (segmentIndex == 0){\\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\\n                    return;\\n                  }\\n\\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\\n                      if (i == 0 || j == 0) {\\n                        continue;\\n                      }\\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\\n                        gl_FragCoord.y + float(j),\\n                        gl_FragCoord.z, gl_FragCoord.w);\\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\\n                      if (value != centerValue) {\\n                        pixelOnBorder = true;\\n                        break;\\n                      }\\n                    }\\n                    if (pixelOnBorder == true) {\\n                      break;\\n                    }\\n                  }\\n                  if (pixelOnBorder == true) {\\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\\n                  }\\n                  else {\\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\\n                  }\\n                #else\\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\\n                #endif\\n                &quot;)]).result;break;case 2:i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);&quot;,&quot;float intensity = tcolor.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);&quot;]).result;break;case 3:i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]).result;break;default:i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[&quot;vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;]).result}t.haveSeenDepthRequest&&(i=td.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=td.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=td.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=td.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=td.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=td.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!!(i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||0===e.getProgram()?.getHandle()||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<r.getProperty().getMTime()||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;vertexMC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Bf(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getProgram().isAttributeUsed(&quot;tcoordMC&quot;)&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),&quot;tcoordMC&quot;,n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||Bf(&quot;Error setting tcoordMC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi(&quot;texture1&quot;,a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),n.getProgram().isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf(&quot;coffset&quot;,t.offset),n.getProgram().isUniformUsed(&quot;cfactor&quot;)&&n.getProgram().setUniformf(&quot;cfactor&quot;,t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi(&quot;colorTexture1&quot;,c);const u=t.pwfTexture.getTextureUnit();if(n.getProgram().setUniformi(&quot;pwfTexture1&quot;,u),o.getProperty().getUseLabelOutline()){const e=t.labelOutlineThicknessTexture.getTextureUnit();n.getProgram().setUniformi(&quot;labelOutlineTexture1&quot;,e);const r=t.labelOutlineOpacityTexture.getTextureUnit();n.getProgram().setUniformi(&quot;labelOutlineOpacityTexture1&quot;,r)}if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(et(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?p(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(h(a,a),b(a,a,r),h(a,a)),h(t.imagemat,t.currentInput.getIndexToWorld()),b(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi(&quot;numClipPlanes&quot;,e),n.getProgram().setUniform4fv(&quot;clipPlanes&quot;,i)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();b(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(b(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();b(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===Nf.NONE&&(i=Nf.K),a.setUniform3i(&quot;imageDimensions&quot;,o[0],o[1],o[2]),a.setUniformi(&quot;sliceAxis&quot;,i),a.setUniformMatrix(&quot;vWCtoIDX&quot;,n);const l=t.openGLCamera.getKeyMatrices(r);v(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix(&quot;PCWCMatrix&quot;,t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf(&quot;vpWidth&quot;,c[0]),a.setUniformf(&quot;vpHeight&quot;,c[1]);const u=e.getRenderTargetOffset();a.setUniformf(&quot;vpOffsetX&quot;,u[0]/c[0]),a.setUniformf(&quot;vpOffsetY&quot;,u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf(&quot;opacity&quot;,o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.activate(),t.labelOutlineOpacityTexture.activate()),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.deactivate(),t.labelOutlineOpacityTexture.deactivate()),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):Bf(&quot;No input!&quot;)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||r.getProperty().getUseLabelOutline()&&(!t.labelOutlineThicknessTexture?.getHandle()||!t.labelOutlineOpacityTexture?.getHandle())||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=wf(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=Pd.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Pf.NEAREST?(t.colorTexture.setMinificationFilter(ud.NEAREST),t.colorTexture.setMagnificationFilter(ud.NEAREST)):(t.colorTexture.setMinificationFilter(ud.LINEAR),t.colorTexture.setMagnificationFilter(ud.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=wf(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=Pd.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Pf.NEAREST?(t.pwfTexture.setMinificationFilter(ud.NEAREST),t.pwfTexture.setMagnificationFilter(ud.NEAREST)):(t.pwfTexture.setMinificationFilter(ud.LINEAR),t.pwfTexture.setMagnificationFilter(ud.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:cs.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:cs.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}r.getProperty().getUseLabelOutline()&&(e.updatelabelOutlineThicknessTexture(r),e.updateLabelOutlineOpacityTexture(r));const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA(&quot;vtkImageArrayMapper&quot;)?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===Nf.I&&(I=S-A[0]),x===Nf.J&&(I=S-A[2]),x!==Nf.K&&x!==Nf.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=Pd.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),c===Pf.NEAREST?(new Set([1,3,4]).has(s)&&i===cs.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(ud.NEAREST)):t.openGLTexture.setMinificationFilter(ud.NEAREST),t.openGLTexture.setMagnificationFilter(ud.NEAREST)):(4!==s||i!==cs.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(ud.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(ud.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(ud.LINEAR)),t.openGLTexture.setWrapS(cd.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(cd.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[Nf.X,Nf.Y,Nf.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===Nf.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===Nf.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===Nf.K||x===Nf.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):Bf(&quot;Reformat slicing not yet supported.&quot;);const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=xs.newInstance({numberOfComponents:3,values:r});h.setName(&quot;points&quot;);const v=xs.newInstance({numberOfComponents:2,values:l});v.setName(&quot;tcoords&quot;);const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=xs.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,&quot;polys&quot;,Zi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updateLabelOutlineOpacityTexture=n=>{let r=n.getProperty().getLabelOutlineOpacity();&quot;number&quot;==typeof r&&(r=t._cachedLabelOutlineOpacityObj?.[0]===r?t._cachedLabelOutlineOpacityObj:[r],t._cachedLabelOutlineOpacityObj=r);const o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join(&quot;-&quot;)}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineOpacityTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Float32Array(n*o);for(let e=0;e<n;++e)i[e]=r[e]??r[0];t.labelOutlineOpacityTexture=Pd.newInstance({resizable:!1}),t.labelOutlineOpacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineOpacityTexture.resetFormatAndType(),t.labelOutlineOpacityTexture.setMinificationFilter(ud.NEAREST),t.labelOutlineOpacityTexture.setMagnificationFilter(ud.NEAREST),t.labelOutlineOpacityTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:cs.FLOAT,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineOpacityTexture,a),r!==t._labelOutlineOpacity&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineOpacity,e)),t._labelOutlineOpacity=r)}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join(&quot;-&quot;)}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=Pd.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(ud.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(ud.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:cs.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Et((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),&quot;vtkOpenGLImageMapper&quot;);Jt(&quot;vtkAbstractImageMapper&quot;,kf);const Gf=0,Uf=1,zf=2,{vtkErrorMacro:Wf}=Wt,Hf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const jf=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hf,n),qt.extend(e,t,n),Ed(e,t,n),Wt.algo(e,t,2,0),t.tris=ld.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=m(new Float64Array(16)),t.imagematinv=m(new Float64Array(16)),t.VBOBuildTime={},Wt.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push(&quot;vtkOpenGLImageCPRMapper&quot;),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType(&quot;vtkOpenGLImageSlice&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===gl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update(),e.invokeEvent({type:&quot;EndEvent&quot;}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Pf.NEAREST?(t.volumeTexture.setMinificationFilter(ud.NEAREST),t.volumeTexture.setMagnificationFilter(ud.NEAREST),t.colorTexture.setMinificationFilter(ud.NEAREST),t.colorTexture.setMagnificationFilter(ud.NEAREST),t.pwfTexture.setMinificationFilter(ud.NEAREST),t.pwfTexture.setMagnificationFilter(ud.NEAREST)):(t.volumeTexture.setMinificationFilter(ud.LINEAR),t.volumeTexture.setMagnificationFilter(ud.LINEAR),t.colorTexture.setMinificationFilter(ud.LINEAR),t.colorTexture.setMagnificationFilter(ud.LINEAR),t.pwfTexture.setMinificationFilter(ud.LINEAR),t.pwfTexture.setMagnificationFilter(ud.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Of(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=Pd.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=wf(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=Pd.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=wf(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=Pd.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:cs.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:cs.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=xs.newInstance({numberOfComponents:3,values:s});c.setName(&quot;points&quot;);const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=xs.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=xs.newInstance({numberOfComponents:3,values:f,name:&quot;centerlinePosition&quot;}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,xs.newInstance({numberOfComponents:1,values:v,name:&quot;quadIndex&quot;})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=xs.newInstance({numberOfComponents:4,values:r,name:&quot;centerlineTopOrientation&quot;}),s=xs.newInstance({numberOfComponents:4,values:o,name:&quot;centerlineBotOrientation&quot;});T.push(a,s)}t.tris.getCABO().createVBO(d,&quot;polys&quot;,Zi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=[&quot;vec3 applyQuaternionToVec(vec4 q, vec3 v) {&quot;,&quot;  float uvx = q.y * v.z - q.z * v.y;&quot;,&quot;  float uvy = q.z * v.x - q.x * v.z;&quot;,&quot;  float uvz = q.x * v.y - q.y * v.x;&quot;,&quot;  float uuvx = q.y * uvz - q.z * uvy;&quot;,&quot;  float uuvy = q.z * uvx - q.x * uvz;&quot;,&quot;  float uuvz = q.x * uvy - q.y * uvx;&quot;,&quot;  float w2 = q.w * 2.0;&quot;,&quot;  uvx *= w2;&quot;,&quot;  uvy *= w2;&quot;,&quot;  uvz *= w2;&quot;,&quot;  uuvx *= 2.0;&quot;,&quot;  uuvy *= 2.0;&quot;,&quot;  uuvz *= 2.0;&quot;,&quot;  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);&quot;,&quot;}&quot;];a=td.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 MCPCMatrix;&quot;]).result,a=td.substitute(a,&quot;//VTK::PositionVC::Impl&quot;,[&quot;  gl_Position = MCPCMatrix * vertexMC;&quot;]).result;const l=[&quot;attribute vec3 centerlinePosition;&quot;,&quot;attribute float quadIndex;&quot;,&quot;uniform float width;&quot;,&quot;out vec2 quadOffsetVSOutput;&quot;,&quot;out vec3 centerlinePosVSOutput;&quot;],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push(&quot;out vec3 samplingDirVSOutput;&quot;,&quot;uniform vec4 centerlineOrientation;&quot;,&quot;uniform vec3 tangentDirection;&quot;,...s),c&&l.push(&quot;out vec3 projectionDirVSOutput;&quot;,&quot;uniform vec3 bitangentDirection;&quot;)):l.push(&quot;out vec4 centerlineTopOrientationVSOutput;&quot;,&quot;out vec4 centerlineBotOrientationVSOutput;&quot;,&quot;attribute vec4 centerlineTopOrientation;&quot;,&quot;attribute vec4 centerlineBotOrientation;&quot;),a=td.substitute(a,&quot;//VTK::Color::Dec&quot;,l).result;const d=[&quot;quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);&quot;,&quot;centerlinePosVSOutput = centerlinePosition;&quot;];u?(d.push(&quot;samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);&quot;),c&&d.push(&quot;projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);&quot;)):d.push(&quot;centerlineTopOrientationVSOutput = centerlineTopOrientation;&quot;,&quot;centerlineBotOrientationVSOutput = centerlineBotOrientation;&quot;),a=td.substitute(a,&quot;//VTK::Color::Impl&quot;,d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=[&quot;uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates&quot;,&quot;in vec2 quadOffsetVSOutput;&quot;,&quot;in vec3 centerlinePosVSOutput;&quot;,&quot;uniform highp sampler3D volumeTexture;&quot;,&quot;uniform sampler2D colorTexture1;&quot;,&quot;uniform sampler2D pwfTexture1;&quot;,&quot;uniform float opacity;&quot;,&quot;uniform vec4 backgroundColor;&quot;,&quot;uniform float cshift0;&quot;,&quot;uniform float cscale0;&quot;,&quot;uniform float pwfshift0;&quot;,&quot;uniform float pwfscale0;&quot;];c&&g.push(&quot;uniform vec3 volumeSizeMC;&quot;,&quot;uniform int projectionSlabNumberOfSamples;&quot;,&quot;uniform float projectionConstantOffset;&quot;,&quot;uniform float projectionStepLength;&quot;),u?(g.push(&quot;in vec3 samplingDirVSOutput;&quot;),c&&g.push(&quot;in vec3 projectionDirVSOutput;&quot;)):(g.push(&quot;uniform vec3 tangentDirection;&quot;,&quot;in vec4 centerlineTopOrientationVSOutput;&quot;,&quot;in vec4 centerlineBotOrientationVSOutput;&quot;,...s),c&&g.push(&quot;uniform vec3 bitangentDirection;&quot;));const m=t.renderable.getCenterPoint();if(m&&g.push(&quot;uniform vec3 globalCenterPoint;&quot;),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat([&quot;uniform float mix0;&quot;,&quot;#define height0 0.5&quot;]);break;case 2:g=g.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;#define height0 0.25&quot;,&quot;#define height1 0.75&quot;]);break;case 3:g=g.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;#define height0 0.17&quot;,&quot;#define height1 0.5&quot;,&quot;#define height2 0.83&quot;]);break;case 4:g=g.concat([&quot;uniform float mix0;&quot;,&quot;uniform float mix1;&quot;,&quot;uniform float mix2;&quot;,&quot;uniform float mix3;&quot;,&quot;#define height0 0.125&quot;,&quot;#define height1 0.375&quot;,&quot;#define height2 0.625&quot;,&quot;#define height3 0.875&quot;]);break;default:Wf(&quot;Unsupported number of independent coordinates.&quot;)}}i=td.substitute(i,&quot;//VTK::TCoord::Dec&quot;,g).result;let h=[];if(u?(h.push(&quot;vec3 samplingDirection = samplingDirVSOutput;&quot;),c&&h.push(&quot;vec3 projectionDirection = projectionDirVSOutput;&quot;)):(h.push(&quot;vec4 q0 = centerlineBotOrientationVSOutput;&quot;,&quot;vec4 q1 = centerlineTopOrientationVSOutput;&quot;,&quot;float qCosAngle = dot(q0, q1);&quot;,&quot;vec4 interpolatedOrientation;&quot;,&quot;if (qCosAngle > 0.999 || qCosAngle < -0.999) {&quot;,&quot;  // Use LERP instead of SLERP when the two quaternions are close or opposite&quot;,&quot;  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));&quot;,&quot;} else {&quot;,&quot;  float omega = acos(qCosAngle);&quot;,&quot;  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);&quot;,&quot;}&quot;,&quot;vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);&quot;),c&&h.push(&quot;vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);&quot;)),m?h.push(&quot;float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);&quot;,&quot;float horizontalOffset = quadOffsetVSOutput.x + baseOffset;&quot;):h.push(&quot;float horizontalOffset = quadOffsetVSOutput.x;&quot;),h.push(&quot;vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;&quot;,&quot;vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;&quot;,&quot;if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))&quot;,&quot;{&quot;,&quot;  // set the background color and exit&quot;,&quot;  gl_FragData[0] = backgroundColor;&quot;,&quot;  return;&quot;,&quot;}&quot;),c){const e=t.renderable.getProjectionMode();switch(e===Uf?h.push(&quot;const vec4 initialProjectionTextureValue = vec4(1.0);&quot;):h.push(&quot;const vec4 initialProjectionTextureValue = vec4(0.0);&quot;),h.push(&quot;vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;&quot;,&quot;vec3 projectionStep = projectionStepLength * projectionScaledDirection;&quot;,&quot;vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;&quot;,&quot;vec4 tvalue = initialProjectionTextureValue;&quot;,&quot;for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {&quot;,&quot;  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;&quot;,&quot;  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);&quot;),e){case Gf:h.push(&quot;  tvalue = max(tvalue, sampledTextureValue);&quot;);break;case Uf:h.push(&quot;  tvalue = min(tvalue, sampledTextureValue);&quot;);break;default:h.push(&quot;  tvalue = tvalue + sampledTextureValue;&quot;)}h.push(&quot;}&quot;),e===zf&&h.push(&quot;tvalue = tvalue / float(projectionSlabNumberOfSamples);&quot;)}else h.push(&quot;vec4 tvalue = texture(volumeTexture, volumePosTC);&quot;);if(f){const e=[&quot;r&quot;,&quot;g&quot;,&quot;b&quot;,&quot;a&quot;];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat([&quot;gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);&quot;]);break;case 2:h=h.concat([&quot;float weightSum = compWeight0 + compWeight1;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);&quot;]);break;case 3:h=h.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);&quot;]);break;case 4:h=h.concat([&quot;float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;&quot;,&quot;gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);&quot;]);break;default:Wf(&quot;Unsupported number of independent coordinates.&quot;)}}else switch(p){case 1:h=h.concat([&quot;// Dependent components&quot;,&quot;float intensity = tvalue.r;&quot;,&quot;vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;&quot;,&quot;float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;&quot;,&quot;gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);&quot;]);break;case 2:h=h.concat([&quot;float intensity = tvalue.r*cscale0 + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);&quot;]);break;case 3:h=h.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);&quot;]);break;default:h=h.concat([&quot;vec4 tcolor = cscale0*tvalue + cshift0;&quot;,&quot;gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,&quot;,&quot;  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);&quot;])}i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,h).result,t.haveSeenDepthRequest&&(i=td.substitute(i,&quot;//VTK::ZBuffer::Dec&quot;,&quot;uniform int depthRequest;&quot;).result,i=td.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float iz = floor(gl_FragCoord.z*65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Wt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6),o=td.substitute(o,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;uniform vec4 clipPlanes[6];&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,o=td.substitute(o,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);&quot;,&quot;    }&quot;]).result,a=td.substitute(a,&quot;//VTK::Clip::Dec&quot;,[&quot;uniform int numClipPlanes;&quot;,&quot;varying float clipDistancesVSOutput[6];&quot;]).result,a=td.substitute(a,&quot;//VTK::Clip::Impl&quot;,[&quot;for (int planeNum = 0; planeNum < 6; planeNum++)&quot;,&quot;    {&quot;,&quot;    if (planeNum >= numClipPlanes)&quot;,&quot;        {&quot;,&quot;        break;&quot;,&quot;        }&quot;,&quot;    if (clipDistancesVSOutput[planeNum] < 0.0) discard;&quot;,&quot;    }&quot;]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=Rd,e.Fragment=Md,e.Geometry=&quot;&quot;},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexMC&quot;)&&(n.getVAO().addAttributeArray(a,i,&quot;vertexMC&quot;,i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||Wf(&quot;Error setting vertexMC in shader VAO.&quot;)),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&Wf(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi(&quot;volumeTexture&quot;,s),a.setUniformf(&quot;width&quot;,t.renderable.getWidth()),n.getProgram().setUniform4fv(&quot;backgroundColor&quot;,t.renderable.getBackgroundColor()),a.isUniformUsed(&quot;tangentDirection&quot;)){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray(&quot;tangentDirection&quot;,e)}if(a.isUniformUsed(&quot;bitangentDirection&quot;)){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray(&quot;bitangentDirection&quot;,e)}if(a.isUniformUsed(&quot;centerlineOrientation&quot;)){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv(&quot;centerlineOrientation&quot;,e)}if(a.isUniformUsed(&quot;globalCenterPoint&quot;)){const e=t.renderable.getCenterPoint();a.setUniform3fArray(&quot;globalCenterPoint&quot;,e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=Mn([],n,r);a.setUniform3fArray(&quot;volumeSizeMC&quot;,s),a.setUniformi(&quot;projectionSlabNumberOfSamples&quot;,i);const l=-.5*o;a.setUniformf(&quot;projectionConstantOffset&quot;,l);const c=o/(i-1);a.setUniformf(&quot;projectionStepLength&quot;,c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=P(new Float32Array(16),xn([],l.getDimensions())),d=ae(u,u,c);if(a.setUniformMatrix(&quot;MCTCMatrix&quot;,d),t.haveSeenDepthRequest&&n.getProgram().setUniformi(&quot;depthRequest&quot;,t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Wt.vtkErrorMacro(&quot;OpenGL has a limit of 6 clipping planes&quot;),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?p(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(h(r,r),b(r,r,n),h(r,r)),h(t.imagemat,t.currentImageDataInput.getIndexToWorld()),b(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi(&quot;numClipPlanes&quot;,e),a.setUniform4fv(&quot;clipPlanes&quot;,s)}if(a.isUniformUsed(&quot;coffset&quot;)){const t=e.getCoincidentParameters(r,o);a.setUniformf(&quot;coffset&quot;,t.offset),a.isUniformUsed(&quot;cfactor&quot;)&&a.setUniformf(&quot;cfactor&quot;,t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(b(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();b(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix(&quot;MCPCMatrix&quot;,t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf(&quot;opacity&quot;,i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi(&quot;colorTexture1&quot;,u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi(&quot;pwfTexture1&quot;,d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Wt.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),&quot;vtkOpenGLImageCPRMapper&quot;);Jt(&quot;vtkImageCPRMapper&quot;,jf);const Kf={context:null,keyMatrixTime:null,keyMatrices:null};const $f=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kf,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:m(new Float64Array(16))},Ct(e,t,[&quot;context&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLImageSlice&quot;),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(p(t.keyMatrices.mcwc,t.renderable.getMatrix()),h(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),&quot;vtkOpenGLImageSlice&quot;);Jt(&quot;vtkImageSlice&quot;,$f);const qf={};const Xf=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qf,n),qt.extend(e,t,n),t.keyMatrixTime={},ht(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),Ct(e,t,[&quot;context&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLVolume&quot;),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),p(t.MCWCMatrix,t.renderable.getMatrix()),h(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?fe(t.normalMatrix):(le(t.normalMatrix,t.MCWCMatrix),me(t.normalMatrix,t.normalMatrix),ge(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),&quot;vtkOpenGLVolume&quot;);Jt(&quot;vtkVolume&quot;,Xf);const Yf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},Zf={FRACTIONAL:0,PROPORTIONAL:1},Qf={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var Jf={InterpolationType:Yf,OpacityMode:Zf,ColorMixPreset:Qf,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const eg={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var tg={BlendMode:eg};const{vtkWarningMacro:ng,vtkErrorMacro:rg}=Ht,og={idxToView:m(new Float64Array(16)),vecISToVCMatrix:fe(new Float64Array(9)),modelToView:m(new Float64Array(16)),projectionToView:m(new Float64Array(16)),projectionToWorld:m(new Float64Array(16))};const ag={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const ig=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ag,n),qt.extend(e,t,n),Vd(e,t,n),t.VBOBuildTime={},ht(t.VBOBuildTime,{mtime:0}),t.tris=ld.newInstance(),t.jitterTexture=Pd.newInstance(),t.jitterTexture.setWrapS(cd.REPEAT),t.jitterTexture.setWrapT(cd.REPEAT),t.framebuffer=Sp.newInstance(),Ct(e,t,[&quot;context&quot;]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===eg.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push(&quot;vtkOpenGLVolumeMapper&quot;);const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType(&quot;vtkOpenGLVolume&quot;);const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\n\\nvarying vec3 vertexVCVSOutput;\\nuniform mat4 PCVCMatrix;\\n\\nuniform float dcxmin;\\nuniform float dcxmax;\\nuniform float dcymin;\\nuniform float dcymax;\\n\\nvoid main()\\n{\\n  // dcsmall is the device coords reduced to the\\n  // x y area covered by the volume\\n  vec4 dcsmall = vec4(\\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\\n    vertexDC.z,\\n    vertexDC.w);\\n  vec4 vcpos = PCVCMatrix * dcsmall;\\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\\n  gl_Position = dcsmall;\\n}\\n&quot;,e.Fragment=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkVolumeFS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// Template for the volume mappers fragment shader\\n\\nconst float infinity = 3.402823466e38;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nin vec3 vertexVCVSOutput;\\n\\n// From Sources\\\\Rendering\\\\Core\\\\VolumeProperty\\\\Constants.js\\n#define COMPOSITE_BLEND 0\\n#define MAXIMUM_INTENSITY_BLEND 1\\n#define MINIMUM_INTENSITY_BLEND 2\\n#define AVERAGE_INTENSITY_BLEND 3\\n#define ADDITIVE_INTENSITY_BLEND 4\\n#define RADON_TRANSFORM_BLEND 5\\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\\n\\n#define vtkNumberOfLights //VTK::NumberOfLights\\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\\n#define vtkNumberOfComponents //VTK::NumberOfComponents\\n#define vtkBlendMode //VTK::BlendMode\\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\\n\\n//VTK::EnabledColorFunctions\\n\\n//VTK::EnabledLightings\\n\\n//VTK::EnabledMultiTexturePerVolume\\n\\n//VTK::EnabledGradientOpacity\\n\\n//VTK::EnabledIndependentComponents\\n\\n//VTK::vtkProportionalComponents\\n\\n//VTK::vtkForceNearestComponents\\n\\nuniform int twoSidedLighting;\\n\\n#if vtkMaxLaoKernelSize > 0\\n  vec2 kernelSample[vtkMaxLaoKernelSize];\\n#endif\\n\\n// Textures\\n#ifdef EnabledMultiTexturePerVolume\\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\\n#else\\n  #define vtkNumberOfVolumeTextures 1\\n#endif\\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\\nuniform sampler2D colorTexture;\\nuniform sampler2D opacityTexture;\\nuniform sampler2D jtexture;\\nuniform sampler2D labelOutlineThicknessTexture;\\n\\nstruct Volume {\\n  // ---- Volume geometry settings ----\\n\\n  vec3 originVC;          // in VC\\n  vec3 spacing;           // in VC per IC\\n  vec3 inverseSpacing;    // 1/spacing\\n  ivec3 dimensions;       // in IC\\n  vec3 inverseDimensions; // 1/vec3(dimensions)\\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\\n  mat4 PCWCMatrix;\\n  mat4 worldToIndex;\\n  float diagonalLength; // in VC, this is: length(size)\\n\\n  // ---- Texture settings ----\\n\\n  // Texture shift and scale\\n  vec4 colorTextureScale;\\n  vec4 colorTextureShift;\\n  vec4 opacityTextureScale;\\n  vec4 opacityTextureShift;\\n\\n  // The heights defined below are the locations for the up to four components\\n  // of the transfer functions. The transfer functions have a height of (2 *\\n  // numberOfComponents) pixels so the values are computed to hit the middle of\\n  // the two rows for that component\\n  vec4 transferFunctionsSampleHeight;\\n\\n  // ---- Mode specific settings ----\\n\\n  // Independent component default preset settings per component\\n  vec4 independentComponentMix;\\n\\n  // Additive / average blending mode settings\\n  vec4 ipScalarRangeMin;\\n  vec4 ipScalarRangeMax;\\n\\n  // ---- Rendering settings ----\\n\\n  // Lighting\\n  float ambient;\\n  float diffuse;\\n  float specular;\\n  float specularPower;\\n  int computeNormalFromOpacity;\\n\\n  // Gradient opacity\\n  vec4 gradientOpacityScale;\\n  vec4 gradientOpacityShift;\\n  vec4 gradientOpacityMin;\\n  vec4 gradientOpacityMax;\\n\\n  // Volume shadow\\n  float volumetricScatteringBlending;\\n  float globalIlluminationReach;\\n  float anisotropy;\\n  float anisotropySquared;\\n\\n  // LAO\\n  int kernelSize;\\n  int kernelRadius;\\n\\n  // Label outline\\n  float outlineOpacity;\\n};\\nuniform Volume volume;\\n\\nstruct Light {\\n  vec3 color;\\n  vec3 positionVC;\\n  vec3 directionVC; // normalized\\n  vec3 halfAngleVC;\\n  vec3 attenuation;\\n  float exponent;\\n  float coneAngle;\\n  int isPositional;\\n};\\n#if vtkNumberOfLights > 0\\n  uniform Light lights[vtkNumberOfLights];\\n#endif\\n\\nuniform float vpWidth;\\nuniform float vpHeight;\\nuniform float vpOffsetX;\\nuniform float vpOffsetY;\\n\\n// Bitmasks for label outline\\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\\n#define MAX_SEGMENTS 256\\n#define UINT_SIZE 32\\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\\n// floor\\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\\nuint labelOutlineBitmasks[BITMASK_SIZE];\\n\\n// Set the corresponding bit in the bitmask\\nvoid setLabelOutlineBit(int segmentIndex) {\\n  int arrayIndex = segmentIndex / UINT_SIZE;\\n  int bitIndex = segmentIndex % UINT_SIZE;\\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\\n}\\n\\n// Check if a bit is set in the bitmask\\nbool isLabelOutlineBitSet(int segmentIndex) {\\n  int arrayIndex = segmentIndex / UINT_SIZE;\\n  int bitIndex = segmentIndex % UINT_SIZE;\\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\\n}\\n\\n// if you want to see the raw tiled\\n// data in webgl1 uncomment the following line\\n// #define debugtile\\n\\n// camera values\\nuniform float camThick;\\nuniform float camNear;\\nuniform float camFar;\\nuniform int cameraParallel;\\n\\n//VTK::ClipPlane::Dec\\n\\n// A random number between 0 and 1 that only depends on the fragment\\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\\n// in screen space\\nfloat fragmentSeed;\\n\\n// sample texture is global\\nuniform float sampleDistance;\\nuniform float volumeShadowSampleDistance;\\n\\n// declaration for intermixed geometry\\n//VTK::ZBuffer::Dec\\n\\n//=======================================================================\\n// global and custom variables (a temporary section before photorealistics\\n// rendering module is complete)\\nvec3 rayDirVC;\\n\\n#define INV4PI 0.0796\\n#define EPSILON 0.001\\n#define PI 3.1415\\n#define PI2 9.8696\\n\\nvec4 rawSampleTexture(vec3 pos) {\\n  #ifdef EnabledMultiTexturePerVolume\\n    vec4 rawSample;\\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\\n  #if vtkNumberOfComponents > 1\\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\\n  #endif\\n  #if vtkNumberOfComponents > 2\\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\\n  #endif\\n  #if vtkNumberOfComponents > 3\\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\\n  #endif\\n    return rawSample;\\n  #else\\n    return texture(volumeTexture[0], pos);\\n  #endif\\n}\\n\\nvec4 rawFetchTexture(ivec3 pos) {\\n  #ifdef EnabledMultiTexturePerVolume\\n    vec4 rawSample;\\n    #if vtkNumberOfComponents > 0\\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\\n    #endif\\n    #if vtkNumberOfComponents > 1\\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\\n    #endif\\n    #if vtkNumberOfComponents > 2\\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\\n    #endif\\n    #if vtkNumberOfComponents > 3\\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\\n    #endif\\n    return rawSample;\\n  #else\\n    return texelFetch(volumeTexture[0], pos, 0);\\n  #endif\\n}\\n\\nvec4 getTextureValue(vec3 pos) {\\n  vec4 tmp = rawSampleTexture(pos);\\n\\n  // Force nearest\\n  #if defined(vtkComponent0ForceNearest) || \\\\\\n      defined(vtkComponent1ForceNearest) || \\\\\\n      defined(vtkComponent2ForceNearest) || \\\\\\n      defined(vtkComponent3ForceNearest)\\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\\n                      volume.inverseDimensions;\\n    vec4 nearestValue = rawSampleTexture(nearestPos);\\n    #ifdef vtkComponent0ForceNearest\\n      tmp[0] = nearestValue[0];\\n    #endif\\n    #ifdef vtkComponent1ForceNearest\\n      tmp[1] = nearestValue[1];\\n    #endif\\n    #ifdef vtkComponent2ForceNearest\\n      tmp[2] = nearestValue[2];\\n    #endif\\n    #ifdef vtkComponent3ForceNearest\\n      tmp[3] = nearestValue[3];\\n    #endif\\n  #endif\\n\\n  // Set alpha when using dependent components\\n  #ifndef EnabledIndependentComponents\\n    #if vtkNumberOfComponents == 1\\n      tmp.a = tmp.r;\\n    #endif\\n    #if vtkNumberOfComponents == 2\\n      tmp.a = tmp.g;\\n    #endif\\n    #if vtkNumberOfComponents == 3\\n      tmp.a = length(tmp.rgb);\\n    #endif\\n  #endif\\n\\n  return tmp;\\n}\\n\\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\\n// when using independent component and `0.5` otherwise. Don't move the if\\n// statement in these function, as the callers usually already knows if it is\\n// using independent component or not\\nfloat getOpacityFromTexture(float scalar, int component, float height) {\\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\\n                       volume.opacityTextureShift[component];\\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\\n}\\nvec3 getColorFromTexture(float scalar, int component, float height) {\\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\\n                       volume.colorTextureShift[component];\\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\\n}\\n\\n//=======================================================================\\n// transformation between VC and IS space\\n\\n// convert vector position from idx to vc\\nvec3 posIStoVC(vec3 posIS) {\\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\\n}\\n\\n// convert vector position from vc to idx\\nvec3 posVCtoIS(vec3 posVC) {\\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\\n}\\n\\n// Rotate vector to view coordinate\\nvec3 vecISToVC(vec3 dirIS) {\\n  return volume.vecISToVCMatrix * dirIS;\\n}\\n\\n// Rotate vector to idx coordinate\\nvec3 vecVCToIS(vec3 dirVC) {\\n  return volume.vecVCToISMatrix * dirVC;\\n}\\n\\n//=======================================================================\\n// Given a normal compute the gradient opacity factors\\nfloat computeGradientOpacityFactor(float normalMag, int component) {\\n  float goscale = volume.gradientOpacityScale[component];\\n  float goshift = volume.gradientOpacityShift[component];\\n  float gomin = volume.gradientOpacityMin[component];\\n  float gomax = volume.gradientOpacityMax[component];\\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\\n}\\n\\n#ifdef vtkClippingPlanesOn\\n  bool isPointClipped(vec3 posVC) {\\n    for (int i = 0; i < clip_numPlanes; ++i) {\\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n#endif\\n\\n//=======================================================================\\n// compute the normal and gradient magnitude for a position, uses forward\\n// difference\\n\\n// The output normal is in VC\\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\\n                          float gradientOpacity, int component) {\\n  // Pass the scalars through the opacity functions\\n  vec4 opacityG;\\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\\n                                      opacityTextureHeight);\\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\\n                                      opacityTextureHeight);\\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\\n                                      opacityTextureHeight);\\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\\n                                      opacityTextureHeight);\\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\\n                                      opacityTextureHeight);\\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\\n                                      opacityTextureHeight);\\n\\n  // Divide by spacing and convert to VC\\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\\n  opacityG.w = length(opacityG.xyz);\\n  if (opacityG.w == 0.0) {\\n    return vec4(0.0);\\n  }\\n\\n  // Normalize\\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\\n\\n  return opacityG;\\n}\\n\\n// The output normal is in VC\\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\\n                             const int opacityComponent) {\\n  vec3 offsetedPosIS;\\n  for (int axis = 0; axis < 3; ++axis) {\\n    // Positive direction\\n    offsetedPosIS = posIS;\\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\\n    scalarInterp[0][axis] =\\n        getTextureValue(offsetedPosIS)[opacityComponent];\\n    #ifdef vtkClippingPlanesOn\\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\\n        scalarInterp[0][axis] = 0.0;\\n      }\\n    #endif\\n\\n    // Negative direction\\n    offsetedPosIS = posIS;\\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\\n    scalarInterp[1][axis] =\\n        getTextureValue(offsetedPosIS)[opacityComponent];\\n    #ifdef vtkClippingPlanesOn\\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\\n        scalarInterp[1][axis] = 0.0;\\n      }\\n    #endif\\n  }\\n\\n  vec4 result;\\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\\n  result.w = length(result.xyz);\\n  if (result.w == 0.0) {\\n    return vec4(0.0);\\n  }\\n  result.xyz = normalize(vecISToVC(result.xyz));\\n  return result;\\n}\\n\\nvec4 fragCoordToPCPos(vec4 fragCoord) {\\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\\n              (fragCoord.z - 0.5) * 2.0, 1.0);\\n}\\n\\nvec4 pcPosToWorldCoord(vec4 pcPos) {\\n  return volume.PCWCMatrix * pcPos;\\n}\\n\\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\\n  vec4 vertex = (worldCoord / worldCoord.w);\\n\\n  vec3 index = (volume.worldToIndex * vertex).xyz;\\n\\n  // half voxel fix for labelmapOutline\\n  return (index + vec3(0.5)) * volume.inverseDimensions;\\n}\\n\\nvec3 fragCoordToWorld(vec4 fragCoord) {\\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\\n  return worldCoord.xyz;\\n}\\n\\n//=======================================================================\\n// Compute the normals and gradient magnitudes for a position for independent\\n// components The output normals are in VC\\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\\n\\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\\n\\n  // divide by spacing\\n  distX *= 0.5 * volume.inverseSpacing.x;\\n  distY *= 0.5 * volume.inverseSpacing.y;\\n  distZ *= 0.5 * volume.inverseSpacing.z;\\n\\n  mat4 result;\\n\\n  // optionally compute the 1st component\\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\\n    {\\n      const int component = 0;\\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\\n      float normalLength = length(normal);\\n      if (normalLength > 0.0) {\\n        normal = normalize(vecISToVC(normal));\\n      }\\n      result[component] = vec4(normal, normalLength);\\n    }\\n  #endif\\n\\n  // optionally compute the 2nd component\\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\\n    {\\n      const int component = 1;\\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\\n      float normalLength = length(normal);\\n      if (normalLength > 0.0) {\\n        normal = normalize(vecISToVC(normal));\\n      }\\n      result[component] = vec4(normal, normalLength);\\n    }\\n  #endif\\n\\n  // optionally compute the 3rd component\\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\\n    {\\n      const int component = 2;\\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\\n      float normalLength = length(normal);\\n      if (normalLength > 0.0) {\\n        normal = normalize(vecISToVC(normal));\\n      }\\n      result[component] = vec4(normal, normalLength);\\n    }\\n  #endif\\n\\n  // optionally compute the 4th component\\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\\n    {\\n      const int component = 3;\\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\\n      float normalLength = length(normal);\\n      if (normalLength > 0.0) {\\n        normal = normalize(vecISToVC(normal));\\n      }\\n      result[component] = vec4(normal, normalLength);\\n    }\\n  #endif\\n\\n  return result;\\n}\\n\\n//=======================================================================\\n// global shadow - secondary ray\\n\\n// henyey greenstein phase function\\nfloat phaseFunction(float cos_angle) {\\n  // divide by 2.0 instead of 4pi to increase intensity\\n  float anisotropy = volume.anisotropy;\\n  if (abs(anisotropy) <= EPSILON) {\\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\\n    return 0.5;\\n  }\\n  float anisotropy2 = volume.anisotropySquared;\\n  return ((1.0 - anisotropy2) /\\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\\n         2.0;\\n}\\n\\n// Compute the two intersection distances of the ray with the volume in VC\\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\\n// volume is not intersected The ray origin is inside the box when distanceMin <\\n// 0.0 < distanceMax\\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\\n  // Compute origin and direction in IS\\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\\n  // Don't check for infinity as the min/max combination afterward will always\\n  // find an intersection before infinity\\n  vec3 invDir = 1.0 / rayDirIS;\\n\\n  // We have: bound = origin + t * dir\\n  // So: t = (1/dir) * (bound - origin)\\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\\n  // Min and max distances to plane intersection per plane\\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\\n  // Overall first and last intersection\\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\\n  return vec2(distanceMin, distanceMax);\\n}\\n\\n//=======================================================================\\n// local ambient occlusion\\n#if vtkMaxLaoKernelSize > 0\\n\\n  // Return a random point on the unit sphere\\n  vec3 sampleDirectionUniform(int rayIndex) {\\n    // Each ray of each fragment should be different, two sources of randomness\\n    // are used. Only depends on ray index\\n    vec2 rayRandomness = kernelSample[rayIndex];\\n    // Only depends on fragment\\n    float fragmentRandomness = fragmentSeed;\\n    // Merge both source of randomness in a single uniform random variable using\\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\\n    // result in a uniform distribution\\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\\n\\n    // Insipred by:\\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\\n    float u = mergedRandom[0];\\n    float v = mergedRandom[1];\\n    float theta = u * 2.0 * PI;\\n    float phi = acos(2.0 * v - 1.0);\\n    float sinTheta = sin(theta);\\n    float cosTheta = cos(theta);\\n    float sinPhi = sin(phi);\\n    float cosPhi = cos(phi);\\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\\n  }\\n\\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\\n    // apply LAO only at selected locations, otherwise return full brightness\\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\\n      return 1.0;\\n    }\\n\\n    #ifdef EnabledGradientOpacity\\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\\n    #endif\\n\\n    float visibilitySum = 0.0;\\n    float weightSum = 0.0;\\n    for (int i = 0; i < volume.kernelSize; i++) {\\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\\n      // normalDotRay should be negative\\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\\n      if (normalDotRay > 0.0) {\\n        // Flip rayDirectionVC when it is in the wrong hemisphere\\n        rayDirectionVC = -rayDirectionVC;\\n        normalDotRay = -normalDotRay;\\n      }\\n\\n      vec3 currPosIS = posVCtoIS(posVC);\\n      float visibility = 1.0;\\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\\n      for (int j = 0; j < volume.kernelRadius; j++) {\\n        currPosIS += randomDirStepIS;\\n        // If out of the volume, we are done\\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\\n            any(greaterThan(currPosIS, vec3(1.0)))) {\\n          break;\\n        }\\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\\n        #ifdef EnabledGradientOpacity\\n          opacity *= gradientOpacityFactor;\\n        #endif\\n        visibility *= 1.0 - opacity;\\n        // If visibility is less than EPSILON, consider it to be 0\\n        if (visibility < EPSILON) {\\n          visibility = 0.0;\\n          break;\\n        }\\n      }\\n      float rayWeight = -normalDotRay;\\n      visibilitySum += visibility * rayWeight;\\n      weightSum += rayWeight;\\n    }\\n\\n    // If no sample, LAO factor is one\\n    if (weightSum == 0.0) {\\n      return 1.0;\\n    }\\n\\n    // LAO factor is the average visibility:\\n    // - visibility low => ambient low\\n    // - visibility high => ambient high\\n    float lao = visibilitySum / weightSum;\\n\\n    // Reduce variance by clamping\\n    return clamp(lao, 0.3, 1.0);\\n  }\\n#endif\\n\\n//=======================================================================\\n// Volume shadows\\n#if vtkNumberOfLights > 0\\n\\n  // Non-memoised version\\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\\n    // modify sample distance with a random number between 1.5 and 3.0\\n    float rayStepLength =\\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\\n\\n    // in case the first sample near surface has a very tiled light ray, we need\\n    // to offset start position\\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\\n\\n    #ifdef vtkClippingPlanesOn\\n      float clippingPlanesMaxDistance = infinity;\\n      for (int i = 0; i < clip_numPlanes; ++i) {\\n        // Find distance of intersection with the plane\\n        // Points are clipped when:\\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\\n        // This is equivalent to:\\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\\n        // planeNormal) > 0.0\\n        // We precompute the dot products, so we clip ray points when:\\n        // dotOrigin - distance * dotDirection > 0.0\\n        float dotOrigin =\\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\\n        if (dotOrigin > 0.0) {\\n          // The initialPosVC is clipped by this plane\\n          return 1.0;\\n        }\\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\\n        if (dotDirection < 0.0) {\\n          // We only hit the plane if dotDirection is negative, as (distance is\\n          // positive)\\n          float intersectionDistance =\\n              dotOrigin / dotDirection; // negative divided by negative => positive\\n          clippingPlanesMaxDistance =\\n              min(clippingPlanesMaxDistance, intersectionDistance);\\n        }\\n      }\\n    #endif\\n\\n    vec2 intersectionDistances =\\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\\n\\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\\n        intersectionDistances[1] <= 0.0) {\\n      // Volume not hit or behind the ray\\n      return 1.0;\\n    }\\n\\n    // When globalIlluminationReach is 0, no sample at all\\n    // When globalIlluminationReach is 1, the ray will go through the whole\\n    // volume\\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\\n                                  volume.globalIlluminationReach);\\n    float startDistance = max(intersectionDistances[0], 0.0);\\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\\n    #ifdef vtkClippingPlanesOn\\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\\n    #endif\\n    if (endDistance - startDistance < 0.0) {\\n      return 1.0;\\n    }\\n\\n    // These two variables are used to compute posIS, without having to call\\n    // VCtoIS at each step\\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\\n    // The light dir is scaled and rotated, but not translated, as it is a\\n    // vector (w = 0)\\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\\n\\n    float shadow = 1.0;\\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\\n          currentDistance += rayStepLength) {\\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\\n      vec4 scalar = getTextureValue(posIS);\\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\\n        vec3 scalarInterp[2];\\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\\n        opacity *= opacityFactor;\\n      #endif\\n      shadow *= 1.0 - opacity;\\n\\n      // Early termination if shadow coeff is near 0.0\\n      if (shadow < EPSILON) {\\n        return 0.0;\\n      }\\n    }\\n    return shadow;\\n  }\\n\\n  // Some cache for volume shadows\\n  struct {\\n    vec3 posVC;\\n    float shadow;\\n  } cachedShadows[vtkNumberOfLights];\\n\\n  // Memoised version\\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\\n    if (posVC == cachedShadows[lightIdx].posVC) {\\n      return cachedShadows[lightIdx].shadow;\\n    }\\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\\n    cachedShadows[lightIdx].posVC = posVC;\\n    cachedShadows[lightIdx].shadow = shadow;\\n    return shadow;\\n  }\\n\\n#endif\\n\\n//=======================================================================\\n// surface light contribution\\n#if vtkNumberOfLights > 0\\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\\n    vec3 specular = vec3(0.0, 0.0, 0.0);\\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\\n      if (df > 0.0) {\\n        diffuse += df * lights[lightIdx].color;\\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\\n        if (sf > 0.0) {\\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\\n        }\\n      }\\n    }\\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\\n          specular * volume.specular;\\n  }\\n\\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\\n                                  vec4 normalVC) {\\n    // everything in VC\\n    vec3 diffuse = vec3(0.0);\\n    vec3 specular = vec3(0.0);\\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\\n      vec3 vertLightDirection;\\n      float attenuation;\\n      if (lights[ligthIdx].isPositional == 1) {\\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\\n        float lightDistance = length(vertLightDirection);\\n        // Normalize with precomputed length\\n        vertLightDirection = vertLightDirection / lightDistance;\\n        // Base attenuation\\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\\n        attenuation =\\n            1.0 / (attenuationPolynom[0] +\\n                  lightDistance * (attenuationPolynom[1] +\\n                                    lightDistance * attenuationPolynom[2]));\\n        // Cone attenuation\\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\\n        // Per OpenGL standard cone angle is 90 or less for a spot light\\n        if (lights[ligthIdx].coneAngle <= 90.0) {\\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\\n            // Inside the cone\\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\\n          } else {\\n            // Outside the cone\\n            attenuation = 0.0;\\n          }\\n        }\\n      } else {\\n        vertLightDirection = lights[ligthIdx].directionVC;\\n        attenuation = 1.0;\\n      }\\n\\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\\n        ndotL = -ndotL;\\n      }\\n      if (ndotL > 0.0) {\\n        // Diffuse\\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\\n        // Specular\\n        float vdotR =\\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\\n        if (vdotR > 0.0) {\\n          specular += pow(vdotR, volume.specularPower) * attenuation *\\n                      lights[ligthIdx].color;\\n        }\\n      }\\n    }\\n    #if vtkMaxLaoKernelSize > 0\\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\\n    #else\\n      const float laoFactor = 1.0;\\n    #endif\\n    return tColor * (diffuse * volume.diffuse +\\n                    volume.ambient * laoFactor) +\\n          specular * volume.specular;\\n  }\\n\\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\\n    // Here we have no effect of cones and no attenuation\\n    vec3 diffuse = vec3(0.0);\\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\\n                            ? normalize(lights[lightIdx].positionVC - posVC)\\n                            : -lights[lightIdx].directionVC;\\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\\n    }\\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\\n  }\\n#endif\\n\\n// LAO of surface shadows and volume shadows only work with dependent components\\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\\n                       vec4 surfaceNormalVC) {\\n  #if vtkNumberOfLights > 0\\n    // 0 <= volCoeff < EPSILON => only surface shadows\\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\\n    // 1 - EPSILON <= volCoeff => only volume shadows\\n    float volCoeff = volume.volumetricScatteringBlending *\\n                    (1.0 - alpha / 2.0) *\\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\\n\\n    // Compute surface lighting if needed\\n    vec3 surfaceShadedColor = tColor;\\n    #ifdef EnableSurfaceLighting\\n      if (volCoeff < 1.0 - EPSILON) {\\n        surfaceShadedColor =\\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\\n      }\\n    #endif\\n\\n    // Compute volume lighting if needed\\n    vec3 volumeShadedColor = tColor;\\n    #ifdef EnableVolumeLighting\\n      if (volCoeff >= EPSILON) {\\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\\n      }\\n    #endif\\n\\n    // Return the right mix\\n    if (volCoeff < EPSILON) {\\n      // Surface shadows\\n      return surfaceShadedColor;\\n    }\\n    if (volCoeff >= 1.0 - EPSILON) {\\n      // Volume shadows\\n      return volumeShadedColor;\\n    }\\n    // Mix of surface and volume shadows\\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\\n  #endif\\n  return tColor;\\n}\\n\\nvec4 getColorForLabelOutline() {\\n  vec3 centerPosIS =\\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\\n  vec4 centerValue = getTextureValue(centerPosIS);\\n  bool pixelOnBorder = false;\\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\\n\\n  int segmentIndex = int(centerValue.r * 255.0);\\n\\n  // Use texture sampling for outlineThickness\\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\\n  float textureValue =\\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\\n  int actualThickness = int(textureValue * 255.0);\\n\\n  // If it is the background (segment index 0), we should quickly bail out.\\n  // Previously, this was determined by tColor.a, which was incorrect as it\\n  // prevented the outline from appearing when the fill is 0.\\n  if (segmentIndex == 0) {\\n    return vec4(0, 0, 0, 0);\\n  }\\n\\n  // Only perform outline check on fragments rendering voxels that aren't\\n  // invisible. Saves a bunch of needless checks on the background.\\n  // TODO define epsilon when building shader?\\n  for (int i = -actualThickness; i <= actualThickness; i++) {\\n    for (int j = -actualThickness; j <= actualThickness; j++) {\\n      if (i == 0 || j == 0) {\\n        continue;\\n      }\\n\\n      vec4 neighborPixelCoord =\\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\\n               gl_FragCoord.z, gl_FragCoord.w);\\n\\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n      vec4 value = getTextureValue(neighborPosIS);\\n\\n      // If any of my neighbours are not the same value as I\\n      // am, this means I am on the border of the segment.\\n      // We can break the loops\\n      if (any(notEqual(value, centerValue))) {\\n        pixelOnBorder = true;\\n        break;\\n      }\\n    }\\n\\n    if (pixelOnBorder == true) {\\n      break;\\n    }\\n  }\\n\\n  // If I am on the border, I am displayed at full opacity\\n  if (pixelOnBorder == true) {\\n    tColor.a = volume.outlineOpacity;\\n  }\\n\\n  return tColor;\\n}\\n\\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\\n  // compute normals\\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\\n  vec4 normalLights[2];\\n  normalLights[0] = normalMat[0];\\n  normalLights[1] = normalMat[1];\\n  #if vtkNumberOfLights > 0\\n    if (volume.computeNormalFromOpacity == 1) {\\n      for (int component = 0; component < 2; ++component) {\\n        vec3 scalarInterp[2];\\n        float height = volume.transferFunctionsSampleHeight[component];\\n        computeNormalForDensity(posIS, scalarInterp, component);\\n        normalLights[component] =\\n            computeDensityNormal(scalarInterp, height, 1.0, component);\\n      }\\n    }\\n  #endif\\n\\n  // compute opacities\\n  float opacities[2];\\n  opacities[0] = getOpacityFromTexture(\\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\\n  opacities[1] = getOpacityFromTexture(\\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\\n  #ifdef EnabledGradientOpacity\\n    for (int component = 0; component < 2; ++component) {\\n      opacities[component] *=\\n          computeGradientOpacityFactor(normalMat[component].a, component);\\n    }\\n  #endif\\n  float opacitySum = opacities[0] + opacities[1];\\n  if (opacitySum <= 0.0) {\\n    return vec4(0.0);\\n  }\\n\\n  // mix the colors and opacities\\n  vec3 colors[2];\\n  for (int component = 0; component < 2; ++component) {\\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\\n    color = applyAllLightning(color, opacities[component], posVC,\\n                              normalLights[component]);\\n    colors[component] = color;\\n  }\\n  vec3 mixedColor =\\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\\n  return vec4(mixedColor, min(1.0, opacitySum));\\n}\\n\\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\\n  // compute normals\\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\\n  vec4 normalLight = normalMat[0];\\n  #if vtkNumberOfLights > 0\\n    if (volume.computeNormalFromOpacity == 1) {\\n      vec3 scalarInterp[2];\\n      float height = volume.transferFunctionsSampleHeight[0];\\n      computeNormalForDensity(posIS, scalarInterp, 0);\\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\\n    }\\n  #endif\\n\\n  // compute opacities\\n  float opacity = getOpacityFromTexture(\\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\\n  #ifdef EnabledGradientOpacity\\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\\n  #endif\\n\\n  // colorizing component\\n  vec3 colorizingColor = getColorFromTexture(\\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\\n  float colorizingOpacity = getOpacityFromTexture(\\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\\n\\n  // mix the colors and opacities\\n  vec3 color =\\n      getColorFromTexture(tValue[0], 0,\\n                          volume.transferFunctionsSampleHeight[0]) *\\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\\n  color = applyAllLightning(color, opacity, posVC, normalLight);\\n  return vec4(color, opacity);\\n}\\n\\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\\n\\n  // compute the normal vectors as needed\\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\\n  #endif\\n\\n  // process color and opacity for each component\\n  // initial value of alpha is determined by wether the first component is\\n  // proportional or not\\n  #if defined(vtkComponent0Proportional)\\n    // when it is proportional, it starts at 1 (neutral for multiplications)\\n    float alpha = 1.0;\\n  #else\\n    // when it is not proportional, it starts at 0 (neutral for additions)\\n    float alpha = 0.0;\\n  #endif\\n\\n  vec3 mixedColor = vec3(0.0);\\n  #if vtkNumberOfComponents > 0\\n    {\\n      const int component = 0;\\n      vec3 color = getColorFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      float opacity = getOpacityFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      #if !defined(vtkComponent0Proportional)\\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\\n        #ifdef EnabledGradientOpacity\\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\\n        #endif\\n        alpha += alphaContribution;\\n        #if vtkNumberOfLights > 0\\n          color = applyLighting(color, normalMat[component]);\\n        #endif\\n      #else\\n        color *= opacity;\\n        alpha *= mix(opacity, 1.0,\\n                    (1.0 - volume.independentComponentMix[component]));\\n      #endif\\n      mixedColor += volume.independentComponentMix[component] * color;\\n    }\\n  #endif\\n  #if vtkNumberOfComponents > 1\\n    {\\n      const int component = 1;\\n      vec3 color = getColorFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      float opacity = getOpacityFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      #if !defined(vtkComponent1Proportional)\\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\\n        #ifdef EnabledGradientOpacity\\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\\n        #endif\\n        alpha += alphaContribution;\\n        #if vtkNumberOfLights > 0\\n          color = applyLighting(color, normalMat[component]);\\n        #endif\\n      #else\\n        color *= opacity;\\n        alpha *= mix(opacity, 1.0,\\n                    (1.0 - volume.independentComponentMix[component]));\\n      #endif\\n      mixedColor += volume.independentComponentMix[component] * color;\\n    }\\n  #endif\\n  #if vtkNumberOfComponents > 2\\n    {\\n      const int component = 2;\\n      vec3 color = getColorFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      float opacity = getOpacityFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      #if !defined(vtkComponent2Proportional)\\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\\n        #ifdef EnabledGradientOpacity\\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\\n        #endif\\n        alpha += alphaContribution;\\n        #if vtkNumberOfLights > 0\\n          color = applyLighting(color, normalMat[component]);\\n        #endif\\n      #else\\n        color *= opacity;\\n        alpha *= mix(opacity, 1.0,\\n                    (1.0 - volume.independentComponentMix[component]));\\n      #endif\\n      mixedColor += volume.independentComponentMix[component] * color;\\n    }\\n  #endif\\n  #if vtkNumberOfComponents > 3\\n    {\\n      const int component = 3;\\n      vec3 color = getColorFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      float opacity = getOpacityFromTexture(\\n          tValue[component], component,\\n          volume.transferFunctionsSampleHeight[component]);\\n      #if !defined(vtkComponent3Proportional)\\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\\n        #ifdef EnabledGradientOpacity\\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\\n        #endif\\n        alpha += alphaContribution;\\n        #if vtkNumberOfLights > 0\\n          color = applyLighting(color, normalMat[component]);\\n        #endif\\n      #else\\n        color *= opacity;\\n        alpha *= mix(opacity, 1.0,\\n                    (1.0 - volume.independentComponentMix[component]));\\n      #endif\\n      mixedColor += volume.independentComponentMix[component] * color;\\n    }\\n  #endif\\n\\n  return vec4(mixedColor, alpha);\\n}\\n\\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\\n    // the opacity value\\n    vec3 scalarInterp[2];\\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\\n  #endif\\n\\n  // get color and opacity\\n  #if vtkNumberOfComponents == 1\\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\\n  #endif\\n  #if vtkNumberOfComponents == 2\\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\\n                  volume.colorTextureShift[0]);\\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\\n  #endif\\n  #if vtkNumberOfComponents == 3\\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\\n              volume.colorTextureShift.rgb;\\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\\n  #endif\\n  #if vtkNumberOfComponents == 4\\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\\n              volume.colorTextureShift.rgb;\\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\\n  #endif\\n\\n  // Apply gradient opacity\\n  #if defined(EnabledGradientOpacity)\\n    alpha *= gradientOpacity;\\n  #endif\\n\\n  #if vtkNumberOfComponents == 1\\n    if (alpha < EPSILON) {\\n      return vec4(0.0);\\n    }\\n  #endif\\n\\n  // lighting\\n  #if vtkNumberOfLights > 0\\n    vec4 normalLight;\\n    if (volume.computeNormalFromOpacity == 1) {\\n      if (normal0[3] != 0.0) {\\n        normalLight =\\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\\n        if (normalLight[3] == 0.0) {\\n          normalLight = normal0;\\n        }\\n      }\\n    } else {\\n      normalLight = normal0;\\n    }\\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\\n  #endif\\n\\n  return vec4(tColor, alpha);\\n}\\n\\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\\n  #ifdef EnableColorForValueFunctionId0\\n    return getColorForDependentComponents(tValue, posVC, posIS);\\n  #endif\\n\\n  #ifdef EnableColorForValueFunctionId1\\n    return getColorForAdditivePreset(tValue, posVC, posIS);\\n  #endif\\n\\n  #ifdef EnableColorForValueFunctionId2\\n    return getColorForColorizePreset(tValue, posVC, posIS);\\n  #endif\\n\\n  #ifdef EnableColorForValueFunctionId3\\n    /*\\n      * Mix the color information from all the independent components to get a\\n      * single rgba output. See other shader functions like\\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\\n      * The custom color mix should return a value, but if it doesn't, it will\\n      * fallback on the default shading\\n      */\\n    //VTK::CustomColorMix\\n  #endif\\n\\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\\n    return getColorForDefaultIndependentPreset(tValue, posIS);\\n  #endif\\n\\n  #ifdef EnableColorForValueFunctionId5\\n    return getColorForLabelOutline();\\n  #endif\\n}\\n\\nbool valueWithinScalarRange(vec4 val) {\\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\\n    return false;\\n  #endif\\n  vec4 rangeMin = volume.ipScalarRangeMin;\\n  vec4 rangeMax = volume.ipScalarRangeMax;\\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\\n    if (val[component] < rangeMin[component] ||\\n        rangeMax[component] < val[component]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\\n                              int segmentIndex, vec3 stepIS) {\\n    vec3 volumeDimensions = vec3(volume.dimensions);\\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\\n                                  gl_FragCoord.y + float(yFragmentOffset),\\n                                  gl_FragCoord.z, gl_FragCoord.w);\\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\\n\\n    vec3 neighborPosIS = originalNeighborPosIS;\\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\\n      vec4 texValue = rawFetchTexture(texCoord);\\n      if (int(texValue.g) == segmentIndex) {\\n        // not on edge\\n        return false;\\n      }\\n      neighborPosIS += stepIS;\\n    }\\n\\n    neighborPosIS = originalNeighborPosIS;\\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\\n      vec4 texValue = rawFetchTexture(texCoord);\\n      if (int(texValue.g) == segmentIndex) {\\n        // not on edge\\n        return false;\\n      }\\n      neighborPosIS -= stepIS;\\n    }\\n\\n    // onedge\\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\\n    vec3 tColorSegment =\\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\\n    float pwfValueSegment =\\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\\n    return true;\\n  }\\n#endif\\n\\nvec4 getColorAtPos(vec3 posVC) {\\n  vec3 posIS = posVCtoIS(posVC);\\n  vec4 texValue = getTextureValue(posIS);\\n  return getColorForValue(texValue, posVC, posIS);\\n}\\n\\n//=======================================================================\\n// Apply the specified blend mode operation along the ray's path.\\n//\\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\\n                float maxDistance) {\\n  // start slightly inside and apply some jitter\\n  vec3 stepVC = rayDirVC * sampleDistance;\\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\\n\\n  // Avoid 0.0 jitter\\n  float jitter = 0.01 + 0.99 * fragmentSeed;\\n\\n  #if vtkBlendMode == COMPOSITE_BLEND\\n    // now map through opacity and color\\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\\n    vec4 firstColor = getColorAtPos(firstPosVC);\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0) {\\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\\n      gl_FragData[0] = firstColor;\\n      return;\\n    }\\n\\n    // first color only counts for `jitter` factor of the step\\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\\n    vec3 posVC = firstPosVC + jitter * stepVC;\\n    float stepsTraveled = jitter;\\n\\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) {\\n        break;\\n      }\\n      vec4 tColor = getColorAtPos(posVC);\\n\\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\\n      stepsTraveled++;\\n      posVC += stepVC;\\n      if (color.a > 0.99) {\\n        color.a = 1.0;\\n        break;\\n      }\\n    }\\n\\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\\n      vec4 tColor = getColorAtPos(endPosVC);\\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\\n\\n      float mix = (1.0 - color.a);\\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\\n    }\\n\\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\\n  #endif\\n\\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\\\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\\n    // Find maximum/minimum intensity along the ray.\\n\\n    // Define the operation we will use (min or max)\\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\\n      #define OP max\\n    #else\\n      #define OP min\\n    #endif\\n\\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\\n    float stepsTraveled = 0.0;\\n\\n    // Find a value to initialize the selected variables\\n    vec4 selectedValue;\\n    vec3 selectedPosVC;\\n    vec3 selectedPosIS;\\n    {\\n      vec3 posIS = posVCtoIS(posVC);\\n      selectedValue = getTextureValue(posIS);\\n      selectedPosVC = posVC;\\n      selectedPosIS = posIS;\\n    }\\n\\n    // If the clipping range is shorter than the sample distance\\n    // we can skip the sampling loop along the ray.\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\\n      return;\\n    }\\n\\n    posVC += jitter * stepVC;\\n    stepsTraveled += jitter;\\n\\n    // Sample along the ray until vtkMaximumNumberOfSamples,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) {\\n        break;\\n      }\\n\\n      // Get selected values\\n      vec3 posIS = posVCtoIS(posVC);\\n      vec4 previousSelectedValue = selectedValue;\\n      vec4 currentValue = getTextureValue(posIS);\\n      selectedValue = OP(selectedValue, currentValue);\\n      if (previousSelectedValue != selectedValue) {\\n        selectedPosVC = posVC;\\n        selectedPosIS = posIS;\\n      }\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posVC += stepVC;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posVC = rayOriginVC + maxDistance * rayDirVC;\\n    {\\n      vec3 posIS = posVCtoIS(posVC);\\n      vec4 previousSelectedValue = selectedValue;\\n      vec4 currentValue = getTextureValue(posIS);\\n      selectedValue = OP(selectedValue, currentValue);\\n      if (previousSelectedValue != selectedValue) {\\n        selectedPosVC = posVC;\\n        selectedPosIS = posIS;\\n      }\\n    }\\n\\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\\n  #endif\\n\\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\\\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\\n    vec4 sum = vec4(0.);\\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\\n      float totalWeight = 0.0;\\n    #endif\\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\\n    float stepsTraveled = 0.0;\\n\\n    vec3 posIS = posVCtoIS(posVC);\\n    vec4 value = getTextureValue(posIS);\\n\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\\n      return;\\n    }\\n\\n    if (valueWithinScalarRange(value)) {\\n      sum += value * jitter;\\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\\n        totalWeight += jitter;\\n      #endif\\n    }\\n    posVC += jitter * stepVC;\\n    stepsTraveled += jitter;\\n\\n    // Sample along the ray until vtkMaximumNumberOfSamples,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) {\\n        break;\\n      }\\n\\n      posIS = posVCtoIS(posVC);\\n      value = getTextureValue(posIS);\\n      // One can control the scalar range by setting the AverageIPScalarRange to\\n      // disregard scalar values, not in the range of interest, from the average\\n      // computation. Notes:\\n      // - We are comparing all values in the texture to see if any of them\\n      //   are outside of the scalar range. In the future we might want to allow\\n      //   scalar ranges for each component.\\n      if (valueWithinScalarRange(value)) {\\n        sum += value;\\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\\n          totalWeight++;\\n        #endif\\n      }\\n\\n      stepsTraveled++;\\n      posVC += stepVC;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posVC = rayOriginVC + maxDistance * rayDirVC;\\n    posIS = posVCtoIS(posVC);\\n    value = getTextureValue(posIS);\\n    if (valueWithinScalarRange(value)) {\\n      sum += value;\\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\\n        totalWeight += raySteps - stepsTraveled;\\n      #endif\\n    }\\n\\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\\n    #endif\\n\\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\\n  #endif\\n\\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\\n    float normalizedRayIntensity = 1.0;\\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\\n    float stepsTraveled = 0.0;\\n\\n    // handle very thin volumes\\n    if (raySteps <= 1.0) {\\n      vec3 posIS = posVCtoIS(posVC);\\n      vec4 tValue = getTextureValue(posIS);\\n      normalizedRayIntensity -= raySteps * sampleDistance *\\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\\n      gl_FragData[0] =\\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\\n      return;\\n    }\\n\\n    posVC += jitter * stepVC;\\n    stepsTraveled += jitter;\\n\\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\\n      if (stepsTraveled + 1.0 >= raySteps) {\\n        break;\\n      }\\n\\n      vec3 posIS = posVCtoIS(posVC);\\n      vec4 value = getTextureValue(posIS);\\n      // Convert scalar value to normalizedRayIntensity coefficient and\\n      // accumulate normalizedRayIntensity\\n      normalizedRayIntensity -=\\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\\n\\n      posVC += stepVC;\\n      stepsTraveled++;\\n    }\\n\\n    // map normalizedRayIntensity to color\\n    gl_FragData[0] =\\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\\n  #endif\\n\\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\\n    // Only works with a single volume\\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\\n    float stepsTraveled = 0.0;\\n    vec3 posIS = posVCtoIS(posVC);\\n    vec4 tValue = getTextureValue(posIS);\\n    if (raySteps <= 1.0) {\\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\\n      return;\\n    }\\n\\n    vec3 stepIS = vecVCToIS(stepVC);\\n    vec4 value = tValue;\\n    posIS += jitter * stepIS;\\n    stepsTraveled += jitter;\\n    vec3 maxPosIS = posIS; // Store the position of the max value\\n    int segmentIndex = int(value.g);\\n    bool originalPosHasSeenNonZero = false;\\n\\n    if (segmentIndex != 0) {\\n      // Tried using the segment index in an boolean array but reading\\n      // from the array by dynamic indexing was horrondously slow\\n      // so use bit masking instead and assign 1 to the bit corresponding to the\\n      // segment index and later check if the bit is set via bit operations\\n      setLabelOutlineBit(segmentIndex);\\n    }\\n\\n    // Sample along the ray until vtkMaximumNumberOfSamples,\\n    // ending slightly inside the total distance\\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\\n      // If we have reached the last step, break\\n      if (stepsTraveled + 1.0 >= raySteps) {\\n        break;\\n      }\\n\\n      // compute the scalar\\n      tValue = getTextureValue(posIS);\\n      segmentIndex = int(tValue.g);\\n\\n      if (segmentIndex != 0) {\\n        originalPosHasSeenNonZero = true;\\n        setLabelOutlineBit(segmentIndex);\\n      }\\n\\n      if (tValue.r > value.r) {\\n        value = tValue;   // Update the max value\\n        maxPosIS = posIS; // Update the position where max occurred\\n      }\\n\\n      // Otherwise, continue along the ray\\n      stepsTraveled++;\\n      posIS += stepIS;\\n    }\\n\\n    // Perform the last step along the ray using the\\n    // residual distance\\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\\n    tValue = getTextureValue(posIS);\\n\\n    if (tValue.r > value.r) {\\n      value = tValue;   // Update the max value\\n      maxPosIS = posIS; // Update the position where max occurred\\n    }\\n\\n    // If we have not seen any non-zero segments, we can return early\\n    // and grab color from the actual center value first component (image)\\n    if (!originalPosHasSeenNonZero) {\\n      vec3 maxPosVC = posIStoVC(maxPosIS);\\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\\n      return;\\n    }\\n\\n    vec3 neighborRayStepsIS = stepIS;\\n    float neighborRaySteps = raySteps;\\n    bool shouldLookInAllNeighbors = false;\\n\\n    vec3 volumeSpacings = volume.spacing;\\n    float minVoxelSpacing =\\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\\n    vec4 base =\\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\\n\\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\\n                          gl_FragCoord.w);\\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\\n                          gl_FragCoord.w);\\n\\n    vec3 baseWorld = fragCoordToWorld(base);\\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\\n\\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\\n\\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\\n\\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\\n      // bail out quickly if the segment index has not\\n      // been seen by the center segment\\n      if (!isLabelOutlineBitSet(s)) {\\n        continue;\\n      }\\n\\n      // Use texture sampling for outlineThickness so that we can have\\n      // per segment thickness\\n      float textureCoordinate = float(s - 1) / 1024.0;\\n      float textureValue =\\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\\n\\n      int actualThickness = int(textureValue * 255.0);\\n\\n      // check the extreme points in the neighborhood since there is a better\\n      // chance of finding the edge there, so that we can bail out\\n      // faster if we find the edge\\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\\n                                          stepIS) ||\\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\\n                                          stepIS) ||\\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\\n                                          stepIS) ||\\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\\n                                          stepIS);\\n\\n      if (onEdge) {\\n        return;\\n      }\\n\\n      // since the next step is computationally expensive, we need to perform\\n      // some optimizations to avoid it if possible. One of the optimizations\\n      // is to check the whether the minimum of the voxel spacing is greater than\\n      // the 2 * the thickness of the outline segment. If that is the case\\n      // then we can safely skip the next step since we can be sure that the\\n      // the previous 4 checks on the extreme points would caught the entirety\\n      // of the all the fragments inside. i.e., this happens when we zoom out,\\n      if (minVoxelSpacing >\\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\\n        continue;\\n      }\\n\\n      // Loop through the rest, skipping the processed extremes and the center\\n      for (int i = -actualThickness; i <= actualThickness; i++) {\\n        for (int j = -actualThickness; j <= actualThickness; j++) {\\n          if (i == 0 && j == 0)\\n            continue; // Skip the center\\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\\n            continue; // Skip corners\\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\\n            return;\\n          }\\n        }\\n      }\\n    }\\n\\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\\n  #endif\\n}\\n\\n//=======================================================================\\n// given a\\n// - ray direction (rayDir)\\n// - starting point (vertexVCVSOutput)\\n// - bounding planes of the volume\\n// - optionally depth buffer values\\n// - far clipping plane\\n// compute the start/end distances of the ray we need to cast\\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\\n\\n  //VTK::ClipPlane::Impl\\n\\n  // do not go behind front clipping plane\\n  dists.x = max(0.0, dists.x);\\n\\n  // do not go PAST far clipping plane\\n  float farDist = -camThick / rayDirVC.z;\\n  dists.y = min(farDist, dists.y);\\n\\n  // Do not go past the zbuffer value if set\\n  // This is used for intermixing opaque geometry\\n  //VTK::ZBuffer::Impl\\n\\n  return dists;\\n}\\n\\nfloat getFragmentSeed() {\\n  // This first noise has a diagonal pattern\\n  float firstNoise =\\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\\n  // This second noise is made out of blocks of CPU generated noise\\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\\n  // Combine the two sources of noise in a way that the distribution is uniform\\n  // in [0,1[\\n  float noiseSum = firstNoise + secondNoise;\\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\\n}\\n\\nvoid main() {\\n  fragmentSeed = getFragmentSeed();\\n\\n  if (cameraParallel == 1) {\\n    // Camera is parallel, so the rayDir is just the direction of the camera.\\n    rayDirVC = vec3(0.0, 0.0, -1.0);\\n  } else {\\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\\n    rayDirVC = normalize(vertexVCVSOutput);\\n  }\\n\\n  vec3 rayOriginVC = vertexVCVSOutput;\\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\\n      rayStartEndDistancesVC[1] <= 0.0) {\\n    // Volume not hit or behind the ray\\n    discard;\\n  }\\n\\n  // Perform the blending operation along the ray\\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\\n}\\n&quot;,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=td.substitute(o,&quot;//VTK::EnabledColorFunctions&quot;,`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push(&quot;Surface&quot;),t.previousState.volumeLightingEnabled&&a.push(&quot;Volume&quot;),o=td.substitute(o,&quot;//VTK::EnabledLightings&quot;,a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=td.substitute(o,&quot;//VTK::EnabledMultiTexturePerVolume&quot;,&quot;#define EnabledMultiTexturePerVolume&quot;).result),t.previousState.useIndependentComponents&&(o=td.substitute(o,&quot;//VTK::EnabledIndependentComponents&quot;,&quot;#define EnabledIndependentComponents&quot;).result),t.previousState.gradientOpacityEnabled&&(o=td.substitute(o,&quot;//VTK::EnabledGradientOpacity&quot;,&quot;#define EnabledGradientOpacity&quot;).result),o=td.substitute(o,&quot;//VTK::vtkProportionalComponents&quot;,t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join(&quot;\\n&quot;)).result,o=td.substitute(o,&quot;//VTK::vtkForceNearestComponents&quot;,t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join(&quot;\\n&quot;)).result,t.previousState.hasZBufferTexture&&(o=td.substitute(o,&quot;//VTK::ZBuffer::Dec&quot;,[&quot;uniform sampler2D zBufferTexture;&quot;,&quot;uniform float vpZWidth;&quot;,&quot;uniform float vpZHeight;&quot;]).result,o=td.substitute(o,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));&quot;,&quot;float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;&quot;,&quot;zdepth = zdepth * 2.0 - 1.0;&quot;,&quot;if (cameraParallel == 0) {&quot;,&quot;zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}&quot;,&quot;else {&quot;,&quot;zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\\n&quot;,&quot;zdepth = -zdepth/rayDirVC.z;&quot;,&quot;dists.y = min(zdepth,dists.y);&quot;]).result),o=td.substitute(o,&quot;//VTK::BlendMode&quot;,`${t.previousState.blendMode}`).result,o=td.substitute(o,&quot;//VTK::NumberOfLights&quot;,`${t.previousState.numberOfLights}`).result,o=td.substitute(o,&quot;//VTK::MaxLaoKernelSize&quot;,`${t.previousState.maxLaoKernelSize}`).result,o=td.substitute(o,&quot;//VTK::NumberOfComponents&quot;,`${t.previousState.numberOfComponents}`).result,o=td.substitute(o,&quot;//VTK::MaximumNumberOfSamples&quot;,`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=td.substitute(o,&quot;//VTK::ClipPlane::Dec&quot;,[&quot;uniform vec3 vClipPlaneNormals[6];&quot;,&quot;uniform float vClipPlaneDistances[6];&quot;,&quot;uniform vec3 vClipPlaneOrigins[6];&quot;,&quot;uniform int clip_numPlanes;&quot;,&quot;//VTK::ClipPlane::Dec&quot;,&quot;#define vtkClippingPlanesOn&quot;],!1).result,o=td.substitute(o,&quot;//VTK::ClipPlane::Impl&quot;,[`for(int i = 0; i < ${i}; i++) {`,&quot;  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);&quot;,&quot;  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];&quot;,&quot;  if (rayDirRatio == 0.0)&quot;,&quot;  {&quot;,&quot;    if (equationResult < 0.0) dists.x = dists.y;&quot;,&quot;    continue;&quot;,&quot;  }&quot;,&quot;  float result = -1.0 * equationResult / rayDirRatio;&quot;,&quot;  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);&quot;,&quot;  else dists.x = max(dists.x, result);&quot;,&quot;}&quot;,&quot;//VTK::ClipPlane::Impl&quot;],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Gi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&ng(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==eg.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Qf.ADDITIVE:return 1;case Qf.COLORIZE:return 2;case Qf.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===Zf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&ke(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed(&quot;vertexDC&quot;)&&(n.getVAO().addAttributeArray(a,n.getCABO(),&quot;vertexDC&quot;,n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||rg(&quot;Error setting vertexDC in shader VAO.&quot;)),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf(&quot;sampleDistance&quot;,i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf(&quot;volumeShadowSampleDistance&quot;,s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p=&quot;volume&quot;;if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi(&quot;zBufferTexture&quot;,t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf(&quot;vpZWidth&quot;,e[0]),a.setUniformf(&quot;vpZHeight&quot;,e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=og,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();b(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),h=g.getClippingRange();f.setUniformf(&quot;camThick&quot;,h[1]-h[0]),f.setUniformf(&quot;camNear&quot;,h[0]),f.setUniformf(&quot;camFar&quot;,h[1]),f.setUniformi(&quot;cameraParallel&quot;,m);const T=t.currentValidInputs[0],y=T.imageData.getBounds(),x=Gi.getCorners(y,[]).map((e=>(In(e,e,l),m||bn(e,e,-h[0]/(e[2]*gn(e))),In(e,e,d.vcpc),e))),C=Gi.addPoints([...Gi.INIT_BOUNDS],x);f.setUniformf(&quot;dcxmin&quot;,C[0]),f.setUniformf(&quot;dcxmax&quot;,C[1]),f.setUniformf(&quot;dcymin&quot;,C[2]),f.setUniformf(&quot;dcymax&quot;,C[3]);const S=e.getRenderTargetSize();f.setUniformf(&quot;vpWidth&quot;,S[0]),f.setUniformf(&quot;vpHeight&quot;,S[1]);const A=e.getRenderTargetOffset();f.setUniformf(&quot;vpOffsetX&quot;,A[0]/S[0]),f.setUniformf(&quot;vpOffsetY&quot;,A[1]/S[1]),v(c,d.vcpc),f.setUniformMatrix(&quot;PCVCMatrix&quot;,c),f.setUniformi(&quot;twoSidedLighting&quot;,o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv(&quot;kernelSample&quot;,I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=bn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();In(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];wn(a,a,d.normalMatrix),Cn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w=&quot;volume&quot;,O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();b(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=xn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,xn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=yn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],Te(s,L,s),Te(s,p.normalMatrix,s),Te(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,me(new Float32Array(9),s));const F=mn(R[0],R[2],R[4]),_=In(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const k=gn(N);if(f.setUniformf(`${w}.diagonalLength`,k),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),v(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(h[0],h[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi(&quot;jtexture&quot;,t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi(&quot;labelOutlineThicknessTexture&quot;,t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi(&quot;opacityTexture&quot;,t.opacityTexture.getTextureUnit()),o.setUniformi(&quot;colorTexture&quot;,t.colorTexture.getTextureUnit());const i=&quot;volume&quot;,s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();wn(t,t,r.normalMatrix),In(n,n,r.wcvc);const l=-1*Sn(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv(&quot;vClipPlaneNormals&quot;,o),c.setUniformfv(&quot;vClipPlaneDistances&quot;,a),c.setUniform3fv(&quot;vClipPlaneOrigins&quot;,i),c.setUniformi(&quot;clip_numPlanes&quot;,l)}},e.delete=Et((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===Yf.NEAREST?(o.setMinificationFilter(ud.NEAREST),o.setMagnificationFilter(ud.NEAREST)):(o.setMinificationFilter(ud.LINEAR),o.setMagnificationFilter(ud.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;uniform vec2 tfactor;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),[&quot;//VTK::System::Dec&quot;,&quot;//VTK::Output::Dec&quot;,&quot;uniform sampler2D texture1;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { gl_FragData[0] = texture2D(texture1,tcoord); }&quot;].join(&quot;\\n&quot;),&quot;&quot;);const e=t.copyShader;t.copyVAO=od.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||rg(&quot;Error setting vertexDC in copy shader VAO.&quot;)}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi(&quot;texture&quot;,n.getTextureUnit()),t.copyShader.setUniform2f(&quot;tfactor&quot;,t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:&quot;StartEvent&quot;}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}let a=0;if(t.currentValidInputs.length>0){const e=r.getProperties(),o=t.currentValidInputs[0],i=o.imageData.getPointData().getScalars(),s=e[o.inputIndex];s.getShade()&&t.renderable.getBlendMode()===eg.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&a++}));const l=t.currentValidInputs.length,c=l>1;t.numberOfComponents=c?l:i.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(s,t.numberOfComponents)}a!==t.numberOfLights&&(t.numberOfLights=a,e.modified()),e.invokeEvent({type:&quot;EndEvent&quot;}),0!==t.currentValidInputs.length&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(ud.NEAREST),t.jitterTexture.setMagnificationFilter(ud.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:cs.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=wf(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=Pd.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(ud.LINEAR),r.setMagnificationFilter(ud.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension(&quot;OES_texture_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:cs.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:cs.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=wf(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(ud.LINEAR),e.setMagnificationFilter(ud.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:cs.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Of(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension(&quot;EXT_texture_norm16&quot;)),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join(&quot;-&quot;);if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=Pd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(ud.NEAREST),e.setMagnificationFilter(ud.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:cs.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=xs.newInstance({numberOfComponents:3,values:e});r.setName(&quot;points&quot;);const o=xs.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,&quot;polys&quot;,Zi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),&quot;vtkOpenGLVolumeMapper&quot;);Jt(&quot;vtkVolumeMapper&quot;,ig);const{vtkDebugMacro:sg}=Ht,lg={};const cg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lg,n),qt.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType(&quot;vtkOpenGLRenderer&quot;),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;);const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():sg(&quot;No framebuffer to save/restore&quot;);const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),&quot;vtkOpenGLPixelSpaceCallbackMapper&quot;);Jt(&quot;vtkPixelSpaceCallbackMapper&quot;,cg);var ug=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtktextureObjectVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n\\nattribute vec4 vertexDC;\\nattribute vec2 tcoordDC;\\nvarying vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  tcoordVC = tcoordDC;\\n  gl_Position = vertexDC;\\n}\\n&quot;;const{Representation:dg}=os;function pg(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=Pd.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:&quot;Float32Array&quot;,data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function fg(e,t){return pg(e,t,Pd.Filter.NEAREST,Pd.Wrap.CLAMP_TO_EDGE)}const gg={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function mg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gg,n),Wt.obj(e,t),Wt.get(e,t,[&quot;readIndex&quot;]),Wt.setGet(e,t,[&quot;doEEPass&quot;,&quot;doVTPass&quot;,&quot;_openGLRenderWindow&quot;,&quot;vectorTexture&quot;,&quot;maskVectorTexture&quot;,&quot;noiseTexture&quot;,&quot;framebuffer&quot;,&quot;size&quot;]),Wt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkLICPingPongBufferManager&quot;),t._openGLRenderWindow?(t.quad=function(e){const t=ld.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=xs.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=xs.newInstance({numberOfComponents:1,values:o}),s=xs.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,dg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=fg(t._openGLRenderWindow,t.size),t.seedTexture0=fg(t._openGLRenderWindow,t.size),t.licTexture1=fg(t._openGLRenderWindow,t.size),t.seedTexture1=fg(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?pg(t._openGLRenderWindow,t.size,Pd.Filter.NEAREST,Pd.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,pg(n,r,Pd.Filter.LINEAR,Pd.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=od.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error(&quot;Wrong LIC pass number&quot;)}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error(&quot;Pass renderwindow to ping pong manager&quot;);var n,r}(e,t)}var hg={newInstance:Wt.newInstance(mg,&quot;vtkLICPingPongBufferManager&quot;),extend:mg};const vg=0,Tg=1,yg=2,bg=3,xg=1,Cg={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function Sg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cg,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;nuberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;componentIds&quot;,&quot;isComposite&quot;]),Wt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),function(e,t){function n(e,t){e.setUniformi(&quot;texLIC&quot;,t.getLICTextureUnit()),e.setUniformi(&quot;texSeedPts&quot;,t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push(&quot;vtkLineIntegralConvolution2D&quot;),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(ug,e,&quot;&quot;),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=Sp.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t=&quot;xyzw&quot;;return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n/**\\nThis shader initializes the convolution for the LIC computation.\\n*/\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texMaskVectors;\\nuniform sampler2D texNoise;\\nuniform sampler2D texLIC;\\n\\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the *whole* domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value. this\\n// depends on the pass number.\\nvec2 getNoiseTC(vec2 vectc)\\n{\\n  // in pass 1 : convert from vector tc to noise tc\\n  // in pass 2 : use vector tc\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(vectc);\\n    }\\n  else\\n    {\\n    return vectc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the\\n// need to convert to noise texture coordinates.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 vectc = tcoordVC.st;\\n\\n  // lic => (convolution, mask, 0, step count)\\n  if (uStepNo == 0)\\n    {\\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\\n    float maskFlag;\\n    if (maskCriteria <= uMaskThreshold)\\n      {\\n      maskFlag = 1.0;\\n      }\\n    else\\n      {\\n      maskFlag = 0.0;\\n      }\\n    float noise = getNoise(vectc);\\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = texture2D(texLIC, vectc);\\n    }\\n\\n  // initial seed\\n  SeedOutput = vec4(vectc, 0.0, 1.0);\\n}\\n&quot;);const n=td.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// move vector field to normalized image space\\n// pre-processing for vtkLineIntegralConvolution2D\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\n// Fragment shader used by the gaussian blur filter render pass.\\n\\nuniform sampler2D texVectors; // input texture\\nuniform vec2      uTexSize;   // size of texture\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  //VTK::LICComponentSelection::Impl\\n  V = V/uTexSize;\\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\\n}\\n&quot;,&quot;//VTK::LICComponentSelection::Impl&quot;,`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=td.substitute(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D  texVectors;\\nuniform sampler2D  texNoise;\\nuniform sampler2D  texLIC;\\nuniform sampler2D  texSeedPts;\\n\\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\\nuniform float uStepSize;        // step size in parametric space\\n\\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\\n\\nin vec2 tcoordVC;\\n\\n//VTK::LICVectorLookup::Impl\\n\\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\\n// are very poorly supported in webgl\\nvec2 clampToBorder(vec2 uv){\\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\\n  {\\n    return vec2(0.0, 0.0);\\n  }\\n  return getVector(uv);\\n}\\n\\n// convert from vector coordinate space to noise coordinate space.\\n// the noise texture is tiled across the whole domain\\nvec2 VectorTCToNoiseTC(vec2 vectc)\\n{\\n  return vectc/uNoiseBoundsPt1;\\n}\\n\\n// get the texture coordidnate to lookup noise value.\\n// in pass 1 repeatedly tile the noise texture across\\n// the computational domain.\\nvec2 getNoiseTC(vec2 tc)\\n{\\n  if (uPassNo == 0)\\n    {\\n    return VectorTCToNoiseTC(tc);\\n    }\\n  else\\n    {\\n    return tc;\\n    }\\n}\\n\\n// look up noise value at the given location. The location\\n// is supplied in vector texture coordinates, hence the need\\n// to convert to either noise or lic texture coordinates in\\n// pass 1 and 2 respectively.\\nfloat getNoise(vec2 vectc)\\n{\\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\\n}\\n\\n// fourth-order Runge-Kutta streamline integration\\n// no bounds checks are made, therefore it's essential\\n// to have the entire texture initialized to 0\\n// and set clamp to border and have border color 0\\n// an integer is set if the step was taken, keeping\\n// an accurate step count is necessary to prevent\\n// boundary artifacts. Don't count the step if\\n// all vector lookups are identically 0. This is\\n// a proxy for \\&quot;stepped outside valid domain\\&quot;\\nvec2 rk4(vec2 pt0, float dt, out bool count)\\n{\\n  count=true;\\n  float dtHalf = dt * 0.5;\\n  vec2 pt1;\\n\\n  vec2 v0 = clampToBorder(pt0);\\n  pt1 = pt0 + v0 * dtHalf;\\n\\n  vec2 v1 = clampToBorder(pt1);\\n  pt1 = pt0 + v1 * dtHalf;\\n\\n  vec2 v2 = clampToBorder(pt1);\\n  pt1 = pt0 + v2 * dt;\\n\\n  vec2 v3 = clampToBorder(pt1);\\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\\n\\n  if (vSum == vec2(0.0, 0.0))\\n    {\\n      count = false;\\n    }\\n\\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\\n\\n return pt1;\\n}\\n\\nvoid main(void)\\n{\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic = texture2D(texLIC, lictc);\\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\\n\\n  bool count;\\n  vec2 pt1 = rk4(pt0, uStepSize, count);\\n\\n  if (count)\\n    {\\n    // accumulate lic step\\n    // (lic, mask, 0, step count)\\n    float noise = getNoise(pt1);\\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\\n    SeedOutput = vec4(pt1, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    // keep existing values\\n    LICOutput = lic;\\n    SeedOutput = vec4(pt0, 0.0, 1.0);\\n    }\\n}\\n&quot;,&quot;//VTK::LICVectorLookup::Impl&quot;,function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      return texture2D( texVectors, vectc ).xy;\\n\\n      }\\n\\n    &quot;:&quot;\\n    vec2 getVector( vec2 vectc )\\n\\n      {\\n\\n      vec2 V = texture2D( texVectors, vectc ).xy;\\n\\n      // normalize if |V| not 0\\n\\n      float lenV = length( V );\\n\\n      if ( lenV > 1.0e-8 )\\n\\n        {\\n\\n        return V/lenV;\\n\\n        }\\n\\n      else\\n\\n        {\\n\\n        return vec2( 0.0, 0.0 );\\n\\n        }\\n\\n      }\\n\\n    &quot;}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(&quot; //VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n/**\\nThis shader finalizes the convolution for the LIC computation\\napplying the normalization. eg. if box kernel is used the this\\nis the number of steps taken.\\n*/\\n\\nuniform sampler2D texLIC;\\n\\nin vec2 tcoordVC;\\n\\nvoid main(void)\\n{\\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\\n  conv.r = conv.r/conv.a;\\n  // lic => (convolution, mask, 0, 1)\\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.CEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// gray scale contrast enhance stage implemented via histogram stretching\\n// if the min and max are tweaked it can generate out-of-range values\\n// these will be clamped in 0 to 1\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\n\\nuniform sampler2D texLIC;  // most recent lic pass\\nuniform float uMin;        // min gray scale color value\\nuniform float uMaxMinDiff; // max-min\\n\\nin vec2 tcoordVC;\\n\\nvoid main( void )\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g!=0.0)\\n    {\\n    LICOutput = lic;\\n    }\\n  else\\n    {\\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\\n    LICOutput = vec4(CElic, lic.gb, 1.0);\\n    }\\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.EEProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\\n// noise for pass2.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 EEOutput;\\n\\nuniform sampler2D texLIC; // most recent lic pass\\nuniform float     uDx;    // fragment size\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// kernel for simple laplace edge enhancement.\\n// p=Laplace(p)+p\\nfloat K[9] = float[9](\\n  -1.0, -1.0, -1.0,\\n  -1.0,  9.0, -1.0,\\n  -1.0, -1.0, -1.0\\n  );\\n\\n// determine if the fragment was masked\\nbool Masked(float val) { return val != 0.0; }\\n\\nvoid main(void)\\n{\\n  // tex coord neighbor offsets\\n  vec2 fragDx[9] = vec2[9](\\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\\n    );\\n\\n  vec2 lictc = tcoordVC.st;\\n\\n  // compute the convolution but don't use convovled values if\\n  // any masked fragments on the stencil. Fragments outside\\n  // the valid domain are masked during initialization, and\\n  // texture wrap parameters are clamp to border with border\\n  // color that contains masked flag\\n  float conv = 0.0;\\n  bool dontUse = false;\\n  for (int i=0; i<9; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    vec4 lic = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic.g);\\n    conv = conv + K[i] * lic.r;\\n    }\\n\\n  if (dontUse)\\n    {\\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\\n    }\\n  else\\n    {\\n    conv = clamp(conv, 0.0, 1.0);\\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\\n    }\\n\\n}\\n&quot;),t.AAHProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// horizontal pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDx;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDx[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;),t.AAVProgram=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// Anti-alias stage in vtkLineIntegralConvolution2D\\n// vertical pass of a Gaussian convolution\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 LICOutput;\\nlayout(location = 1) out vec4 SeedOutput;\\n\\nuniform sampler2D texLIC; // input texture\\nuniform float     uDy;    // fragment size\\n\\nin vec2 tcoordVC;\\n\\n\\n// factored 3x3 Gaussian kernel\\n// K^T*K = G\\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\\n\\n// determine if the fragment was masked\\nbool Masked(float val){ return val != 0.0; }\\n\\nvoid main(void)\\n{\\n// neighbor offsets\\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\\n\\n\\n  vec2 lictc = tcoordVC.st;\\n  vec4 lic[3];\\n  bool dontUse = false;\\n  float conv = 0.0;\\n  for (int i=0; i<3; ++i)\\n    {\\n    vec2 tc = lictc + fragDy[i];\\n    lic[i] = texture2D(texLIC, tc);\\n    dontUse = dontUse || Masked(lic[i].g);\\n    conv = conv + K[i] * lic[i].r;\\n    }\\n  // output is (conv, mask, skip, 1)\\n  if (dontUse)\\n    {\\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\\n    }\\n  else\\n    {\\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\\n    }\\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\\n}\\n&quot;)},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=Sp.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=hg.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f(&quot;uTexSize&quot;,...o),e.setUniformi(&quot;texVectors&quot;,t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,0),y.setUniformf(&quot;uMaskThreshold&quot;,t.maskThreshold),y.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...m),y.setUniformi(&quot;texMaskVectors&quot;,t.bufs.getMaskVectorTextureUnit()),y.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi(&quot;uPassNo&quot;,0),b.setUniformf(&quot;uStepSize&quot;,-d),b.setUniform2f(&quot;uNoiseBoundsPt1&quot;,...m),b.setUniformi(&quot;texVectors&quot;,t.bufs.getImageVectorTextureUnit()),b.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==Tg&&t.enhanceContrast!==bg||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDx&quot;,h),a.setUniformf(&quot;uDy&quot;,v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,0),y.setUniformi(&quot;uPassNo&quot;,1),n(y,t.bufs),y.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi(&quot;uPassNo&quot;,1),b.setUniformf(&quot;uStepSize&quot;,-d),b.setUniformi(&quot;texNoise&quot;,t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi(&quot;uStepNo&quot;,1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf(&quot;uStepSize&quot;,d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),x.setUniformi(&quot;texSeedPts&quot;,t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),e.setUniformf(&quot;uDx&quot;,h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),a.setUniformf(&quot;uDy&quot;,v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==Tg&&t.enhanceContrast!==bg||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error(&quot;Invalid color range: &quot;,i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi(&quot;texLIC&quot;,t.bufs.getLICTextureUnit()),c.setUniformf(&quot;uMin&quot;,i),c.setUniformf(&quot;uMaxMinDiff&quot;,l),r(t.bufs,o,c)}}(e,t)}var Ag={newInstance:Wt.newInstance(Sg,&quot;vtkLineIntegralConvolution2D&quot;),extend:Sg};const Ig={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:vg,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:xg,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function wg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ig,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;enableLIC&quot;,&quot;numberOfSteps&quot;,&quot;stepSize&quot;,&quot;normalizeVectors&quot;,&quot;transformVectors&quot;,&quot;maskOnSurface&quot;,&quot;maskThreshold&quot;,&quot;maskColor&quot;,&quot;maskIntensity&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;noiseTextureSize&quot;,&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;noiseGeneratorSeed&quot;,&quot;viewPortScale&quot;,&quot;rebuildNoiseTexture&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkSurfaceLICInterface&quot;)}(0,t)}var Og={newInstance:Wt.newInstance(wg,&quot;vtkSurfaceLICInterface&quot;),extend:wg};const{Representation:Pg}=os;const Rg={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function Mg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rg,n),Og.extend(e,t,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;context&quot;,&quot;_openGLRenderWindow&quot;,&quot;reallocateTextures&quot;,&quot;licInterface&quot;,&quot;size&quot;]),Wt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICInterface&quot;),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=od.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),&quot;vertexDC&quot;,r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),&quot;tcoordDC&quot;,r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),oo(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get(&quot;noiseTextureType&quot;,&quot;noiseGrainSize&quot;,&quot;numberOfNoiseLevels&quot;,&quot;noiseImpulseProbability&quot;,&quot;noiseImpulseBackgroundValue&quot;,&quot;minNoiseValue&quot;,&quot;maxNoiseValue&quot;);n=r===xg?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=Pd.newInstance({wrapS:Pd.Wrap.REPEAT,wrapT:Pd.Wrap.REPEAT,minificationFilter:Pd.Filter.NEAREST,magnificationFilter:Pd.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:&quot;Float32Array&quot;,data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(ug,e,&quot;&quot;),e.allocateTextures=()=>{const n=Pd.Filter.NEAREST,r=Pd.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=Pd.newInstance({wrapS:Pd.Wrap.CLAMP_TO_EDGE,wrapT:Pd.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:&quot;Float32Array&quot;,data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=Pd.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:&quot;Float32Array&quot;,data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=Sp.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader combines surface geometry, LIC, and  scalar colors.\\n\\n// the output of this shader\\nlayout(location = 0) out vec4 RGBOutput;\\nlayout(location = 1) out vec4 HSLOutput;\\n\\nuniform sampler2D texVectors;       // vectors, depth\\nuniform sampler2D texGeomColors;    // scalar colors + lighting\\nuniform sampler2D texLIC;           // image lic\\nuniform int       uScalarColorMode; // select between blend, and map shader\\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\\nuniform float     uMaskIntensity;   // blending factor for mask color\\nuniform vec3      uMaskColor;       // color for the masked out fragments\\n\\nin vec2 tcoordVC;\\n\\n/**\\nConvert from RGB color space into HSL colorspace.\\n*/\\nvec3 RGBToHSL(vec3 RGB)\\n{\\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\\n\\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\\n  float RGBMaxMinDiff = RGBMax - RGBMin;\\n\\n  HSL.z = (RGBMax + RGBMin) / 2.0;\\n\\n  if (RGBMaxMinDiff == 0.0)\\n    {\\n    // Gray scale\\n    HSL.x = 0.0;\\n    HSL.y = 0.0;\\n    }\\n  else\\n    {\\n    // Color\\n    if (HSL.z < 0.5)\\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\\n    else\\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\\n\\n    float dR\\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dG\\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n    float dB\\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\\n\\n    if (RGB.r == RGBMax)\\n      HSL.x = dB - dG;\\n    else\\n    if (RGB.g == RGBMax)\\n      HSL.x = (1.0 / 3.0) + dR - dB;\\n    else\\n    if (RGB.b == RGBMax)\\n      HSL.x = (2.0 / 3.0) + dG - dR;\\n\\n    if (HSL.x < 0.0)\\n      HSL.x += 1.0;\\n\\n    if (HSL.x > 1.0)\\n      HSL.x -= 1.0;\\n    }\\n\\n  return HSL;\\n}\\n\\n/**\\nHelper for HSL to RGB conversion.\\n*/\\nfloat Util(float v1, float v2, float vH)\\n{\\n  if (vH < 0.0)\\n    vH += 1.0;\\n\\n  if (vH > 1.0)\\n     vH -= 1.0;\\n\\n  if ((6.0 * vH) < 1.0)\\n    return (v1 + (v2 - v1) * 6.0 * vH);\\n\\n  if ((2.0 * vH) < 1.0)\\n    return (v2);\\n\\n  if ((3.0 * vH) < 2.0)\\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\\n\\n  return v1;\\n}\\n\\n/**\\nConvert from HSL space into RGB space.\\n*/\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  if (HSL.y == 0.0)\\n    {\\n    // Gray\\n    RGB.r = HSL.z;\\n    RGB.g = HSL.z;\\n    RGB.b = HSL.z;\\n    }\\n  else\\n    {\\n    // Chromatic\\n    float v2;\\n    if (HSL.z < 0.5)\\n      v2 = HSL.z * (1.0 + HSL.y);\\n    else\\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\\n\\n    float v1 = 2.0 * HSL.z - v2;\\n\\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\\n    RGB.g = Util(v1, v2, HSL.x);\\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\\n    }\\n\\n  return RGB.rgb;\\n}\\n\\nvoid main()\\n{\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n\\n  // depth is used to determine which fragment belong to us\\n  // and we can change\\n  float depth = texture2D(texVectors, tcoordVC.st).a;\\n\\n  vec3 fragColorRGB;\\n  float valid;\\n  if (depth > 1.0e-3)\\n    {\\n    // we own it\\n    // shade LIC'ed geometry, or apply mask\\n    if (lic.g!=0.0)\\n      {\\n      // it's masked\\n      // apply fragment mask\\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\\n      valid = 0.0;\\n      }\\n    else\\n      {\\n      if (uScalarColorMode==0)\\n        {\\n        // blend with scalars\\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\\n        }\\n      else\\n        {\\n        // multiply with scalars\\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\\n        }\\n      if (lic.b != 0.0)\\n        {\\n        // didn't have the required guard pixels\\n        // don't consider it in min max estimation\\n        // for histpgram stretching\\n        valid = 0.0;\\n        }\\n      else\\n        {\\n        // ok to use in min/max estimates for histogram\\n        // stretching\\n        valid = 1.0;\\n        }\\n      }\\n    }\\n  else\\n    {\\n    // we don't own it\\n    // pass through scalars\\n    fragColorRGB = geomColor.rgb;\\n    valid = 0.0;\\n    }\\n\\n  // if no further stages this texture is\\n  // copied to the screen\\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\\n\\n  // if further stages, move to hsl space for contrast\\n  // enhancement. encoding validity saves moving a texture to the cpu\\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\\n  HSLOutput = vec4(fragColorHSL, valid);\\n}\\n&quot;),t.licCopyPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// This shader copies fragments and depths to the output buffer\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texDepth;     // z values from vertex shader\\nuniform sampler2D texRGBColors; // final rgb LIC colors\\n\\nin vec2 tcoordVC;\\n\\nvoid main()\\n{\\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\\n\\n  // since we render a screen aligned quad\\n  // we're going to be writing fragments\\n  // not touched by the original geometry\\n  // it's critical not to modify those\\n  // fragments.\\n  if (gl_FragDepth == 1.0)\\n    {\\n    discard;\\n    }\\n}\\n&quot;),t.enhanceContrastPass=e.buildAShader(&quot;//VTK::System::Dec\\n\\n//=========================================================================\\n//\\n//  Program:   Visualization Toolkit\\n//  Module:    vtkSurfaceLICMapper_CE.glsl\\n//\\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n//  All rights reserved.\\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n//\\n//     This software is distributed WITHOUT ANY WARRANTY; without even\\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n//     PURPOSE.  See the above copyright notice for more information.\\n//\\n//=========================================================================\\n\\n// color contrast enhance stage implemented via histogram stretching\\n// on lightness channel. if the min and max are tweaked it can generate\\n// out-of-range values these will be clamped in 0 to 1\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nuniform sampler2D texGeomColors; // scalars + lighting\\nuniform sampler2D texLIC;        // image lic, mask\\nuniform sampler2D texHSLColors;  // hsla colors\\n\\nuniform float     uLMin;         // min lightness over all fragments\\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\\n\\nin vec2 tcoordVC;\\n\\nvec3 HSLToRGB(vec3 HSL)\\n{\\n  vec3 RGB;\\n  float v;\\n  float h = HSL.x;\\n  float sl = HSL.y;\\n  float l = HSL.z;\\n\\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\\n  if (v <= 0.0) {\\n    RGB = vec3(0.0,0.0,0.0);\\n  } else {\\n    float m;\\n    int sextant;\\n    float fract, vsf, mid1, mid2;\\n\\n    m = l + l - v;\\n    h *= 6.0;\\n    sextant = int(h);\\n    fract = h - float(sextant);\\n\\n    vsf = (v - m) * fract;\\n    mid1 = m + vsf;\\n    mid2 = v - vsf;\\n    switch (sextant) {\\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\\n    }\\n  }\\n  return RGB;\\n}\\n\\nvoid main()\\n{\\n  // lookup hsl color , mask\\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\\n\\n  // don't modify masked fragments (masked => lic.g==1)\\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\\n  if (lic.g==0.0)\\n    {\\n    // normalize lightness channel\\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\\n    }\\n\\n  // back into rgb space\\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\\n\\n  // add alpha\\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\\n  fragColor.a = geomColor.a;\\n\\n  gl_FragData[0] = fragColor;\\n}\\n&quot;),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=ld.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=xs.newInstance({numberOfComponents:3,values:n});a.setName(&quot;points&quot;);const i=xs.newInstance({numberOfComponents:1,values:o}),s=xs.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,&quot;polys&quot;,Pg.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=Ag.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi(&quot;texDepth&quot;,t.depthTexture.getTextureUnit()),r.setUniformi(&quot;texRGBColors&quot;,t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi(&quot;texVectors&quot;,t.vectorImage.getTextureUnit()),o.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get(&quot;colorMode&quot;,&quot;LICIntensity&quot;,&quot;mapModeBias&quot;,&quot;maskIntensity&quot;,&quot;maskColor&quot;,&quot;enhanceContrast&quot;,&quot;lowColorContrastEnhancementFactor&quot;,&quot;highColorContrastEnhancementFactor&quot;);if(o.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),o.setUniformi(&quot;uScalarColorMode&quot;,a),o.setUniformf(&quot;uLICIntensity&quot;,i),o.setUniformf(&quot;uMapBias&quot;,s),o.setUniformf(&quot;uMaskIntensity&quot;,l),o.setUniform3f(&quot;uMaskColor&quot;,...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===yg||u===bg){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi(&quot;texGeomColors&quot;,t.geometryImage.getTextureUnit()),s.setUniformi(&quot;texHSLColors&quot;,t.HSLColorImage.getTextureUnit()),s.setUniformi(&quot;texLIC&quot;,t.LICImage.getTextureUnit()),s.setUniformf(&quot;uLMin&quot;,o),s.setUniformf(&quot;uLMaxMinDiff&quot;,i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get(&quot;stepSize&quot;,&quot;numberOfSteps&quot;,&quot;enhancedLIC&quot;,&quot;enhanceContrast&quot;,&quot;lowLICContrastEnhancementFactor&quot;,&quot;highLICContrastEnhancementFactor&quot;,&quot;antiAlias&quot;,&quot;normalizeVectors&quot;,&quot;maskThreshold&quot;,&quot;transformVectors&quot;),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error(&quot;Failed to compute image LIC&quot;),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var Eg={newInstance:Wt.newInstance(Mg,&quot;vtkSurfaceLICInterface&quot;),extend:Mg};const{vtkErrorMacro:Vg}=Ht,Dg={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const Lg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dg,n),$d.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLSurfaceLICMapper&quot;);const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName(&quot;lastLightComplexity&quot;);let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=td.substitute(s,&quot;//VTK::Output::Dec&quot;,[&quot;//VTK::Output::Dec&quot;,&quot;layout(location = 2) out vec4 vectorTexture;&quot;,&quot;layout(location = 3) out vec4 maskVectorTexture;&quot;]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=td.substitute(i,&quot;//VTK::TCoord::Dec&quot;,[`attribute vec3 ${n};`,&quot;out vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,i=td.substitute(i,&quot;//VTK::TCoord::Impl&quot;,[`licOutput = ${n};`,&quot;//VTK::TCoord::Impl&quot;]).result,s=td.substitute(s,&quot;//VTK::TCoord::Dec&quot;,[&quot;uniform int uMaskOnSurface;&quot;,&quot;uniform mat3 normalMatrix;&quot;,&quot;in vec3 licOutput;&quot;,&quot;//VTK::TCoord::Dec&quot;]).result,s=td.substitute(s,&quot;//VTK::TCoord::Impl&quot;,[&quot;// projected vectors&quot;,&quot;  vec3 tcoordLIC = normalMatrix * licOutput;&quot;,&quot;  vec3 normN = normalize(normalVCVSOutput);&quot;,&quot;  float k = dot(tcoordLIC, normN);&quot;,&quot;  vec3 projected = (tcoordLIC - k*normN);&quot;,&quot;  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;// vectors for fragment masking&quot;,&quot;  if (uMaskOnSurface == 0)&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(licOutput, 1.0);&quot;,&quot;    }&quot;,&quot;  else&quot;,&quot;    {&quot;,&quot;    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);&quot;,&quot;    }&quot;,&quot;//VTK::TCoord::Impl&quot;],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi(&quot;uMaskOnSurface&quot;,t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(Vg(&quot;SurfaceLICMapper Requires WebGL 2&quot;),a=!1),t.context.getExtension(&quot;EXT_color_buffer_float&quot;)&&t.context.getExtension(&quot;OES_texture_float_linear&quot;)||(Vg(&quot;SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions.&quot;),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(Vg(&quot;No input&quot;),a=!1);let i=t.renderable.getLicInterface();i||(i=Og.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=Eg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(Vg(&quot;No vector input array&quot;),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),Ct(e,t,[&quot;openGLLicInterface&quot;])}),&quot;vtkOpenGLSurfaceLICMapper&quot;);Jt(&quot;vtkSurfaceLICMapper&quot;,Lg);const{vtkErrorMacro:Bg}=Ht,Ng={};const Fg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ng,n),$d.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLSphereMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkSphereMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Spheres\\n\\nattribute vec4 vertexMC;\\nattribute vec2 offsetMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\n\\nuniform int cameraParallel;\\nuniform float scaleFactor;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  // compute the projected vertex position\\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\\n\\n  // make the triangle face the camera\\n  if (cameraParallel == 0)\\n    {\\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\\n    vec3 base1 = cross(base2,dir);\\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\\n    }\\n  else\\n    {\\n    // add in the offset\\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\\n    }\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Md,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=td.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=td.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,[&quot;varying vec4 vertexVCVSOutput;&quot;]).result,i=td.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,[&quot;vec4 vertexVC = vertexVCVSOutput;\\n&quot;]).result,i=td.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform float invertedDepth;\\n&quot;,&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=td.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float b = 2.0*dot(EyePos,EyeDir);\\n&quot;,&quot;  float c = dot(EyePos,EyePos) - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t = (-b - invertedDepth*sqrt(d))*0.5;\\n&quot;,&quot;    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\\n&quot;,&quot;    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=td.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=td.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;offsetMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||Bg(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isUniformUsed(&quot;invertedDepth&quot;)&&e.getProgram().setUniformf(&quot;invertedDepth&quot;,t.invert?-1:1),e.getProgram().isUniformUsed(&quot;scaleFactor&quot;)){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf(&quot;scaleFactor&quot;,t.renderable.getScaleFactor()):e.getProgram().setUniformf(&quot;scaleFactor&quot;,1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed(&quot;MCVCMatrix&quot;))if(r.getIsIdentity())p(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&b(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix(&quot;MCVCMatrix&quot;,s);else{const n=t.openGLActor.getKeyMatrices();b(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&b(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix(&quot;MCVCMatrix&quot;,s)}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(zu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(vo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=Wu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,Fu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,Fu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),&quot;vtkOpenGLSphereMapper&quot;);Jt(&quot;vtkSphereMapper&quot;,Fg);const{vtkErrorMacro:_g}=Ht,kg={};const Gg=Mt((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kg,n),$d.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLStickMapper&quot;);const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex=&quot;//VTK::System::Dec\\n\\n/*=========================================================================\\n\\n  Program:   Visualization Toolkit\\n  Module:    vtkStickMapperVS.glsl\\n\\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\\n  All rights reserved.\\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\\n\\n     This software is distributed WITHOUT ANY WARRANTY; without even\\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\\n     PURPOSE.  See the above copyright notice for more information.\\n\\n=========================================================================*/\\n// this shader implements imposters in OpenGL for Sticks\\n\\nattribute vec4 vertexMC;\\nattribute vec3 orientMC;\\nattribute vec4 offsetMC;\\nattribute float radiusMC;\\n\\n// optional normal declaration\\n//VTK::Normal::Dec\\n\\n//VTK::Picking::Dec\\n\\n// Texture coordinates\\n//VTK::TCoord::Dec\\n\\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\\n\\n// material property values\\n//VTK::Color::Dec\\n\\n// clipping plane vars\\n//VTK::Clip::Dec\\n\\n// camera and actor matrix values\\n//VTK::Camera::Dec\\n\\nvarying vec4 vertexVCVSOutput;\\nvarying float radiusVCVSOutput;\\nvarying float lengthVCVSOutput;\\nvarying vec3 centerVCVSOutput;\\nvarying vec3 orientVCVSOutput;\\n\\nuniform int cameraParallel;\\n\\nvoid main()\\n{\\n  //VTK::Picking::Impl\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Clip::Impl\\n\\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\\n  centerVCVSOutput = vertexVCVSOutput.xyz;\\n  radiusVCVSOutput = radiusMC;\\n  lengthVCVSOutput = length(orientMC);\\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\\n\\n  // make sure it is pointing out of the screen\\n  if (orientVCVSOutput.z < 0.0)\\n    {\\n    orientVCVSOutput = -orientVCVSOutput;\\n    }\\n\\n  // make the basis\\n  vec3 xbase;\\n  vec3 ybase;\\n  vec3 dir = vec3(0.0,0.0,1.0);\\n  if (cameraParallel == 0)\\n    {\\n    dir = normalize(-vertexVCVSOutput.xyz);\\n    }\\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\\n    {\\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\\n    ybase = cross(xbase,orientVCVSOutput);\\n    }\\n  else\\n    {\\n    xbase = normalize(cross(orientVCVSOutput,dir));\\n    ybase = cross(orientVCVSOutput,xbase);\\n    }\\n\\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\\n    radiusVCVSOutput*offsets.x*xbase +\\n    radiusVCVSOutput*offsets.y*ybase +\\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\\n\\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\\n}\\n&quot;,e.Fragment=Md,e.Geometry=&quot;&quot;},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=td.substitute(a,&quot;//VTK::Camera::Dec&quot;,[&quot;uniform mat4 VCPCMatrix;\\n&quot;,&quot;uniform mat4 MCVCMatrix;&quot;]).result,i=td.substitute(i,&quot;//VTK::PositionVC::Dec&quot;,&quot;varying vec4 vertexVCVSOutput;&quot;).result,i=td.substitute(i,&quot;//VTK::PositionVC::Impl&quot;,&quot;  vec4 vertexVC = vertexVCVSOutput;\\n&quot;).result,i=td.substitute(i,&quot;//VTK::Normal::Dec&quot;,[&quot;uniform int cameraParallel;\\n&quot;,&quot;varying float radiusVCVSOutput;\\n&quot;,&quot;varying vec3 orientVCVSOutput;\\n&quot;,&quot;varying float lengthVCVSOutput;\\n&quot;,&quot;varying vec3 centerVCVSOutput;\\n&quot;,&quot;uniform mat4 VCPCMatrix;\\n&quot;]).result;let s=&quot;&quot;;t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(s=&quot;  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),t._openGLRenderWindow.getWebgl2()&&(s=&quot;gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\\n&quot;),i=td.substitute(i,&quot;//VTK::Depth::Impl&quot;,[&quot;  vec3 EyePos;\\n&quot;,&quot;  vec3 EyeDir;\\n&quot;,&quot;  if (cameraParallel != 0) {\\n&quot;,&quot;    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\\n&quot;,&quot;    EyeDir = vec3(0.0,0.0,-1.0); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    EyeDir = vertexVC.xyz;\\n&quot;,&quot;    EyePos = vec3(0.0,0.0,0.0);\\n&quot;,&quot;    float lengthED = length(EyeDir);\\n&quot;,&quot;    EyeDir = normalize(EyeDir);\\n&quot;,&quot;    if (lengthED > radiusVCVSOutput*3.0) {\\n&quot;,&quot;      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\\n&quot;,&quot;    }\\n&quot;,&quot;  EyePos = EyePos - centerVCVSOutput;\\n&quot;,&quot;  vec3 base1;\\n&quot;,&quot;  if (abs(orientVCVSOutput.z) < 0.99) {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\\n&quot;,&quot;  else {\\n&quot;,&quot;    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\\n&quot;,&quot;  vec3 base2 = cross(orientVCVSOutput,base1);\\n&quot;,&quot;  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\\n&quot;,&quot;  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\\n&quot;,&quot;  EyePos = EyePos/radiusVCVSOutput;\\n&quot;,&quot;  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\\n&quot;,&quot;  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\\n&quot;,&quot;  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\\n&quot;,&quot;  float d = b*b - 4.0*a*c;\\n&quot;,&quot;  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\\n&quot;,&quot;  if (d < 0.0) { discard; }\\n&quot;,&quot;  else {\\n&quot;,&quot;    float t =  (-b - sqrt(d))/(2.0*a);\\n&quot;,&quot;    float tz = EyePos.z + t*EyeDir.z;\\n&quot;,&quot;    vec3 iPoint = EyePos + t*EyeDir;\\n&quot;,&quot;    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\\n&quot;,&quot;      float t2 = (-b + sqrt(d))/(2.0*a);\\n&quot;,&quot;      float tz2 = EyePos.z + t2*EyeDir.z;\\n&quot;,&quot;      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\\n&quot;,&quot;      else {\\n&quot;,&quot;        normalVCVSOutput = orientVCVSOutput;\\n&quot;,&quot;        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\\n&quot;,&quot;        iPoint = EyePos + t3*EyeDir;\\n&quot;,&quot;        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;        }\\n&quot;,&quot;      }\\n&quot;,&quot;    else {\\n&quot;,&quot;      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\\n&quot;,&quot;      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\\n&quot;,&quot;      }\\n&quot;,&quot;    }\\n&quot;,&quot;  vec4 pos = VCPCMatrix * vertexVC;\\n&quot;,s]).result,i=td.substitute(i,&quot;//VTK::Normal::Impl&quot;,&quot;&quot;).result,t.haveSeenDepthRequest&&(i=td.substitute(i,&quot;//VTK::ZBuffer::Impl&quot;,[&quot;if (depthRequest == 1) {&quot;,&quot;float computedZ = (pos.z / pos.w + 1.0) / 2.0;&quot;,&quot;float iz = floor(computedZ * 65535.0 + 0.1);&quot;,&quot;float rf = floor(iz/256.0)/255.0;&quot;,&quot;float gf = mod(iz,256.0)/255.0;&quot;,&quot;gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }&quot;]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed(&quot;orientMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;orientMC&quot;,12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||_g(&quot;Error setting 'orientMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;offsetMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),&quot;offsetMC&quot;,0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||_g(&quot;Error setting 'offsetMC' in shader VAO.&quot;)),e.getProgram().isAttributeUsed(&quot;radiusMC&quot;)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),&quot;radiusMC&quot;,24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||_g(&quot;Error setting 'radiusMC' in shader VAO.&quot;))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed(&quot;VCPCMatrix&quot;)&&o.setUniformMatrix(&quot;VCPCMatrix&quot;,i.vcpc),r.getIsIdentity())o.isUniformUsed(&quot;MCVCMatrix&quot;)&&o.setUniformMatrix(&quot;MCVCMatrix&quot;,i.wcvc),o.isUniformUsed(&quot;normalMatrix&quot;)&&o.setUniformMatrix3x3(&quot;normalMatrix&quot;,i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed(&quot;MCVCMatrix&quot;)){const t=new Float64Array(16);b(t,i.wcvc,e.mcwc),o.setUniformMatrix(&quot;MCVCMatrix&quot;,t)}if(o.isUniformUsed(&quot;normalMatrix&quot;)){const t=new Float64Array(9);Te(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3(&quot;normalMatrix&quot;,t)}}o.isUniformUsed(&quot;cameraParallel&quot;)&&e.getProgram().setUniformi(&quot;cameraParallel&quot;,a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(zu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():_g([&quot;Error setting orientationArray.\\n&quot;,&quot;You have to specify the stick orientation&quot;]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,Fu.ARRAY_BUFFER),a.getColorBO().upload(g,Fu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),&quot;vtkOpenGLStickMapper&quot;);Jt(&quot;vtkStickMapper&quot;,Gg);const Ug=[];Ug[&quot;-&quot;.charCodeAt(0)]=62,Ug[&quot;_&quot;.charCodeAt(0)]=63;const zg=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;for(let e=0;e<64;e++)Ug[zg.charCodeAt(e)]=e;function Wg(e){return void 0!==Ug[e.charCodeAt(0)]}function Hg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!Wg(e[l]);)l++;for(c=Ug[e.charCodeAt(l++)]<<18;!Wg(e[l]);)l++;for(c|=Ug[e.charCodeAt(l++)]<<12;!Wg(e[l]);)l++;for(c|=Ug[e.charCodeAt(l++)]<<6;!Wg(e[l]);)l++;c|=Ug[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!Wg(e[l]);)l++;for(c=Ug[e.charCodeAt(l++)]<<10;!Wg(e[l]);)l++;for(c|=Ug[e.charCodeAt(l++)]<<4;!Wg(e[l]);)l++;c|=Ug[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!Wg(e[l]);)l++;for(c=Ug[e.charCodeAt(l++)]<<2;!Wg(e[l]);)l++;c|=Ug[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error(&quot;BASE64: remain 1 should not happen&quot;)}return u}function jg(e,t,n){const r=(e<<16)+(t<<8)+n;return zg[r>>18]+zg[r>>12&63]+zg[r>>6&63]+zg[63&r]}function Kg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=jg(t[n],t[n+1],t[n+2])}if(n>0){const e=jg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join(&quot;&quot;)}var $g={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)Wg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):&quot;=&quot;===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=Hg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:Kg};const qg={};function Xg(e,t){qg[e]=t}var Yg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return qg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;http&quot;](e)},has:function(e){return!!qg[e]},registerType:Xg},Zg=Uint8Array,Qg=Uint16Array,Jg=Uint32Array,em=new Zg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),tm=new Zg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),nm=new Zg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),rm=function(e,t){for(var n=new Qg(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Jg(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},om=rm(em,2),am=om[0],im=om[1];am[28]=258,im[258]=28;for(var sm=rm(tm,0),lm=sm[0],cm=(sm[1],new Qg(32768)),um=0;um<32768;++um){var dm=(43690&um)>>>1|(21845&um)<<1;dm=(61680&(dm=(52428&dm)>>>2|(13107&dm)<<2))>>>4|(3855&dm)<<4,cm[um]=((65280&dm)>>>8|(255&dm)<<8)>>>1}var pm=function(e,t,n){for(var r=e.length,o=0,a=new Qg(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Qg(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Qg(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[cm[d]>>>l]=c}else for(i=new Qg(r),o=0;o<r;++o)e[o]&&(i[o]=cm[s[e[o]-1]++]>>>15-e[o]);return i},fm=new Zg(288);for(um=0;um<144;++um)fm[um]=8;for(um=144;um<256;++um)fm[um]=9;for(um=256;um<280;++um)fm[um]=7;for(um=280;um<288;++um)fm[um]=8;var gm=new Zg(32);for(um=0;um<32;++um)gm[um]=5;var mm=pm(fm,9,1),hm=pm(gm,5,1),vm=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},Tm=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},ym=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},bm=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Qg:4==e.BYTES_PER_ELEMENT?Jg:Zg)(n-t);return r.set(e.subarray(t,n)),r},xm=[&quot;unexpected EOF&quot;,&quot;invalid block type&quot;,&quot;invalid length/literal&quot;,&quot;invalid distance&quot;,&quot;stream finished&quot;,&quot;no stream handler&quot;,,&quot;no callback&quot;,&quot;invalid UTF-8 data&quot;,&quot;extra field too long&quot;,&quot;date not in range 1980-2099&quot;,&quot;filename too long&quot;,&quot;stream finishing&quot;,&quot;invalid zip data&quot;],Cm=function(e,t,n){var r=new Error(t||xm[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,Cm),!n)throw r;return r},Sm=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new Zg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new Zg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new Zg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=Tm(e,c,1);var h=Tm(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&Cm(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=mm,p=hm,f=9,g=5;else if(2==h){var y=Tm(e,c,31)+257,b=Tm(e,c+10,15)+4,x=y+Tm(e,c+5,31)+1;c+=14;for(var C=new Zg(x),S=new Zg(19),A=0;A<b;++A)S[nm[A]]=Tm(e,c+3*A,7);c+=3*b;var I=vm(S),w=(1<<I)-1,O=pm(S,I,1);for(A=0;A<x;){var P,R=O[Tm(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+Tm(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+Tm(e,c,7),c+=3):18==P&&(E=11+Tm(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=vm(V),g=vm(D),d=pm(V,f,1),p=pm(D,g,1)}else Cm(1);if(c>m){a&&Cm(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[ym(e,c)&L])>>>4;if((c+=15&M)>m){a&&Cm(0);break}if(M||Cm(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var k=em[A=F-257];_=Tm(e,c,(1<<k)-1)+am[A],c+=k}var G=p[ym(e,c)&B],U=G>>>4;if(G||Cm(3),c+=15&G,D=lm[U],U>3&&(k=tm[U],D+=ym(e,c)&(1<<k)-1,c+=k),c>m){a&&Cm(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:bm(t,0,u)},Am=new Zg(0),Im=function(e,t){return e[t]|e[t+1]<<8},wm=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Om=function(e,t){return wm(e,t)+4294967296*wm(e,t+4)};function Pm(e,t){return Sm(e,t)}function Rm(e,t){return Sm(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||Cm(6,&quot;invalid gzip data&quot;);var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new Zg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function Mm(e,t){return Sm(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&Cm(6,&quot;invalid zlib data&quot;),32&n[1]&&Cm(6,&quot;invalid zlib data: preset dictionaries not supported&quot;),e.subarray(2,-4)),t);var n}function Em(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Rm(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Pm(e,t):Mm(e,t)}var Vm=&quot;undefined&quot;!=typeof TextEncoder&&new TextEncoder,Dm=&quot;undefined&quot;!=typeof TextDecoder&&new TextDecoder;try{Dm.decode(Am,{stream:!0})}catch(e){}function Lm(e,t){if(t){for(var n=&quot;&quot;,r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(Dm)return Dm.decode(e);var o=function(e){for(var t=&quot;&quot;,n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,bm(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&Cm(8),a}var Bm=function(e,t){return t+30+Im(e,t+26)+Im(e,t+28)},Nm=function(e,t,n){var r=Im(e,t+28),o=Lm(e.subarray(t+46,t+46+r),!(2048&Im(e,t+8))),a=t+46+r,i=wm(e,t+20),s=n&&4294967295==i?Fm(e,a):[i,wm(e,t+24),wm(e,t+42)],l=s[0],c=s[1],u=s[2];return[Im(e,t+10),l,c,o,a+Im(e,t+30)+Im(e,t+32),u]},Fm=function(e,t){for(;1!=Im(e,t);t+=4+Im(e,t+2));return[Om(e,t+12),Om(e,t+4),Om(e,t+20)]};function _m(e,t){for(var n={},r=e.length-22;101010256!=wm(e,r);--r)(!r||e.length-r>65558)&&Cm(13);var o=Im(e,r+8);if(!o)return{};var a=wm(e,r+16),i=4294967295==a;i&&(r=wm(e,r-12),101075792!=wm(e,r)&&Cm(13),o=wm(e,r+32),a=wm(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=Nm(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=Bm(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Pm(e.subarray(h,h+d),new Zg(p)):Cm(14,&quot;unknown compression type &quot;+u):n[f]=bm(e,h,h+d))}return n}function km(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?&quot;LittleEndian&quot;:2712847316===n[0]?&quot;BigEndian&quot;:null}&quot;function&quot;==typeof queueMicrotask?queueMicrotask:&quot;function&quot;==typeof setTimeout&&setTimeout;var Gm=km(),Um=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:zm,vtkDebugMacro:Wm}=Wt;let Hm=0;function jm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener(&quot;progress&quot;,n.progressCallback),r}const Km={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;);const s=jm(&quot;GET&quot;,i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++Hm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=Lm(Em(new Uint8Array(n.buffer))):n.buffer=Em(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Gm!==n.ref.encode&&Gm&&(Wm(`Swap bytes of ${n.name}`),Um(n.buffer,ls[n.dataType])),n.values=Wt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&zm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--Hm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||&quot;string&quot;!==n.dataType?&quot;arraybuffer&quot;:&quot;text&quot;,s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=jm(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(Lm(Em(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&&quot;gz&quot;!==n.compression&&(zm(&quot;Supported algorithms are: [gz]&quot;),zm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=jm(&quot;GET&quot;,t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++Hm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--Hm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(Lm(Em(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?&quot;arraybuffer&quot;:&quot;text&quot;,a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&&quot;gz&quot;!==t.compression&&(zm(&quot;Supported algorithms are: [gz]&quot;),zm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=jm(&quot;GET&quot;,e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(Em(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType=&quot;arraybuffer&quot;,o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};Xg(&quot;http&quot;,(e=>Km));const{vtkDebugMacro:$m}=Wt,qm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,modelTransformMatrix:null,cameraLightTransform:u(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function Xm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qm,n),Wt.obj(e,t),Wt.get(e,t,[&quot;distance&quot;]),Wt.setGet(e,t,[&quot;parallelProjection&quot;,&quot;useHorizontalViewAngle&quot;,&quot;viewAngle&quot;,&quot;parallelScale&quot;,&quot;useOffAxisProjection&quot;,&quot;freezeFocalPoint&quot;,&quot;physicalScale&quot;]),Wt.getArray(e,t,[&quot;directionOfProjection&quot;,&quot;viewPlaneNormal&quot;,&quot;position&quot;,&quot;focalPoint&quot;]),Wt.setGetArray(e,t,[&quot;clippingRange&quot;,&quot;windowCenter&quot;],2),Wt.setGetArray(e,t,[&quot;viewUp&quot;,&quot;screenBottomLeft&quot;,&quot;screenBottomRight&quot;,&quot;screenTopRight&quot;,&quot;physicalTranslation&quot;,&quot;physicalViewUp&quot;,&quot;physicalViewNorth&quot;],3),function(e,t){t.classHierarchy.push(&quot;vtkCamera&quot;);const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=m(new Float64Array(16)),i=m(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=m(new Float64Array(16)),d=m(new Float64Array(16)),f=new Float64Array(3),g=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,$m(&quot;Distance is set to minimum.&quot;));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,$m(&quot;Distance is set to minimum.&quot;);const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);m(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);S(u,u,vo(n),s),La(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;m(d),x(d,d,r),S(d,d,vo(n),t.viewUp),x(d,d,[-r[0],-r[1],-r[2]]),In(f,t.position,d),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;m(d),x(d,d,r),S(d,d,vo(n),t.viewUp),x(d,d,[-r[0],-r[1],-r[2]]),In(g,t.focalPoint,d),e.setFocalPoint(g[0],g[1],g[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];m(d),x(d,d,r),S(d,d,vo(n),a),x(d,d,[-r[0],-r[1],-r[2]]),In(f,t.position,d),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];m(d),x(d,d,r),S(d,d,vo(n),a),x(d,d,[-r[0],-r[1],-r[2]]),In(g,t.focalPoint,d),e.setFocalPoint(...g)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Ro(t.position,a,t.position),Ro(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],La(o,[...t.position,1],n),La(a,[...t.focalPoint,1],n),La(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,$m(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,$m(&quot;Thickness is set to minimum.&quot;)),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Float64Array(24);const r=[[1,0,0,1],[-1,0,0,1],[0,1,0,1],[0,-1,0,1],[0,0,1,1],[0,0,-1,1]],o=e.getCompositeProjectionMatrix(t,-1,1);for(let e=0;e<6;e++)La(r[e],r[e],o),_o(r[e]),n[4*e+0]=r[e][0],n[4*e+1]=r[e][1],n[4*e+2]=r[e][2],n[4*e+3]=r[e][3];return n},e.getCameraLightTransformMatrix=e=>(p(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{p(a,e.getViewMatrix()),v(a,a),P(i,[t.distance,t.distance,t.distance]),b(a,a,i),m(t.cameraLightTransform),x(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=_a(e[0],e[1],e[2],e[3]),n=Ba(),r=_a(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],Fa(r,t,r),Fa(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),v(t,t)},e.getWorldToPhysicalMatrix=e=>{m(e);const n=[3];Bo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],h(e,e),hn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),C(e,e,s),x(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{v(a,i),In(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),In(l,r,a),Tn(l,l,s),Cn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),In(c,o,a),Tn(c,c,s),Cn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),b(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setModelTransformMatrix=e=>{t.modelTransformMatrix=e},e.getModelTransformMatrix=()=>t.modelTransformMatrix,e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(p(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),h(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.modelTransformMatrix?(b(a,t.viewMatrix,t.modelTransformMatrix),a):t.viewMatrix;X(a,t.position,t.focalPoint,t.viewUp),h(a,a);const e=new Float64Array(16);return t.modelTransformMatrix?b(e,a,t.modelTransformMatrix):p(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(m(o),t.projectionMatrix){const e=1/t.physicalScale;return hn(s,e,e,e),p(o,t.projectionMatrix),C(o,o,s),h(o,o),o}m(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;$(a,o,i,s,c,l[0],l[1]),h(a,a)}else{if(t.useOffAxisProjection)throw new Error(&quot;Off-Axis projection is not supported at this time&quot;);{const n=Math.tan(vo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return p(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return b(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Bo(t.physicalViewNorth,t.physicalViewUp,i);const s=m(new Float64Array(16));S(s,s,vo(n),t.physicalViewUp),S(s,s,vo(r),i),S(s,s,vo(o),t.physicalViewNorth),S(s,s,vo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);In(l,l,s),In(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=m(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=vo(t),i=Ba();Na(i,[n,r,o],e),G(a,i)}const i=new Float64Array(3);In(i,[0,0,-1],a);const s=new Float64Array(3);In(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var Ym={newInstance:Wt.newInstance(Xm,&quot;vtkCamera&quot;),extend:Xm};const Zm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:&quot;SceneLight&quot;,shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Qm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Zm,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;intensity&quot;,&quot;switch&quot;,&quot;positional&quot;,&quot;exponent&quot;,&quot;coneAngle&quot;,&quot;coneFalloff&quot;,&quot;transformMatrix&quot;,&quot;lightType&quot;,&quot;shadowAttenuation&quot;,&quot;attenuationValues&quot;]),Wt.setGetArray(e,t,[&quot;color&quot;,&quot;position&quot;,&quot;focalPoint&quot;,&quot;attenuationValues&quot;],3),function(e,t){t.classHierarchy.push(&quot;vtkLight&quot;);const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?In(n,t.position,t.transformMatrix):hn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?In(n,t.focalPoint,t.transformMatrix):hn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Rn(t.direction,t.focalPoint,t.position),Fo(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Rn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=vo(t),o=vo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType(&quot;HeadLight&quot;)},e.setLightTypeToCameraLight=()=>{e.setLightType(&quot;CameraLight&quot;)},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType(&quot;SceneLight&quot;)},e.lightTypeIsHeadLight=()=>&quot;HeadLight&quot;===t.lightType,e.lightTypeIsSceneLight=()=>&quot;SceneLight&quot;===t.lightType,e.lightTypeIsCameraLight=()=>&quot;CameraLight&quot;===t.lightType}(e,t)}var Jm={newInstance:Wt.newInstance(Qm,&quot;vtkLight&quot;),extend:Qm,LIGHT_TYPES:[&quot;HeadLight&quot;,&quot;CameraLight&quot;,&quot;SceneLight&quot;]};const{vtkErrorMacro:eh}=Wt;const th={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function nh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,th,n),Wt.obj(e,t),Wt.event(e,t,&quot;event&quot;),Wt.setGetArray(e,t,[&quot;viewport&quot;],4),Wt.setGetArray(e,t,[&quot;background&quot;,&quot;background2&quot;],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push(&quot;vtkViewport&quot;),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>eh(&quot;call displayToView on your view instead&quot;),e.viewToDisplay=()=>eh(&quot;callviewtodisplay on your view instead&quot;),e.getSize=()=>eh(&quot;call getSize on your View instead&quot;),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>eh(&quot;vtkViewport::PickPropFrom - NOT IMPLEMENTED&quot;)}(e,t)}var rh={newInstance:Wt.newInstance(nh,&quot;vtkViewport&quot;),extend:nh};const{vtkDebugMacro:oh,vtkErrorMacro:ah,vtkWarningMacro:ih}=Ht;function sh(e){return()=>ah(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const lh={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Pa(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function ch(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,lh,n),rh.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),Tt(e,t,[&quot;_renderWindow&quot;,&quot;allocatedRenderTime&quot;,&quot;timeFactor&quot;,&quot;lastRenderTimeInSeconds&quot;,&quot;numberOfPropsRendered&quot;,&quot;lastRenderingUsedDepthPeeling&quot;,&quot;selector&quot;]),Ct(e,t,[&quot;twoSidedLighting&quot;,&quot;lightFollowCamera&quot;,&quot;automaticLightCreation&quot;,&quot;erase&quot;,&quot;draw&quot;,&quot;nearClippingPlaneTolerance&quot;,&quot;clippingRangeExpansion&quot;,&quot;backingStore&quot;,&quot;interactive&quot;,&quot;layer&quot;,&quot;preserveColorBuffer&quot;,&quot;preserveDepthBuffer&quot;,&quot;useDepthPeeling&quot;,&quot;occlusionRatio&quot;,&quot;maximumNumberOfPeels&quot;,&quot;delegate&quot;,&quot;backgroundTexture&quot;,&quot;texturedBackground&quot;,&quot;environmentTexture&quot;,&quot;environmentTextureDiffuseStrength&quot;,&quot;environmentTextureSpecularStrength&quot;,&quot;useEnvironmentTextureAsBackground&quot;,&quot;useShadows&quot;,&quot;pass&quot;]),St(e,t,[&quot;actors&quot;,&quot;volumes&quot;,&quot;lights&quot;]),It(e,t,[&quot;background&quot;],4,1),wt(0,t,[&quot;renderWindow&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkRenderer&quot;);const n={type:&quot;ComputeVisiblePropBoundsEvent&quot;,renderer:e},r={type:&quot;ResetCameraClippingRangeEvent&quot;,renderer:e},o={type:&quot;ResetCameraEvent&quot;,renderer:e};e.updateCamera=()=>(t.activeCamera||(oh(&quot;No cameras are on, creating one.&quot;),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(u())):ah(&quot;light has unknown light type&quot;,e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=sh(&quot;allocateTime&quot;),e.updateGeometry=sh(&quot;updateGeometry&quot;),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{oh(e.getClassName(),e,&quot;setting Layer to &quot;,n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:&quot;ActiveCameraEvent&quot;,camera:n}),!0),e.makeCamera=()=>{const t=Ym.newInstance();return e.invokeEvent({type:&quot;CreateCameraEvent&quot;,camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Jm.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return ah(&quot;ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();v(o,o),h(o,o);const a=new Float64Array([e,n,r]);return In(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return ah(&quot;ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);v(a,a),h(a,a);const i=new Float64Array([e,n,r]);return In(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return ah(&quot;WorldToView: no active camera, cannot compute view to world, returning 0,0,0&quot;),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o);const a=new Float64Array([e,n,r]);return In(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return ah(&quot;ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0&quot;),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a);const i=new Float64Array([e,n,r]);return In(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Gi.INIT_BOUNDS[0],t.allBounds[1]=Gi.INIT_BOUNDS[1],t.allBounds[2]=Gi.INIT_BOUNDS[2],t.allBounds[3]=Gi.INIT_BOUNDS[3],t.allBounds[4]=Gi.INIT_BOUNDS[4],t.allBounds[5]=Gi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ya(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(Ta(t.allBounds),oh(&quot;Can't compute bounds, no 3D props are visible&quot;)),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ya(n))return oh(&quot;Cannot reset camera!&quot;),!1;let a=null;if(!e.getActiveCamera())return ah(&quot;Trying to reset non-existent camera&quot;),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=vo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(Lo(f,a))>.999&&(ih(&quot;Resetting view-up since view plane normal is parallel&quot;),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ya(n))return oh(&quot;Cannot reset camera clipping range!&quot;),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return ah(&quot;Trying to reset clipping range of non-existent camera&quot;),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=vo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var uh={newInstance:Mt(ch,&quot;vtkRenderer&quot;),extend:ch};const dh=Object.create(null);function ph(e,t){dh[e]=t}function fh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return dh[e]&&dh[e](t)}const gh={defaultViewAPI:&quot;WebGL&quot;,renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function mh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gh,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;interactor&quot;,&quot;numberOfLayers&quot;,&quot;_views&quot;,&quot;defaultViewAPI&quot;]),Wt.get(e,t,[&quot;neverRendered&quot;]),Wt.getArray(e,t,[&quot;renderers&quot;,&quot;childRenderWindows&quot;]),Wt.moveToProtected(e,t,[&quot;views&quot;]),Wt.event(e,t,&quot;completion&quot;),function(e,t){t.classHierarchy.push(&quot;vtkRenderWindow&quot;),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return fh(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join(&quot;\\n&quot;),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Wt.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var hh={newInstance:Wt.newInstance(mh,&quot;vtkRenderWindow&quot;),extend:mh,registerViewConstructor:ph,listViewAPIs:function(){return Object.keys(dh)},newAPISpecificView:fh};const vh={Unknown:0,LeftController:1,RightController:2},Th={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var yh={Device:vh,Input:Th,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:bh,Input:xh}=yh,{vtkWarningMacro:Ch,vtkErrorMacro:Sh,normalizeWheel:Ah,vtkOnceErrorMacro:Ih}=Wt,wh={ctrlKey:!1,altKey:!1,shiftKey:!1},Oh={&quot;xr-standard&quot;:[xh.Trigger,xh.Grip,xh.TrackPad,xh.Thumbstick,xh.A,xh.B]},Ph=[&quot;StartAnimation&quot;,&quot;Animation&quot;,&quot;EndAnimation&quot;,&quot;PointerEnter&quot;,&quot;PointerLeave&quot;,&quot;MouseEnter&quot;,&quot;MouseLeave&quot;,&quot;StartMouseMove&quot;,&quot;MouseMove&quot;,&quot;EndMouseMove&quot;,&quot;LeftButtonPress&quot;,&quot;LeftButtonRelease&quot;,&quot;MiddleButtonPress&quot;,&quot;MiddleButtonRelease&quot;,&quot;RightButtonPress&quot;,&quot;RightButtonRelease&quot;,&quot;KeyPress&quot;,&quot;KeyDown&quot;,&quot;KeyUp&quot;,&quot;StartMouseWheel&quot;,&quot;MouseWheel&quot;,&quot;EndMouseWheel&quot;,&quot;StartPinch&quot;,&quot;Pinch&quot;,&quot;EndPinch&quot;,&quot;StartPan&quot;,&quot;Pan&quot;,&quot;EndPan&quot;,&quot;StartRotate&quot;,&quot;Rotate&quot;,&quot;EndRotate&quot;,&quot;Button3D&quot;,&quot;Move3D&quot;,&quot;StartPointerLock&quot;,&quot;EndPointerLock&quot;,&quot;StartInteraction&quot;,&quot;Interaction&quot;,&quot;EndInteraction&quot;,&quot;AnimationFrameRateUpdate&quot;];function Rh(e){e.cancelable&&e.preventDefault()}function Mh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const Eh={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:&quot;Start&quot;,animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function Vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eh,n),Wt.obj(e,t),t._animationExtendedEnd=0,Wt.event(e,t,&quot;RenderEvent&quot;),Ph.forEach((n=>Wt.event(e,t,n))),Wt.get(e,t,[&quot;initialized&quot;,&quot;interactorStyle&quot;,&quot;lastFrameTime&quot;,&quot;recentAnimationFrameRate&quot;,&quot;_view&quot;]),Wt.setGet(e,t,[&quot;container&quot;,&quot;lightFollowCamera&quot;,&quot;enabled&quot;,&quot;enableRender&quot;,&quot;recognizeGestures&quot;,&quot;desiredUpdateRate&quot;,&quot;stillUpdateRate&quot;,&quot;picker&quot;,&quot;preventDefaultOnPointerDown&quot;,&quot;preventDefaultOnPointerUp&quot;,&quot;mouseScrollDebounceByPass&quot;]),Wt.moveToProtected(e,t,[&quot;view&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkRenderWindowInteractor&quot;);const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{Sh(&quot;you want to call setView(view) instead of setRenderWindow on a vtk.js interactor&quot;)},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Ch(&quot;empty event loop&quot;),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||&quot;&quot;}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener(&quot;contextmenu&quot;,Rh),n.addEventListener(&quot;wheel&quot;,e.handleWheel),n.addEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.addEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.addEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.addEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.addEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.addEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.addEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),n.addEventListener(&quot;keypress&quot;,e.handleKeyPress),n.addEventListener(&quot;keydown&quot;,e.handleKeyDown),document.addEventListener(&quot;keyup&quot;,e.handleKeyUp),document.addEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction=&quot;none&quot;,n.style.userSelect=&quot;none&quot;,n.style.webkitTapHighlightColor=&quot;rgba(0,0,0,0)&quot;};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener(&quot;contextmenu&quot;,Rh),n.removeEventListener(&quot;wheel&quot;,e.handleWheel),n.removeEventListener(&quot;DOMMouseScroll&quot;,e.handleWheel),n.removeEventListener(&quot;pointerenter&quot;,e.handlePointerEnter),n.removeEventListener(&quot;pointerleave&quot;,e.handlePointerLeave),n.removeEventListener(&quot;pointermove&quot;,e.handlePointerMove,{passive:!1}),n.removeEventListener(&quot;pointerdown&quot;,e.handlePointerDown,{passive:!1}),n.removeEventListener(&quot;pointerup&quot;,e.handlePointerUp),n.removeEventListener(&quot;pointercancel&quot;,e.handlePointerCancel),n.removeEventListener(&quot;keypress&quot;,e.handleKeyPress),n.removeEventListener(&quot;keydown&quot;,e.handleKeyDown)),document.removeEventListener(&quot;keyup&quot;,e.handleKeyUp),document.removeEventListener(&quot;pointerlockchange&quot;,e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),&quot;mouse&quot;===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Rh(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Ch(&quot;[RenderWindowInteractor] duplicate pointerId detected&quot;),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Rh(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case&quot;pen&quot;:case&quot;touch&quot;:e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:Sh(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Ch(&quot;requester is already registered for animating&quot;):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):Sh(&quot;undefined requester, can not start animating&quot;)},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Ch(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:&quot;left&quot;===n.handedness?bh.LeftController:bh.RightController,input:Oh[s.mapping]&&Oh[s.mapping][r]?Oh[s.mapping][r]:xh.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:&quot;left&quot;===n.handedness?bh.LeftController:bh.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Rh(n);const r={...Ah(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:Sh(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Mh(o);if(2===r.length){const t={...l(wh),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture(&quot;TouchStart&quot;,t)}else if(1===r.length){const t={...l(wh),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=Mh(o);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===r.length){const t={...l(wh),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(wh),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=Mh(o);e.recognizeGesture(&quot;TouchEnd&quot;,t);const a={...l(wh),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=Mh(o);e.recognizeGesture(&quot;TouchMove&quot;,t)}else if(1===r.length){const t={...l(wh),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Ph.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Ih(&quot;\\n          Can not forward events without a current renderer on the interactor.\\n        &quot;);const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),&quot;TouchStart&quot;===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture=&quot;Start&quot;);if(&quot;TouchEnd&quot;===n)return&quot;Pinch&quot;===t.currentGesture&&(e.render(),e.endPinchEvent()),&quot;Rotate&quot;===t.currentGesture&&(e.render(),e.endRotateEvent()),&quot;Pan&quot;===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture=&quot;Start&quot;,void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=To(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=To(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,&quot;TouchMove&quot;===n)if(&quot;Start&quot;===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture=&quot;Pinch&quot;;const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture=&quot;Rotate&quot;;const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture=&quot;Pan&quot;;const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if(&quot;Rotate&quot;===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if(&quot;Pinch&quot;===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if(&quot;Pan&quot;===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener(&quot;visibilitychange&quot;,e.handleVisibilityChange,!1)}(e,t)}var Dh={newInstance:Wt.newInstance(Vh,&quot;vtkRenderWindowInteractor&quot;),extend:Vh,handledEvents:Ph,...yh};const{vtkErrorMacro:Lh,VOID:Bh}=Wt,Nh={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function Fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nh,n),Wt.obj(e,t),Wt.event(e,t,&quot;InteractionEvent&quot;),Wt.event(e,t,&quot;StartInteractionEvent&quot;),Wt.event(e,t,&quot;EndInteractionEvent&quot;),Wt.get(e,t,[&quot;_interactor&quot;,&quot;enabled&quot;]),Wt.setGet(e,t,[&quot;priority&quot;,&quot;processEvents&quot;]),Wt.moveToProtected(e,t,[&quot;interactor&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkInteractorObserver&quot;);const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){Dh.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):Bh),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():Lh(&quot;\\n          The interactor must be set before subscribing to events\\n        &quot;)),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var _h={newInstance:Wt.newInstance(Fh,&quot;vtkInteractorObserver&quot;),extend:Fh,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},kh={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:Gh}=kh,Uh={Rotate:Gh.IS_ROTATE,Pan:Gh.IS_PAN,Spin:Gh.IS_SPIN,Dolly:Gh.IS_DOLLY,CameraPose:Gh.IS_CAMERA_POSE,WindowLevel:Gh.IS_WINDOW_LEVEL,Slice:Gh.IS_SLICE},zh={state:Gh.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function Wh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zh,n),_h.extend(e,t,n),Wt.setGet(e,t,[&quot;focusedRenderer&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkInteractorStyle&quot;),Object.keys(Uh).forEach((n=>{Wt.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===Gh.IS_NONE&&(t.state=Uh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:&quot;StartInteractionEvent&quot;}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Wt.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===Uh[n]&&(t.state=Gh.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:&quot;EndInteractionEvent&quot;}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case&quot;r&quot;:case&quot;R&quot;:t.getRenderer(e).resetCamera(),n.render();break;case&quot;w&quot;:case&quot;W&quot;:r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case&quot;s&quot;:case&quot;S&quot;:r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case&quot;v&quot;:case&quot;V&quot;:r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var Hh={newInstance:Wt.newInstance(Wh,&quot;vtkInteractorStyle&quot;),extend:Wh,...kh};const{States:jh}=kh,Kh={motionFactor:10,zoomFactor:10};function $h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kh,n),Hh.extend(e,t,n),Wt.setGet(e,t,[&quot;motionFactor&quot;,&quot;zoomFactor&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkInteractorStyleTrackballCamera&quot;),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case jh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case jh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case jh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;});break;case jh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:&quot;InteractionEvent&quot;})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==vh.RightController||n.input!==Th.Trigger&&n.input!==Th.TrackPad?!n||n.pressed||n.device!==vh.RightController||n.input!==Th.Trigger&&n.input!==Th.TrackPad||t.state!==jh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===jh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case jh.IS_DOLLY:e.endDolly();break;case jh.IS_PAN:e.endPan();break;case jh.IS_SPIN:e.endSpin();break;case jh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=To(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=To(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var qh={newInstance:Wt.newInstance($h,&quot;vtkInteractorStyleTrackballCamera&quot;),extend:$h};function Xh(e){return e}function Yh(e){return null===e||&quot;null&quot;===e?null:&quot;true&quot;===e||&quot;false&quot;!==e&&(void 0!==e&&&quot;undefined&quot;!==e?&quot;[&quot;===e[0]&&&quot;]&quot;===e[e.length-1]?e.substring(1,e.length-1).split(&quot;,&quot;).map((e=>Yh(e.trim()))):&quot;&quot;===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var Zh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?Yh:Xh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Qh={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Jh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qh,n),Wt.obj(e,t),Wt.get(e,t,[&quot;currentOperation&quot;]),Wt.setGet(e,t,[&quot;delegates&quot;,&quot;_currentParent&quot;,&quot;preDelegateOperations&quot;,&quot;postDelegateOperations&quot;]),Wt.moveToProtected(e,t,[&quot;currentParent&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkRenderPass&quot;),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Wt.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var ev={newInstance:Wt.newInstance(Jh,&quot;vtkRenderPass&quot;),extend:Jh};const{Representation:tv}=os,{vtkErrorMacro:nv}=Wt;function rv(e){const t=td.substitute(e.Fragment,&quot;//VTK::RenderPassFragmentShader::Impl&quot;,&quot;\\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\\n      gl_FragData[1].r = weight;\\n    &quot;,!1);e.Fragment=t.result}const ov={framebuffer:null,copyShader:null,tris:null};function av(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),ev.extend(e,t,n),t.VBOBuildTime={},Wt.obj(t.VBOBuildTime,{mtime:0}),t.tris=ld.newInstance(),Wt.get(e,t,[&quot;framebuffer&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=xs.newInstance({numberOfComponents:3,values:e});o.setName(&quot;points&quot;);const a=xs.newInstance({numberOfComponents:2,values:n});a.setName(&quot;tcoords&quot;);const i=xs.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,&quot;polys&quot;,tv.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=Sp.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=Pd.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:&quot;Float32Array&quot;,data:null}),t.translucentRTexture=Pd.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:&quot;Float32Array&quot;,data:null}),t.translucentZTexture=Pd.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:&quot;Float32Array&quot;,data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray([&quot;//VTK::System::Dec&quot;,&quot;attribute vec4 vertexDC;&quot;,&quot;attribute vec2 tcoordTC;&quot;,&quot;varying vec2 tcoord;&quot;,&quot;void main() { tcoord = tcoordTC; gl_Position = vertexDC; }&quot;].join(&quot;\\n&quot;),&quot;//VTK::System::Dec\\n\\nin vec2 tcoord;\\n\\nuniform sampler2D translucentRTexture;\\nuniform sampler2D translucentRGBATexture;\\n\\n// the output of this shader\\n//VTK::Output::Dec\\n\\nvoid main()\\n{\\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\\n  float t2Color = texture(translucentRTexture, tcoord).r;\\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\\n}\\n&quot;,&quot;&quot;)},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;vertexDC&quot;,t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||nv(&quot;Error setting vertexDC in copy shader VAO.&quot;),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),&quot;tcoordTC&quot;,t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||nv(&quot;Error setting vertexDC in copy shader VAO.&quot;)},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension(&quot;EXT_color_buffer_half_float&quot;)&&!i.getExtension(&quot;EXT_color_buffer_float&quot;))return e.setCurrentOperation(&quot;translucentPass&quot;),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation(&quot;opaqueZBufferPass&quot;),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation(&quot;translucentPass&quot;),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=od.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi(&quot;translucentRGBATexture&quot;,t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi(&quot;translucentRTexture&quot;,t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?rv:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var iv={newInstance:Wt.newInstance(av,&quot;vtkOpenGLOrderIndependentTranslucentPass&quot;),extend:av};const sv={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sv,n),ev.extend(e,t,n),Wt.get(e,t,[&quot;framebuffer&quot;,&quot;opaqueActorCount&quot;,&quot;translucentActorCount&quot;,&quot;volumeCount&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation(&quot;queryPass&quot;),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=Sp.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation(&quot;zBufferPass&quot;),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation(&quot;cameraPass&quot;),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation(&quot;opaquePass&quot;),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=iv.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation(&quot;volumePass&quot;),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation(&quot;overlayPass&quot;),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var cv={newInstance:Wt.newInstance(lv,&quot;vtkForwardPass&quot;),extend:lv},uv=n(292);const dv=[&quot;lastShaderProgramBound&quot;,&quot;context&quot;,&quot;_openGLRenderWindow&quot;],pv={lastShaderProgramBound:null,shaderPrograms:null,context:null};function fv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pv,n),t.shaderPrograms={},Wt.obj(e,t),Wt.setGet(e,t,dv),Wt.moveToProtected(e,t,[&quot;openGLRenderWindow&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkShaderCache&quot;),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=td.substitute(o,&quot;VSOut&quot;,&quot;GSOut&quot;).result);const a=t._openGLRenderWindow.getWebgl2();let i=&quot;\\n&quot;,s=&quot;#version 100\\n&quot;;a?s=&quot;#version 300 es\\n#define attribute in\\n#define textureCube texture\\n#define texture2D texture\\n#define textureCubeLod textureLod\\n#define texture2DLod textureLod\\n&quot;:(t.context.getExtension(&quot;OES_standard_derivatives&quot;),t.context.getExtension(&quot;EXT_frag_depth&quot;)&&(i=&quot;#extension GL_EXT_frag_depth : enable\\n&quot;),t.context.getExtension(&quot;EXT_shader_texture_lod&quot;)&&(i+=&quot;#extension GL_EXT_shader_texture_lod : enable\\n#define textureCubeLod textureCubeLodEXT\\n#define texture2DLod texture2DLodEXT&quot;)),o=td.substitute(o,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,a?&quot;&quot;:&quot;#extension GL_OES_standard_derivatives : enable\\n&quot;,i,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;let l=td.substitute(e,&quot;//VTK::System::Dec&quot;,[`${s}\\n`,&quot;#ifdef GL_FRAGMENT_PRECISION_HIGH&quot;,&quot;precision highp float;&quot;,&quot;precision highp int;&quot;,&quot;#else&quot;,&quot;precision mediump float;&quot;,&quot;precision mediump int;&quot;,&quot;#endif&quot;]).result;if(a){l=td.substitute(l,&quot;varying&quot;,&quot;out&quot;).result,o=td.substitute(o,&quot;varying&quot;,&quot;in&quot;).result;let e=&quot;&quot;,t=0;for(;o.includes(`gl_FragData[${t}]`);)o=td.substitute(o,`gl_FragData\\\\[${t}\\\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\\n`,t++;o=td.substitute(o,&quot;//VTK::Output::Dec&quot;,e).result}return{VSSource:l,FSSource:o,GSSource:td.substitute(r,&quot;//VTK::System::Dec&quot;,s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=uv.hash(o);if(!(a in t.shaderPrograms)){const o=td.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var gv={newInstance:Wt.newInstance(fv,&quot;vtkShaderCache&quot;),extend:fv};const{vtkErrorMacro:mv}=Wt,hv={context:null,numberOfTextureUnits:0,textureUnits:0};function vv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hv,n),Wt.obj(e,t),t.textureUnits=[],Wt.get(e,t,[&quot;numberOfTextureUnits&quot;]),Wt.setGet(e,t,[&quot;context&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkOpenGLTextureUnitManager&quot;),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&mv(&quot;some texture units  were not properly released&quot;);t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var Tv={newInstance:Wt.newInstance(vv,&quot;vtkOpenGLTextureUnitManager&quot;),extend:vv};const yv={size:void 0,selector:void 0};function bv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,yv,n),t.size||(t.size=[300,300]),Wt.getArray(e,t,[&quot;size&quot;],2),Wt.get(e,t,[&quot;selector&quot;]),qt.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkRenderWindowViewNode&quot;),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Wt.vtkErrorMacro(&quot;not implemented&quot;)},e.getPixelData=(e,t,n,r)=>{Wt.vtkErrorMacro(&quot;not implemented&quot;)},e.createSelector=()=>{Wt.vtkErrorMacro(&quot;not implemented&quot;)}}(e,t)}var xv={newInstance:Wt.newInstance(bv,&quot;vtkRenderWindowViewNode&quot;),extend:bv};const{vtkDebugMacro:Cv,vtkErrorMacro:Sv}=Wt,Av={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;},Iv=[&quot;activateTexture&quot;,&quot;deactivateTexture&quot;,&quot;disableCullFace&quot;,&quot;enableCullFace&quot;,&quot;get3DContext&quot;,&quot;getActiveFramebuffer&quot;,&quot;getContext&quot;,&quot;getDefaultTextureByteSize&quot;,&quot;getDefaultTextureInternalFormat&quot;,&quot;getDefaultToWebgl2&quot;,&quot;getGLInformations&quot;,&quot;getGraphicsMemoryInfo&quot;,&quot;getGraphicsResourceForObject&quot;,&quot;getHardwareMaximumLineWidth&quot;,&quot;getPixelData&quot;,&quot;getShaderCache&quot;,&quot;getTextureUnitForTexture&quot;,&quot;getTextureUnitManager&quot;,&quot;getWebgl2&quot;,&quot;makeCurrent&quot;,&quot;releaseGraphicsResources&quot;,&quot;registerGraphicsResourceUser&quot;,&quot;unregisterGraphicsResourceUser&quot;,&quot;restoreContext&quot;,&quot;setActiveFramebuffer&quot;,&quot;setContext&quot;,&quot;setDefaultToWebgl2&quot;,&quot;setGraphicsResourceForObject&quot;];function wv(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let Ov=0;const Pv=[];function Rv(e){e.preventDefault()}function Mv(e,t){let n;t.classHierarchy.push(&quot;vtkOpenGLRenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener(&quot;webglcontextlost&quot;,Rv,!1),t.canvas.addEventListener(&quot;webglcontextrestored&quot;,e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType(&quot;vtkOpenGLRenderWindow&quot;),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(Ov++,Pv.forEach((e=>e(Ov)))),t.textureUnitManager=Tv.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Sv(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:&quot;high-performance&quot;},r=null;const o=&quot;undefined&quot;!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext(&quot;webgl2&quot;,e),r&&(t.webgl2=!0,Cv(&quot;using webgl2&quot;))),r||(Cv(&quot;using webgl1&quot;),r=t.canvas.getContext(&quot;webgl&quot;,e)||t.canvas.getContext(&quot;experimental-webgl&quot;,e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if(&quot;__getUnderlyingContext&quot;===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext(&quot;2d&quot;,e)},e.restoreContext=()=>{const t=ev.newInstance();t.setCurrentOperation(&quot;Release&quot;),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?Sv(&quot;Hardware does not support the number of textures defined.&quot;):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case cs.CHAR:case cs.SIGNED_CHAR:case cs.UNSIGNED_CHAR:return 1;case n:case r:case cs.UNSIGNED_SHORT:case cs.SHORT:case cs.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case cs.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&cs.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&cs.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=Av,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension(&quot;OES_texture_float&quot;),o=n.getExtension(&quot;OES_texture_half_float&quot;),a=n.getExtension(&quot;WEBGL_debug_renderer_info&quot;),i=n.getExtension(&quot;WEBGL_draw_buffers&quot;),s=n.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||n.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;),l=[[&quot;Max Vertex Attributes&quot;,&quot;MAX_VERTEX_ATTRIBS&quot;,n.getParameter(n.MAX_VERTEX_ATTRIBS)],[&quot;Max Varying Vectors&quot;,&quot;MAX_VARYING_VECTORS&quot;,n.getParameter(n.MAX_VARYING_VECTORS)],[&quot;Max Vertex Uniform Vectors&quot;,&quot;MAX_VERTEX_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],[&quot;Max Fragment Uniform Vectors&quot;,&quot;MAX_FRAGMENT_UNIFORM_VECTORS&quot;,n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],[&quot;Max Fragment Texture Image Units&quot;,&quot;MAX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],[&quot;Max Vertex Texture Image Units&quot;,&quot;MAX_VERTEX_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],[&quot;Max Combined Texture Image Units&quot;,&quot;MAX_COMBINED_TEXTURE_IMAGE_UNITS&quot;,n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],[&quot;Max 2D Texture Size&quot;,&quot;MAX_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_TEXTURE_SIZE)],[&quot;Max Cube Texture Size&quot;,&quot;MAX_CUBE_MAP_TEXTURE_SIZE&quot;,n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],[&quot;Max Texture Anisotropy&quot;,&quot;MAX_TEXTURE_MAX_ANISOTROPY_EXT&quot;,s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],[&quot;Point Size Range&quot;,&quot;ALIASED_POINT_SIZE_RANGE&quot;,n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(&quot; - &quot;)],[&quot;Line Width Range&quot;,&quot;ALIASED_LINE_WIDTH_RANGE&quot;,n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(&quot; - &quot;)],[&quot;Max Viewport Dimensions&quot;,&quot;MAX_VIEWPORT_DIMS&quot;,n.getParameter(n.MAX_VIEWPORT_DIMS).join(&quot; - &quot;)],[&quot;Max Renderbuffer Size&quot;,&quot;MAX_RENDERBUFFER_SIZE&quot;,n.getParameter(n.MAX_RENDERBUFFER_SIZE)],[&quot;Framebuffer Red Bits&quot;,&quot;RED_BITS&quot;,n.getParameter(n.RED_BITS)],[&quot;Framebuffer Green Bits&quot;,&quot;GREEN_BITS&quot;,n.getParameter(n.GREEN_BITS)],[&quot;Framebuffer Blue Bits&quot;,&quot;BLUE_BITS&quot;,n.getParameter(n.BLUE_BITS)],[&quot;Framebuffer Alpha Bits&quot;,&quot;ALPHA_BITS&quot;,n.getParameter(n.ALPHA_BITS)],[&quot;Framebuffer Depth Bits&quot;,&quot;DEPTH_BITS&quot;,n.getParameter(n.DEPTH_BITS)],[&quot;Framebuffer Stencil Bits&quot;,&quot;STENCIL_BITS&quot;,n.getParameter(n.STENCIL_BITS)],[&quot;Framebuffer Subpixel Bits&quot;,&quot;SUBPIXEL_BITS&quot;,n.getParameter(n.SUBPIXEL_BITS)],[&quot;MSAA Samples&quot;,&quot;SAMPLES&quot;,n.getParameter(n.SAMPLES)],[&quot;MSAA Sample Buffers&quot;,&quot;SAMPLE_BUFFERS&quot;,n.getParameter(n.SAMPLE_BUFFERS)],[&quot;Supported Formats for UByte Render Targets     &quot;,&quot;UNSIGNED_BYTE RENDER TARGET FORMATS&quot;,[r&&wv(n,n.RGBA,n.UNSIGNED_BYTE)?&quot;RGBA&quot;:&quot;&quot;,r&&wv(n,n.RGB,n.UNSIGNED_BYTE)?&quot;RGB&quot;:&quot;&quot;,r&&wv(n,n.LUMINANCE,n.UNSIGNED_BYTE)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&wv(n,n.ALPHA,n.UNSIGNED_BYTE)?&quot;ALPHA&quot;:&quot;&quot;,r&&wv(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Half Float Render Targets&quot;,&quot;HALF FLOAT RENDER TARGET FORMATS&quot;,[o&&wv(n,n.RGBA,o.HALF_FLOAT_OES)?&quot;RGBA&quot;:&quot;&quot;,o&&wv(n,n.RGB,o.HALF_FLOAT_OES)?&quot;RGB&quot;:&quot;&quot;,o&&wv(n,n.LUMINANCE,o.HALF_FLOAT_OES)?&quot;LUMINANCE&quot;:&quot;&quot;,o&&wv(n,n.ALPHA,o.HALF_FLOAT_OES)?&quot;ALPHA&quot;:&quot;&quot;,o&&wv(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Supported Formats for Full Float Render Targets&quot;,&quot;FLOAT RENDER TARGET FORMATS&quot;,[r&&wv(n,n.RGBA,n.FLOAT)?&quot;RGBA&quot;:&quot;&quot;,r&&wv(n,n.RGB,n.FLOAT)?&quot;RGB&quot;:&quot;&quot;,r&&wv(n,n.LUMINANCE,n.FLOAT)?&quot;LUMINANCE&quot;:&quot;&quot;,r&&wv(n,n.ALPHA,n.FLOAT)?&quot;ALPHA&quot;:&quot;&quot;,r&&wv(n,n.LUMINANCE_ALPHA,n.FLOAT)?&quot;LUMINANCE_ALPHA&quot;:&quot;&quot;].join(&quot; &quot;)],[&quot;Max Multiple Render Targets Buffers&quot;,&quot;MAX_DRAW_BUFFERS_WEBGL&quot;,i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],[&quot;High Float Precision in Vertex Shader&quot;,&quot;HIGH_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Vertex Shader&quot;,&quot;MEDIUM_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Vertex Shader&quot;,&quot;LOW_FLOAT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Float Precision in Fragment Shader&quot;,&quot;HIGH_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Float Precision in Fragment Shader&quot;,&quot;MEDIUM_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Float Precision in Fragment Shader&quot;,&quot;LOW_FLOAT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Vertex Shader&quot;,&quot;HIGH_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Vertex Shader&quot;,&quot;MEDIUM_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Vertex Shader&quot;,&quot;LOW_INT VERTEX_SHADER&quot;,[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;High Int Precision in Fragment Shader&quot;,&quot;HIGH_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Medium Int Precision in Fragment Shader&quot;,&quot;MEDIUM_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Low Int Precision in Fragment Shader&quot;,&quot;LOW_INT FRAGMENT_SHADER&quot;,[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision,&quot; (-2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,&quot;</sup> - 2<sup>&quot;,n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,&quot;</sup>)&quot;].join(&quot;&quot;)],[&quot;Supported Extensions&quot;,&quot;EXTENSIONS&quot;,n.getSupportedExtensions().join(&quot;<br/>\\t\\t\\t\\t\\t    &quot;)],[&quot;WebGL Renderer&quot;,&quot;RENDERER&quot;,n.getParameter(n.RENDERER)],[&quot;WebGL Vendor&quot;,&quot;VENDOR&quot;,n.getParameter(n.VENDOR)],[&quot;WebGL Version&quot;,&quot;VERSION&quot;,n.getParameter(n.VERSION)],[&quot;Shading Language Version&quot;,&quot;SHADING_LANGUAGE_VERSION&quot;,n.getParameter(n.SHADING_LANGUAGE_VERSION)],[&quot;Unmasked Renderer&quot;,&quot;UNMASKED_RENDERER&quot;,a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],[&quot;Unmasked Vendor&quot;,&quot;UNMASKED_VENDOR&quot;,a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],[&quot;WebGL Version&quot;,&quot;WEBGL_VERSION&quot;,t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=Gp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Wt.chain((()=>{t.context&&(Ov--,Pv.forEach((e=>e(Ov)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener(&quot;webglcontextlost&quot;,Rv),t.canvas.removeEventListener(&quot;webglcontextrestored&quot;,e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Iv.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const Ev={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1};const Vv=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ev,n),xv.extend(e,t,n),t.canvas||(t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;),t.selector||(t.selector=Gp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=nn.newInstance(),t.shaderCache=gv.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=cv.newInstance(),Wt.get(e,t,[&quot;shaderCache&quot;,&quot;textureUnitManager&quot;,&quot;webgl2&quot;,&quot;useBackgroundImage&quot;,&quot;activeFramebuffer&quot;,&quot;rootOpenGLRenderWindow&quot;]),Wt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;context2D&quot;,&quot;canvas&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;defaultToWebgl2&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),Wt.setGetArray(e,t,[&quot;size&quot;],2),Wt.event(e,t,&quot;imageReady&quot;),Wt.event(e,t,&quot;windowResizeEvent&quot;),Mv(e,t)}),&quot;vtkOpenGLRenderWindow&quot;);ph(&quot;WebGL&quot;,Vv),Jt(&quot;vtkRenderWindow&quot;,Vv);const Dv={device:null,handle:null};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dv,n),Wt.obj(e,t),Wt.get(e,t,[&quot;lastCameraMTime&quot;]),Wt.setGet(e,t,[&quot;device&quot;,&quot;handle&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderModule&quot;),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var Bv={newInstance:Wt.newInstance(Lv,&quot;vtkWebGPUShaderModule&quot;),extend:Lv};const Nv={shaderModules:null,device:null,window:null};function Fv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Nv,n),t._shaderModules=new Map,Wt.obj(e,t),Wt.setGet(e,t,[&quot;device&quot;,&quot;window&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderCache&quot;),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=Bv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var _v={newInstance:Wt.newInstance(Fv,&quot;vtkWebGPUShaderCache&quot;),extend:Fv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join(&quot;\\n&quot;):n;let a=!1;-1!==e.search(t)&&(a=!0);let i=&quot;&quot;;r&&(i=&quot;g&quot;);const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const kv={device:null,handle:null,label:null};function Gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Wt.obj(e,t),t.bindables=[],t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),Wt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),Wt.setGet(e,t,[&quot;label&quot;,&quot;device&quot;,&quot;arrayInformation&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUBindGroup&quot;),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join(&quot;\\n&quot;)}}(e,t)}var Uv={newInstance:Wt.newInstance(Gv),extend:Gv};const zv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function Wv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zv,n),ht(e,t),t.layouts=[],t.shaderDescriptions=[],Tt(e,t,[&quot;handle&quot;,&quot;pipelineDescription&quot;]),Ct(e,t,[&quot;device&quot;,&quot;renderEncoder&quot;,&quot;topology&quot;,&quot;vertexState&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUPipeline&quot;),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);&quot;vertex&quot;===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint=&quot;main&quot;),&quot;fragment&quot;===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint=&quot;main&quot;)}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var Hv={newInstance:Mt(Wv,&quot;vtkWebGPUPipeline&quot;),extend:Wv};const jv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function Kv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Wt.obj(e,t),Wt.setGet(e,t,[&quot;type&quot;,&quot;hash&quot;,&quot;code&quot;]),Wt.getArray(e,t,[&quot;outputTypes&quot;,&quot;outputNames&quot;,&quot;outputInterpolations&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUShaderDescription&quot;),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push(&quot;};&quot;),o=n,r[r.length-1]+=&quot;,&quot;,r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=_v.substitute(t.code,&quot;//VTK::IOStructs::Input&quot;,r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push(&quot;};&quot;),o=o.concat(e),t.code=_v.substitute(t.code,&quot;//VTK::IOStructs::Output&quot;,[`-> ${t.type}Output`]).result}t.code=_v.substitute(t.code,&quot;//VTK::IOStructs::Dec&quot;,o).result}}(e,t)}var $v={newInstance:Wt.newInstance(Kv,&quot;vtkWebGPUShaderDescription&quot;),extend:Kv};const qv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;float&quot;},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:&quot;sint&quot;},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;uint&quot;},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:&quot;sint&quot;},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:&quot;float&quot;},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;float&quot;},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:&quot;uint&quot;},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:&quot;sint&quot;},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:&quot;uint&quot;},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:&quot;sint&quot;},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:&quot;uint&quot;},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:&quot;sint&quot;},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:&quot;float&quot;},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;rgba8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;uint&quot;},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:&quot;sint&quot;},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},&quot;bgra8unorm-srgb&quot;:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:&quot;float&quot;},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:&quot;float&quot;},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:&quot;float&quot;},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:&quot;uint&quot;},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:&quot;sint&quot;},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:&quot;unfilterable-float&quot;},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:&quot;uint&quot;},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:&quot;sint&quot;},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:&quot;float&quot;},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:&quot;uint&quot;},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:&quot;sint&quot;},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:&quot;unfilterable-float&quot;},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:&quot;uint&quot;},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:&quot;depth&quot;},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:&quot;depth&quot;},&quot;depth24plus-stencil8&quot;:{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:&quot;mixed&quot;},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:&quot;depth&quot;}};var Xv=function(e){return!e||e.length<6?0:e in qv==1?qv[e]:(et(`unknown format ${e}`),null)},Yv=function(e){if(!e||e.length<5)return 0;let t=1;&quot;x&quot;===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(et(`unknown format ${e}`),0):t*(5-r/2)},Zv=function(e){if(!e||e.length<5)return 0;let t;if(&quot;f&quot;===e[0])t=&quot;Float&quot;;else if(&quot;s&quot;===e[0])t=&quot;Int&quot;;else{if(&quot;u&quot;!==e[0])return void et(`unknown format ${e}`);t=&quot;Uint&quot;}const n=e.split(&quot;x&quot;)[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+=&quot;Array&quot;,t;et(`unknown format ${e}`)},Qv=function(e){let t;if(&quot;f&quot;===e[0]||&quot;n&quot;===e[1])t=&quot;f32&quot;;else if(&quot;s&quot;===e[0]&&&quot;i&quot;===e[1])t=&quot;i32&quot;;else{if(&quot;u&quot;!==e[0]||&quot;i&quot;!==e[1])return void et(`unknown format ${e}`);t=&quot;u32&quot;}let n=1;return&quot;x&quot;===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},Jv=function(e){if(!e)return 0;let t=1;return&quot;vec&quot;===e.substring(0,3)?t=Number(e[3]):&quot;mat&quot;===e.substring(0,3)&&(t=e[3]*e[5]),4*t},eT=function(e){if(e)return e.includes(&quot;f32&quot;)?&quot;Float32Array&quot;:e.includes(&quot;i32&quot;)?&quot;Int32Array&quot;:e.includes(&quot;u32&quot;)?&quot;Uint32Array&quot;:void et(`unknown format ${e}`)};function tT(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const nT={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function rT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nT,n),ht(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],Ct(e,t,[&quot;created&quot;,&quot;device&quot;,&quot;handle&quot;,&quot;indexBuffer&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUVertexInput&quot;),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:&quot;vertex&quot;,o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(tT(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e=&quot;&quot;,n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Qv(a.format);n>0&&(e+=&quot;,\\n&quot;),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var oT={newInstance:Mt(rT,&quot;vtkWebGPUVertexInput&quot;),extend:rT};const aT={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:&quot;triangle-list&quot;,UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function iT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,aT,n),qt.extend(e,t,n),t.textureViews=[],t.vertexInput=oT.newInstance(),t.bindGroup=Uv.newInstance({label:&quot;mapperBG&quot;}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::Light::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;,t.vertexShaderTemplate=t.vertexShaderTemplate||&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Color::Dec\\n\\n//VTK::Normal::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@vertex\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : vertexOutput;\\n\\n  // var vertex: vec4<f32> = vertexBC;\\n\\n  //VTK::Color::Impl\\n\\n  //VTK::Normal::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::Position::Impl\\n\\n  return output;\\n}\\n&quot;,t.shaderReplacements=new Map,Wt.get(e,t,[&quot;pipeline&quot;,&quot;vertexInput&quot;]),Wt.setGet(e,t,[&quot;additionalBindables&quot;,&quot;device&quot;,&quot;fragmentShaderTemplate&quot;,&quot;interpolate&quot;,&quot;numberOfInstances&quot;,&quot;numberOfVertices&quot;,&quot;pipelineHash&quot;,&quot;shaderReplacements&quot;,&quot;SSBO&quot;,&quot;textureViews&quot;,&quot;topology&quot;,&quot;UBO&quot;,&quot;vertexShaderTemplate&quot;,&quot;WebGPURenderer&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUSimpleMapper&quot;),e.generateShaderDescriptions=(n,r,o)=>{const a=$v.newInstance({type:&quot;vertex&quot;,hash:n,code:t.vertexShaderTemplate}),i=$v.newInstance({type:&quot;fragment&quot;,hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp(&quot;//VTK::[^:]*::&quot;,&quot;g&quot;),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];&quot;replaceShaderIOStructs&quot;!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.replaceShaderCode(null,n),t.getShaderDescription(&quot;fragment&quot;).replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set(&quot;replaceShaderRenderEncoder&quot;,e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=_v.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);i=s.getCode(),i=_v.substitute(i,&quot;//VTK::Renderer::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderRenderer&quot;,e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription(&quot;vertex&quot;);let i=a.getCode();i=_v.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,a.setCode(i);const s=n.getShaderDescription(&quot;fragment&quot;);s.addBuiltinInput(&quot;bool&quot;,&quot;@builtin(front_facing) frontFacing&quot;),i=s.getCode(),i=_v.substitute(i,&quot;//VTK::Mapper::Dec&quot;,[o]).result,s.setCode(i)},t.shaderReplacements.set(&quot;replaceShaderMapper&quot;,e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=_v.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;    output.Position = rendererUBO.SCPCMatrix*vertexBC;&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription(&quot;vertex&quot;).addOutput(&quot;vec2<f32>&quot;,&quot;tcoordVS&quot;)},t.shaderReplacements.set(&quot;replaceShaderTCoord&quot;,e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=Hv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var sT={newInstance:Wt.newInstance(iT,&quot;vtkWebGPUSimpleMapper&quot;),extend:iT};const lT={};function cT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lT,n),sT.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUFullScreenQuad&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;),r.addOutput(&quot;vec4<f32>&quot;,&quot;vertexVC&quot;);let o=r.getCode();o=_v.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;,&quot;output.vertexVC = vec4<f32>(vertexBC, 1);&quot;]).result,r.setCode(o)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,[&quot;vertexBC&quot;]),t.numberOfVertices=6}}(e,t)}var uT={newInstance:Wt.newInstance(cT,&quot;vtkWebGPUFullScreenQuad&quot;),extend:cT};const dT=[&quot;setBindGroup&quot;,&quot;setIndexBuffer&quot;,&quot;setVertexBuffer&quot;,&quot;draw&quot;,&quot;drawIndexed&quot;],pT={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function fT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pT,n),ht(e,t),t.description={colorAttachments:[{view:void 0,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}],depthStencilAttachment:{view:void 0,depthLoadOp:&quot;clear&quot;,depthClearValue:0,depthStoreOp:&quot;store&quot;}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=_v.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = computedColor;&quot;]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater-equal&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}},t.colorTextureViews=[],Tt(e,t,[&quot;boundPipeline&quot;,&quot;colorTextureViews&quot;]),Ct(e,t,[&quot;depthTextureView&quot;,&quot;description&quot;,&quot;handle&quot;,&quot;label&quot;,&quot;pipelineHash&quot;,&quot;pipelineSettings&quot;,&quot;replaceShaderCodeFunction&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderEncoder&quot;),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!(&quot;depthStencil&quot;in n))console.log(&quot;mismatched depth attachments&quot;),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\\n${o}\\n versus pipeline\\n${a}\\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<dT.length;n++)e[dT[n]]=function(){return t.handle[dT[n]](...arguments)}}(e,t)}var gT={newInstance:Mt(fT,&quot;vtkWebGPURenderEncoder&quot;),extend:fT};const mT={device:null,handle:null,label:null,options:null};function hT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mT,n),Wt.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),Wt.get(e,t,[&quot;bindGroupTime&quot;,&quot;handle&quot;,&quot;options&quot;]),Wt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUSampler&quot;),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:&quot;clamp-to-edge&quot;,t.options.addressModeV=n.addressModeV?n.addressModeV:&quot;clamp-to-edge&quot;,t.options.addressModeW=n.addressModeW?n.addressModeW:&quot;clamp-to-edge&quot;,t.options.magFilter=n.magFilter?n.magFilter:&quot;nearest&quot;,t.options.minFilter=n.minFilter?n.minFilter:&quot;nearest&quot;,t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:&quot;nearest&quot;,t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var vT={newInstance:Wt.newInstance(hT),extend:hT};const TT={texture:null,handle:null,sampler:null,label:null};function yT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TT,n),Wt.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:&quot;float&quot;,viewDimension:&quot;2d&quot;}},t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),Wt.get(e,t,[&quot;bindGroupTime&quot;,&quot;texture&quot;]),Wt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;sampler&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUTextureView&quot;),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Xv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||&quot;2d&quot;,t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=Xv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r=&quot;f32&quot;;&quot;sint&quot;===t.bindGroupLayoutEntry.texture.sampleType?r=&quot;i32&quot;:&quot;uint&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(r=&quot;u32&quot;);let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return&quot;depth&quot;===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=vT.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var bT={newInstance:Wt.newInstance(yT),extend:yT};const xT={device:null,handle:null,buffer:null,ready:!1,label:null};function CT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xT,n),Wt.obj(e,t),Wt.get(e,t,[&quot;handle&quot;,&quot;ready&quot;,&quot;width&quot;,&quot;height&quot;,&quot;depth&quot;,&quot;format&quot;,&quot;usage&quot;]),Wt.setGet(e,t,[&quot;device&quot;,&quot;label&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUTexture&quot;),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?&quot;2d&quot;:&quot;3d&quot;;t.format=n.format?n.format:&quot;rgba8unorm&quot;,t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:&quot;rgba8unorm&quot;,t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&vu.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format=&quot;rgba8unorm&quot;,n.flip=!0,void o(n.image);const a=Xv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&&quot;float&quot;===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Wt.newTypedArray(r?&quot;Uint16Array&quot;:e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=gd.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&vu.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=Xv(t.format);return 2===e.elementSize&&&quot;float&quot;===e.sampleType?1:255},e.getNumberOfComponents=()=>Xv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?&quot;2d&quot;:&quot;3d&quot;);const o=bT.newInstance({label:n});return o.create(e,r),o}}(e,t)}var ST={newInstance:Wt.newInstance(CT),extend:CT};const AT={renderEncoder:null,colorTexture:null,depthTexture:null};function IT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,AT,n),ev.extend(e,t,n),Wt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUOpaquePass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=ST.newInstance({label:&quot;opaquePassColor&quot;}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView(&quot;opaquePassColorTexture&quot;);t.renderEncoder.setColorTextureView(0,n),t.depthFormat=&quot;depth32float&quot;,t.depthTexture=ST.newInstance({label:&quot;opaquePassDepth&quot;}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;opaquePassDepthTexture&quot;);t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;opaquePass&quot;),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=gT.newInstance({label:&quot;OpaquePass&quot;}),t.renderEncoder.setPipelineHash(&quot;op&quot;)}}(e,t)}var wT={newInstance:Wt.newInstance(IT,&quot;vtkWebGPUOpaquePass&quot;),extend:IT};const OT={colorTextureView:null,depthTextureView:null};function PT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,OT,n),ev.extend(e,t,n),Wt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=ST.newInstance({label:&quot;translucentPassColor&quot;}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;rgba16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView(&quot;oitpColorTexture&quot;);t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=ST.newInstance({label:&quot;translucentPassAccumulate&quot;}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView(&quot;oitpAccumTexture&quot;);t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=uT.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash(&quot;oitpfsq&quot;),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\\n  if (reveal == 1.0) { discard; }\\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\\n  var total: f32 = max(tcolor.a, 0.01);\\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;)}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation(&quot;translucentPass&quot;),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=gT.newInstance({label:&quot;translucentRender&quot;});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:void 0,clearValue:[1,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}],e.depthStencilAttachment={view:void 0,depthLoadOp:&quot;load&quot;,depthStoreOp:&quot;store&quot;},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addOutput(&quot;f32&quot;,&quot;outAccum&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=_v.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);&quot;,&quot;output.outColor = vec4<f32>(computedColor.rgb*w, w);&quot;,&quot;output.outAccum = computedColor.a;&quot;]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash(&quot;oitpr&quot;),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!1,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;zero&quot;,dstFactor:&quot;one-minus-src&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=gT.newInstance({label:&quot;translucentFinal&quot;}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;),t.addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;);let n=t.getCode();n=_v.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash(&quot;oitpf&quot;),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})}}(e,t)}var RT={newInstance:Wt.newInstance(PT,&quot;vtkWebGPUOrderIndependentTranslucentPass&quot;),extend:PT},MT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const ET=[&quot;getMappedRange&quot;,&quot;mapAsync&quot;,&quot;unmap&quot;];const VT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,VT,n),Wt.obj(e,t),Wt.get(e,t,[&quot;handle&quot;,&quot;sizeInBytes&quot;,&quot;usage&quot;]),Wt.setGet(e,t,[&quot;strideInBytes&quot;,&quot;device&quot;,&quot;arrayInformation&quot;,&quot;label&quot;,&quot;sourceTime&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUBuffer&quot;),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<ET.length;n++)e[ET[n]]=function(){return t.handle[ET[n]](...arguments)}}(e,t)}var LT={newInstance:Wt.newInstance(DT),extend:DT,...MT};const{Representation:BT}=os,{PrimitiveTypes:NT}=MT;class FT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function _T(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function kT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=_T(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=_T(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=_T(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=_T(n,o,t),n.ibo[n.iboId++]=a}function GT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let UT;const zT=new Uint32Array(1),WT=new Uint32Array(2),HT=new Uint32Array(3),jT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)zT[0]=t[n+a],UT(zT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)WT[0]=t[n+a],WT[1]=t[n+a+1],UT(WT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)WT[0]=t[n+a],WT[1]=t[n+(a+1)%e],UT(WT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)WT[0]=t[n+a],WT[1]=t[n+a+1],UT(WT,r,o);for(let a=0;a<e-2;a++)WT[0]=t[n+a],WT[1]=t[n+a+2],UT(WT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)HT[0]=t[n],HT[1]=t[n+a+1],HT[2]=t[n+a+2],UT(HT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)HT[0]=t[n+a],HT[1]=t[n+a+1+a%2],HT[2]=t[n+a+1+(a+1)%2],UT(HT,r,o)}};const KT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function $T(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,KT,n),LT.extend(e,t,n),Wt.setGet(e,t,[&quot;flatIdToPointId&quot;,&quot;flatIdToCellId&quot;,&quot;flatSize&quot;,&quot;indexCount&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUIndexBuffer&quot;),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case NT.Points:return&quot;points&quot;;case NT.Lines:return&quot;lines&quot;;case NT.Triangles:case NT.TriangleEdges:return&quot;polys&quot;;case NT.TriangleStripEdges:case NT.TriangleStrips:return&quot;strips&quot;;default:return&quot;&quot;}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new FT};let d=null;d=o===BT.POINTS||r===NT.Points?jT.anythingToPoints:o===BT.WIREFRAME||r===NT.Lines?jT[`${l}ToWireframe`]:jT[`${l}ToSurface`],UT=GT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format=&quot;uint16&quot;):(u.ibo=new Uint32Array(u.iboSize),e.format=&quot;uint32&quot;),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),UT=kT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var qT={newInstance:Wt.newInstance($T),extend:$T,...MT};const{BufferUsage:XT}=MT,{vtkErrorMacro:YT}=Ht,{VtkDataTypes:ZT}=xs;function QT(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,&quot;packExtra&quot;)&&o.packExtra;let u,d=0;const p=at(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function JT(e,t,n,r){const o=[];return Bo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),Fo(o),o}const ey={device:null,fullScreenQuadBuffer:null};function ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ey,n),ht(e,t),Ct(e,t,[&quot;device&quot;]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===XT.Index&&(n=qT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=LT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===XT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===XT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===XT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===XT.PointArray){r=GPUBufferUsage.VERTEX;const t=Zv(e.format),o=QT(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(Yv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?&quot;flat&quot;:&quot;perspective&quot;}])}if(e.usage===XT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Zv(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=JT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=QT(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(Yv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:&quot;flat&quot;}])}return e.usage===XT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(Yv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push(&quot;vtkWebGPUBufferManager&quot;),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case ZT.UNSIGNED_CHAR:t=&quot;uint8&quot;;break;case ZT.FLOAT:t=&quot;float32&quot;;break;case ZT.UNSIGNED_INT:t=&quot;uint32&quot;;break;case ZT.INT:t=&quot;sint32&quot;;break;case ZT.DOUBLE:t=&quot;float32&quot;;break;case ZT.UNSIGNED_SHORT:t=&quot;uint16&quot;;break;case ZT.SHORT:t=&quot;sin16&quot;;break;default:t=&quot;float32&quot;}switch(e.getNumberOfComponents()){case 2:t+=&quot;x2&quot;;break;case 3:t.includes(&quot;32&quot;)||YT(`unsupported x3 type for ${t}`),t+=&quot;x3&quot;;break;case 4:t+=&quot;x4&quot;}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:XT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=LT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:&quot;float32x3&quot;}]),t.fullScreenQuadBuffer}}(e,t)}var ny={newInstance:Mt(ty),extend:ty,...MT};const{BufferUsage:ry}=ny,{vtkErrorMacro:oy}=Wt,ay={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function iy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ay,n),Wt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;uniform&quot;}},t.sendTime={},Wt.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Wt.get(e,t,[&quot;binding&quot;,&quot;bindGroupTime&quot;]),Wt.setGet(e,t,[&quot;bindGroupLayoutEntry&quot;,&quot;device&quot;,&quot;label&quot;,&quot;sizeInBytes&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUUniformBuffer&quot;),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?oy(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:Jv(n),offset:-1,nativeType:eT(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:ry.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Wt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void oy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void oy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join(&quot;\\n&quot;)}}(e,t)}var sy={newInstance:Wt.newInstance(iy,&quot;vtkWebGPUUniformBuffer&quot;),extend:iy};const{BufferUsage:ly}=ny,{vtkErrorMacro:cy}=Wt,uy={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function dy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uy,n),Wt.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Wt.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Wt.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:&quot;read-only-storage&quot;}},Wt.get(e,t,[&quot;bindGroupTime&quot;]),Wt.setGet(e,t,[&quot;device&quot;,&quot;bindGroupLayoutEntry&quot;,&quot;label&quot;,&quot;numberOfInstances&quot;,&quot;sizeInBytes&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUStorageBuffer&quot;),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void cy(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=Jv(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:eT(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:ly.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Wt.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void cy(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void cy(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void cy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void cy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void cy(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\\n};\\nstruct ${t.label}Struct\\n{\\n  values: array<${t.label}StructEntry>,\\n};\\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\\n`),r.join(&quot;\\n&quot;)},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var py={newInstance:Wt.newInstance(dy,&quot;vtkWebGPUStorageBuffer&quot;),extend:dy};const fy=new Float64Array(16),gy=new Float64Array(16),my={volumes:null,rowLength:1024,lastVolumeLength:0};function hy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,my,n),uT.extend(e,t,n),t.fragmentShaderTemplate=&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::Volume::TraverseDec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\\n{\\n  // todo multicomponent support\\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\\n}\\n\\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\\n{\\n  var result: vec4<f32>;\\n\\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\\n  result.w = 0.0;\\n\\n  // divide by spacing as that is our delta\\n  result = result / volumeSSBO.values[vNum].spacing;\\n  // now we have a gradient in unit tcoords\\n\\n  var grad: f32 = length(result.xyz);\\n  if (grad > 0.0)\\n  {\\n    // rotate to View Coords, needed for lighting and shading\\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\\n    result = nMat * result;\\n    result = result / length(result);\\n  }\\n\\n  // store gradient magnitude in .w\\n  result.w = grad;\\n\\n  return result;\\n}\\n\\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\\n{\\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n\\n  // convert to tcoords and reject if outside the volume\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\\n\\n  var scalar: f32 = getTextureValue(vTex, tpos);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n\\n  var gofactor: f32 = 1.0;\\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    normal = getGradient(vTex, tpos, vNum, scalar);\\n    if (componentSSBO.values[cNum].gomin <  1.0)\\n    {\\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\\n    }\\n  }\\n\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n\\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\\n  {\\n    color = color*abs(normal.z);\\n  }\\n\\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\\n\\n  return outColor;\\n}\\n\\n// adjust the start and end point of a raycast such that it intersects the unit cube.\\n// This function is used to take a raycast starting point and step vector\\n// and numSteps and return the startijng and ending steps for intersecting the\\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\\n// and bound it to intersecting the texture.\\n//\\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\\n{\\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\\n\\n  // move tpos to the start of the volume\\n  var adjust: f32 =\\n    min(\\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\\n      min(\\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\\n  if (adjust < 0.0)\\n  {\\n    result.x = result.x - adjust;\\n  }\\n\\n  // adjust length to the end\\n  adjust =\\n    max(\\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\\n      max(\\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\\n  if (adjust > 0.0)\\n  {\\n    result.y = result.y - adjust;\\n  }\\n\\n  return result;\\n}\\n\\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\\n{\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var coord: vec2<f32> =\\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\\n  return vec4<f32>(color.rgb, opacity);\\n}\\n\\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var maxVal: f32 = -1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar > maxVal)\\n    {\\n      maxVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\\n}\\n\\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var minVal: f32 = 1.0e37;\\n  loop\\n  {\\n    var scalar: f32 = getTextureValue(vTex, tpos);\\n    if (scalar < minVal)\\n    {\\n      minVal = scalar;\\n    }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\\n}\\n\\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var avgVal: f32 = 0.0;\\n  var sampleCount: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      avgVal = avgVal + sample;\\n      sampleCount = sampleCount + 1.0;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  if (sampleCount <= 0.0)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\\n}\\n\\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\\n{\\n  // convert to tcoords and reject if outside the volume\\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\\n  var tstep: vec4<f32> = tpos2 - tpos;\\n\\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\\n\\n  // did we hit anything\\n  if (rayBounds.x >= rayBounds.y)\\n  {\\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\\n    return;\\n  }\\n\\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\\n  tpos = tpos + tstep*rayBounds.x;\\n  var curDist: f32 = rayBounds.x;\\n  var sumVal: f32 = 0.0;\\n  loop\\n  {\\n    var sample: f32 = getTextureValue(vTex, tpos);\\n    // right now leave filtering off until WebGL changes get merged\\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\\n    // {\\n      sumVal = sumVal + sample;\\n    // }\\n\\n    // increment position\\n    curDist = curDist + 1.0;\\n    tpos = tpos + tstep;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayBounds.y) { break; }\\n  }\\n\\n  // process to get the color and opacity\\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\\n}\\n\\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\\n{\\n  // initial ray position is at the beginning\\n  var rayPosSC: vec4<f32> = minPosSC;\\n\\n  // how many rows (tfuns) do we have in our tfunTexture\\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\\n\\n  var curDist: f32 = 0.0;\\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\\n  var sampleColor: vec4<f32>;\\n//VTK::Volume::TraverseCalls\\n\\n  loop\\n  {\\n    // for each volume, sample and accumulate color\\n//VTK::Volume::CompositeCalls\\n\\n    // increment position\\n    curDist = curDist + mapperUBO.SampleDistance;\\n    rayPosSC = rayPosSC + rayStepSC;\\n\\n    // check if we have reached a terminating condition\\n    if (curDist > rayLengthSC) { break; }\\n    if (computedColor.a > 0.98) { break; }\\n  }\\n  return computedColor;\\n}\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\\n\\n  // discard empty rays\\n  if (rayMax <= rayMin) { discard; }\\n  else\\n  {\\n    // compute start and end ray positions in view coordinates\\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\\n\\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\\n    rayStepSC.w = 0.0;\\n\\n    var computedColor: vec4<f32>;\\n\\n//VTK::Volume::Loop\\n\\n//VTK::RenderEncoder::Impl\\n  }\\n\\n  return output;\\n}\\n&quot;,t.UBO=sy.newInstance({label:&quot;mapperUBO&quot;}),t.UBO.addEntry(&quot;SampleDistance&quot;,&quot;f32&quot;),t.SSBO=py.newInstance({label:&quot;volumeSSBO&quot;}),t.componentSSBO=py.newInstance({label:&quot;componentSSBO&quot;}),t.lutBuildTime={},Wt.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePassFSQ&quot;),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription(&quot;vertex&quot;);r.addBuiltinOutput(&quot;vec4<f32>&quot;,&quot;@builtin(position) Position&quot;);let o=r.getCode();o=_v.substitute(o,&quot;//VTK::Position::Impl&quot;,[&quot;output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);&quot;,&quot;output.Position = vec4<f32>(vertexBC, 1.0);&quot;]).result,r.setCode(o),t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)},t.shaderReplacements.set(&quot;replaceShaderPosition&quot;,e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription(&quot;fragment&quot;);let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===eg.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push(&quot;    computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;)):(s.push(`  sampleColor = traverseVals[${e}];`),s.push(&quot;  computedColor = vec4<f32>(\\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);&quot;));a=_v.substitute(a,&quot;//VTK::Volume::CompositeCalls&quot;,i).result,a=_v.substitute(a,&quot;//VTK::Volume::TraverseCalls&quot;,s).result,a=_v.substitute(a,&quot;//VTK::Volume::TraverseDec&quot;,[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===eg.COMPOSITE_BLEND?l=!0:n===eg.MAXIMUM_INTENSITY_BLEND?a=_v.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===eg.MINIMUM_INTENSITY_BLEND?a=_v.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===eg.AVERAGE_INTENSITY_BLEND?a=_v.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result:n===eg.ADDITIVE_INTENSITY_BLEND&&(a=_v.substitute(a,&quot;//VTK::Volume::Loop&quot;,[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,&quot;//VTK::Volume::Loop&quot;]).result)}l&&(a=_v.substitute(a,&quot;//VTK::Volume::Loop&quot;,[&quot;    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);&quot;]).result),o.setCode(a)},t.shaderReplacements.set(&quot;replaceShaderVolume&quot;,e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;rgba8unorm&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;tfunTexture&quot;);t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:&quot;r16float&quot;},r=n.getTextureManager().getTexture(e).createView(&quot;ofunTexture&quot;);t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();m(fy),x(fy,fy,o);const d=n.getMatrix();h(gy,d),v(gy,gy),b(fy,gy,fy);const p=r.getWorldToIndex();b(fy,p,fy);const f=r.getDimensions();m(gy),C(gy,gy,[1/f[0],1/f[1],1/f[2]]),b(fy,gy,fy);for(let t=0;t<16;t++)a[16*e+t]=fy[t];v(fy,fy);for(let t=0;t<4;t++)i[16*e+4*t]=fy[4*t],i[16*e+4*t+1]=fy[4*t+1],i[16*e+4*t+2]=fy[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const g=r.getSpacing();c[4*e]=g[0],c[4*e+1]=g[1],c[4*e+2]=g[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),y=n.getProperty().getIpScalarRange();u[4*e]=y[0]/T,u[4*e+1]=y[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry(&quot;SCTCMatrix&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;planeNormals&quot;,&quot;mat4x4<f32>&quot;),t.SSBO.addEntry(&quot;shade&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;tstep&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;spacing&quot;,&quot;vec4<f32>&quot;),t.SSBO.addEntry(&quot;ipScalarRange&quot;,&quot;vec4<f32>&quot;),t.SSBO.setAllInstancesFromArray(&quot;SCTCMatrix&quot;,a),t.SSBO.setAllInstancesFromArray(&quot;planeNormals&quot;,i),t.SSBO.setAllInstancesFromArray(&quot;shade&quot;,l),t.SSBO.setAllInstancesFromArray(&quot;tstep&quot;,s),t.SSBO.setAllInstancesFromArray(&quot;spacing&quot;,c),t.SSBO.setAllInstancesFromArray(&quot;ipScalarRange&quot;,u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),g=new Float64Array(t.numRows),T=new Float64Array(t.numRows),y=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=Xv(l),u={scale:[255],offset:[0]};2===c.elementSize&&&quot;float&quot;===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);g[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,y[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,y[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry(&quot;cScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;cShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;oShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goShift&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;goScale&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomin&quot;,&quot;f32&quot;),t.componentSSBO.addEntry(&quot;gomax&quot;,&quot;f32&quot;),t.componentSSBO.setAllInstancesFromArray(&quot;cScale&quot;,d),t.componentSSBO.setAllInstancesFromArray(&quot;cShift&quot;,p),t.componentSSBO.setAllInstancesFromArray(&quot;oScale&quot;,f),t.componentSSBO.setAllInstancesFromArray(&quot;oShift&quot;,g),t.componentSSBO.setAllInstancesFromArray(&quot;goScale&quot;,A),t.componentSSBO.setAllInstancesFromArray(&quot;goShift&quot;,S),t.componentSSBO.setAllInstancesFromArray(&quot;gomin&quot;,T),t.componentSSBO.setAllInstancesFromArray(&quot;gomax&quot;,y),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue(&quot;SampleDistance&quot;,r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=vT.newInstance({label:&quot;clampSampler&quot;}),t.clampSampler.create(t.device,{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}))},e.computePipelineHash=()=>{t.pipelineHash=&quot;volfsq&quot;;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var vy={newInstance:Wt.newInstance(hy,&quot;vtkWebGPUVolumePassFSQ&quot;),extend:hy};const{Representation:Ty}=os,{BufferUsage:yy,PrimitiveTypes:by}=ny,xy=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],Cy={colorTextureView:null,depthTextureView:null,volumes:null};function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cy,n),ev.extend(e,t,n),t._mapper=sT.newInstance(),t._mapper.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Select::Dec\\n\\n//VTK::VolumePass::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output : fragmentOutput;\\n\\n  //VTK::Select::Impl\\n\\n  //VTK::TCoord::Impl\\n\\n  //VTK::VolumePass::Impl\\n\\n  // use the maximum (closest) of the current value and the zbuffer\\n  // the blend func will then take the min to find the farthest stop value\\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._mapper.getShaderReplacements().set(&quot;replaceShaderVolumePass&quot;,((e,t,n)=>{t.getShaderDescription(&quot;fragment&quot;).addBuiltinInput(&quot;vec4<f32>&quot;,&quot;@builtin(position) fragPos&quot;)})),t._boundsPoly=gu.newInstance(),t._lastMTimes=[],Wt.setGet(e,t,[&quot;colorTextureView&quot;,&quot;depthTextureView&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUVolumePass&quot;),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=vy.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=uT.newInstance(),t._volumeCopyQuad.setPipelineHash(&quot;volpassfsq&quot;),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Renderer::Dec\\n\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._copyUBO=sy.newInstance({label:&quot;mapperUBO&quot;}),t._copyUBO.addEntry(&quot;tscale&quot;,&quot;vec2<f32>&quot;),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Go(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray(&quot;tscale&quot;,[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray(&quot;tscale&quot;,[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Wt.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:yy.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:by.Triangles,representation:Ty.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:yy.PointArray,format:&quot;float32x4&quot;,hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,[&quot;vertexBC&quot;]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+xy[e][0],l[n++]=r+xy[e][1],l[n++]=r+xy[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation(&quot;volumeDepthRangePass&quot;),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=gT.newInstance({label:&quot;VolumePass DepthRange&quot;}),t._depthRangeEncoder.setPipelineHash(&quot;volr&quot;),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor1&quot;),t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor2&quot;);let n=t.getCode();n=_v.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);&quot;,&quot;output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);&quot;]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;},{view:null,clearValue:[1,1,1,1],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;max&quot;}}},{format:&quot;r16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one&quot;,operation:&quot;min&quot;}}}]}}),t._depthRangeTexture=ST.newInstance({label:&quot;volumePassMaxDepth&quot;}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView(&quot;maxTexture&quot;);t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=ST.newInstance({label:&quot;volumePassDepthMin&quot;}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;r16float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView(&quot;minTexture&quot;);t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=ST.newInstance({label:&quot;volumePassColor&quot;}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:&quot;bgra8unorm&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView(&quot;volumePassColorTexture&quot;),t._colorTextureView.addSampler(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._clearEncoder=gT.newInstance({label:&quot;VolumePass Clear&quot;}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:&quot;clear&quot;,storeOp:&quot;store&quot;}]}),t._clearEncoder.setPipelineHash(&quot;volpf&quot;),t._clearEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=gT.newInstance({label:&quot;volumePassCopy&quot;}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._copyEncoder.setPipelineHash(&quot;volcopypf&quot;),t._copyEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;rgba16float&quot;,blend:{color:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=gT.newInstance({label:&quot;volumePassMerge&quot;}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<f32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=_v.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);&quot;]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash(&quot;volpf&quot;),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:&quot;bgra8unorm&quot;,blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var Ay={newInstance:Wt.newInstance(Sy,&quot;vtkWebGPUVolumePass&quot;),extend:Sy};const Iy={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function wy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Iy,n),ev.extend(e,t,n),Wt.setGet(e,t,[&quot;opaquePass&quot;,&quot;translucentPass&quot;,&quot;volumePass&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkForwardPass&quot;),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e),t.opaquePass||(t.opaquePass=wT.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation(&quot;queryPass&quot;),i.traverse(e),e.setCurrentOperation(&quot;cameraPass&quot;),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=RT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=Ay.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=gT.newInstance({label:&quot;forwardPassBlit&quot;}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:&quot;load&quot;,storeOp:&quot;store&quot;}]}),t._finalBlitEncoder.setPipelineHash(&quot;fpf&quot;),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:&quot;src-alpha&quot;,dstFactor:&quot;one-minus-src-alpha&quot;},alpha:{srcFactor:&quot;one&quot;,dstFactor:&quot;one-minus-src-alpha&quot;}}}]}}),t._fsqSampler=vT.newInstance({label:&quot;finalPassSampler&quot;}),t._fsqSampler.create(e.getDevice(),{minFilter:&quot;linear&quot;,magFilter:&quot;linear&quot;}),t._fullScreenQuad=uT.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash(&quot;fpfsq&quot;),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate(&quot;\\n//VTK::Mapper::Dec\\n\\n//VTK::TCoord::Dec\\n\\n//VTK::RenderEncoder::Dec\\n\\n//VTK::IOStructs::Dec\\n\\n@fragment\\nfn main(\\n//VTK::IOStructs::Input\\n)\\n//VTK::IOStructs::Output\\n{\\n  var output: fragmentOutput;\\n\\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\\n\\n  //VTK::RenderEncoder::Impl\\n  return output;\\n}\\n&quot;),t._finalBlitOutputTextureView=bT.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var Oy={newInstance:Wt.newInstance(wy,&quot;vtkForwardPass&quot;),extend:wy};const{VtkDataTypes:Py}=xs,Ry={handle:null,device:null};function My(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ry,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;device&quot;]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format=&quot;r&quot;;break;case 2:e.format=&quot;rg&quot;;break;default:e.format=&quot;rgba&quot;}switch(e.dataArray.getDataType()){case Py.UNSIGNED_CHAR:e.format+=&quot;8unorm&quot;;break;case Py.FLOAT:case Py.UNSIGNED_INT:case Py.INT:case Py.DOUBLE:case Py.UNSIGNED_SHORT:case Py.SHORT:default:e.format+=&quot;16float&quot;}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format=&quot;rgba8unorm&quot;,e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=ST.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push(&quot;vtkWebGPUTextureManager&quot;),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var Ey={newInstance:Wt.newInstance(My),extend:My};class Vy extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&&quot;object&quot;==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const Dy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function Ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dy,n),ht(e,t),Ct(e,t,[&quot;handle&quot;]),Tt(e,t,[&quot;bufferManager&quot;,&quot;shaderCache&quot;,&quot;textureManager&quot;]),t.objectCache=new Vy,t.shaderCache=_v.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=ny.newInstance(),t.bufferManager.setDevice(e),t.textureManager=Ey.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push(&quot;vtkWebGPUDevice&quot;),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro(&quot;layout not found&quot;),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro(&quot;attempt to cache an object without a hash&quot;),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var By={newInstance:Mt(Ly,&quot;vtkWebGPUDevice&quot;),extend:Ly};const Ny={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function Fy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ny,n),ev.extend(e,t,n),Wt.get(e,t,[&quot;colorTexture&quot;,&quot;depthTexture&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelectionPass&quot;),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation(&quot;buildPass&quot;),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=ST.newInstance({label:&quot;hardwareSelectorColor&quot;}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;rgba32uint&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView(&quot;hardwareSelectColorTexture&quot;);t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=ST.newInstance({label:&quot;hardwareSelectorDepth&quot;}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:&quot;depth32float&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView(&quot;hardwareSelectDepthTexture&quot;);t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation(&quot;cameraPass&quot;),r.traverse(e),e.setCurrentOperation(&quot;opaquePass&quot;),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=gT.newInstance({label:&quot;HardwareSelectionPass&quot;}),t.selectionRenderEncoder.setPipelineHash(&quot;sel&quot;),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription(&quot;fragment&quot;);t.addOutput(&quot;vec4<u32>&quot;,&quot;outColor&quot;);let n=t.getCode();n=_v.substitute(n,&quot;//VTK::RenderEncoder::Impl&quot;,[&quot;output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);&quot;]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:&quot;none&quot;},depthStencil:{depthWriteEnabled:!0,depthCompare:&quot;greater&quot;,format:&quot;depth32float&quot;},fragment:{targets:[{format:&quot;rgba32uint&quot;,blend:void 0}]}})}}(e,t)}var _y={newInstance:Wt.newInstance(Fy,&quot;vtkWebGPUHardwareSelectionPass&quot;),extend:Fy};const{SelectionContent:ky,SelectionField:Gy}=wp,{FieldAssociations:Uy}=Us,{vtkErrorMacro:zy}=Wt;function Wy(e){return`${e.propID} ${e.compositeID}`}function Hy(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function jy(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=Hy(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=Hy(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=jy(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=jy(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=jy(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=jy(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=jy(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const Ky={};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),bp.extend(e,t,n),t._selectionPass=_y.newInstance(),Wt.setGet(e,t,[&quot;_WebGPURenderWindow&quot;]),Wt.moveToProtected(e,t,[&quot;WebGPURenderWindow&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUHardwareSelector&quot;),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return zy(&quot;Renderer and view must be set before calling Select.&quot;),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=LT.newInstance({label:&quot;hardwareSelectColorBuffer&quot;});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=LT.newInstance({label:&quot;hardwareSelectDepthBuffer&quot;}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:&quot;depth-only&quot;},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=jy(e,[n,t],0,u);if(r){const t=Wy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=wp.newInstance();switch(i.setContentType(ky.INDICES),e){case Uy.FIELD_ASSOCIATION_CELLS:i.setFieldType(Gy.CELL);break;case Uy.FIELD_ASSOCIATION_POINTS:i.setFieldType(Gy.POINT);break;default:zy(&quot;Unknown field association&quot;)}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var qy={newInstance:Wt.newInstance($y,&quot;vtkWebGPUHardwareSelector&quot;),extend:$y};const Xy=Object.create(null),Yy={};function Zy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yy,n),t.overrides=Xy,Zt.extend(e,t,n),function(e,t){t.classHierarchy.push(&quot;vtkWebGPUViewNodeFactory&quot;)}(0,t)}var Qy={newInstance:Wt.newInstance(Zy,&quot;vtkWebGPUViewNodeFactory&quot;),extend:Zy};const{vtkErrorMacro:Jy}=Wt,eb={position:&quot;absolute&quot;,top:0,left:0,width:&quot;100%&quot;,height:&quot;100%&quot;};const tb={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:&quot;pointer&quot;,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:&quot;image/png&quot;,useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const nb=Wt.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tb,n),t.canvas=document.createElement(&quot;canvas&quot;),t.canvas.style.width=&quot;100%&quot;,t.bgImage=new Image,t.bgImage.style.position=&quot;absolute&quot;,t.bgImage.style.left=&quot;0&quot;,t.bgImage.style.top=&quot;0&quot;,t.bgImage.style.width=&quot;100%&quot;,t.bgImage.style.height=&quot;100%&quot;,t.bgImage.style.zIndex=&quot;-1&quot;,xv.extend(e,t,n),t.myFactory=Qy.newInstance(),t.renderPasses[0]=Oy.newInstance(),t.selector||(t.selector=qy.newInstance(),t.selector.setWebGPURenderWindow(e)),Wt.event(e,t,&quot;imageReady&quot;),Wt.event(e,t,&quot;initialized&quot;),Wt.get(e,t,[&quot;commandEncoder&quot;,&quot;device&quot;,&quot;presentationFormat&quot;,&quot;useBackgroundImage&quot;,&quot;xrSupported&quot;]),Wt.setGet(e,t,[&quot;initialized&quot;,&quot;context&quot;,&quot;canvas&quot;,&quot;device&quot;,&quot;renderPasses&quot;,&quot;notifyStartCaptureImage&quot;,&quot;cursor&quot;,&quot;useOffScreen&quot;]),Wt.setGetArray(e,t,[&quot;size&quot;],2),Wt.event(e,t,&quot;windowResizeEvent&quot;),function(e,t){t.classHierarchy.push(&quot;vtkWebGPURenderWindow&quot;),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute(&quot;width&quot;,t.size[0]),t.canvas.setAttribute(&quot;height&quot;,t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?&quot;none&quot;:&quot;block&quot;,t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:&quot;none&quot;),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:&quot;premultiplied&quot;,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Jy(&quot;WebGPU is not enabled.&quot;);e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Jy(&quot;Error: canvas parent node does not match container&quot;),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:&quot;high-performance&quot;}),t.deleted||(t.device=By.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext(&quot;webgpu&quot;))},e.releaseGraphicsResources=()=>{const n=ev.newInstance();n.setCurrentOperation(&quot;Release&quot;),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;image/png&quot;,{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement(&quot;img&quot;);if(n.style=eb,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display=&quot;none&quot;,t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get(&quot;focalPoint&quot;,&quot;position&quot;,&quot;parallelScale&quot;);return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement(&quot;canvas&quot;),o=r.getContext(&quot;2d&quot;);r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName(&quot;canvas&quot;);for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=LT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*gd.fromHalf(r.colorValues[o]),s[n+1]=255*gd.fromHalf(r.colorValues[o+1]),s[n+2]=255*gd.fromHalf(r.colorValues[o+2]),s[n+3]=255*gd.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=qy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Wt.chain(e.delete,e.setViewStream)}(e,t)}),&quot;vtkWebGPURenderWindow&quot;);var rb;ph(&quot;WebGPU&quot;,nb),rb=nb,Xy.vtkRenderWindow=rb;const ob=Zh(),ab={margin:&quot;0&quot;,padding:&quot;0&quot;,position:&quot;absolute&quot;,top:&quot;0&quot;,left:&quot;0&quot;,width:&quot;100%&quot;,height:&quot;100%&quot;,overflow:&quot;hidden&quot;},ib={position:&quot;absolute&quot;,left:&quot;25px&quot;,top:&quot;25px&quot;,backgroundColor:&quot;white&quot;,borderRadius:&quot;5px&quot;,listStyle:&quot;none&quot;,padding:&quot;5px 10px&quot;,margin:&quot;0&quot;,display:&quot;block&quot;,border:&quot;solid 1px black&quot;,maxWidth:&quot;calc(100% - 70px)&quot;,maxHeight:&quot;calc(100% - 60px)&quot;,overflow:&quot;auto&quot;};function sb(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const lb={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lb,n),Wt.obj(e,t),Wt.get(e,t,[&quot;renderWindow&quot;,&quot;renderer&quot;,&quot;apiSpecificRenderWindow&quot;,&quot;interactor&quot;,&quot;rootContainer&quot;,&quot;container&quot;,&quot;controlContainer&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkFullScreenRenderWindow&quot;);const n=document.querySelector(&quot;body&quot;);function r(t){&quot;c&quot;===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement(&quot;div&quot;),sb(t.container,t.containerStyle||ab),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height=&quot;100%&quot;,n.style.height=&quot;100%&quot;,n.style.padding=&quot;0&quot;,n.style.margin=&quot;0&quot;),t.renderWindow=hh.newInstance(),t.renderer=uh.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(ob.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=Dh.newInstance(),t.interactor.setInteractorStyle(qh.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?&quot;block&quot;:&quot;none&quot;)},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement(&quot;div&quot;),sb(t.controlContainer,t.controlPanelStyle||ib),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener(&quot;keypress&quot;,r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Wt.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener(&quot;keypress&quot;,r),window.removeEventListener(&quot;resize&quot;,e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener(&quot;resize&quot;,e.resize),e.resize()}(e,t)}var ub={newInstance:Wt.newInstance(cb),extend:cb},db={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:pb,Scale:fb}=db,{ScalarMappingTarget:gb}=cl,{vtkDebugMacro:mb,vtkErrorMacro:hb,vtkWarningMacro:vb}=Wt;function Tb(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function yb(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function bb(e,t,n,r){const o=[],a=[];ha(t,o),ha(n,a);const i=[],s=[];Tb(o,i),Tb(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=yb(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=yb(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),va(u,r)}const xb={clamping:!0,colorSpace:pb.RGB,hSVWrap:!0,scale:fb.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function Cb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xb,n),cl.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Wt.obj(t.buildTime),Wt.get(e,t,[&quot;buildTime&quot;,&quot;mappingRange&quot;]),Wt.setGet(e,t,[&quot;useAboveRangeColor&quot;,&quot;useBelowRangeColor&quot;,&quot;discretize&quot;,&quot;numberOfValues&quot;,{type:&quot;enum&quot;,name:&quot;colorSpace&quot;,enum:pb},{type:&quot;enum&quot;,name:&quot;scale&quot;,enum:fb}]),Wt.setArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;],4),Wt.getArray(e,t,[&quot;nanColor&quot;,&quot;belowRangeColor&quot;,&quot;aboveRangeColor&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkColorTransferFunction&quot;),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return hb(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(s<0||s>1)return hb(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return da([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];da([n,r,o],u),da(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===fb.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Oa(s)||Oa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=bo(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Aa(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===pb.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===pb.HSV){const n=[],o=[];ua(v,n),ua(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],da(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===pb.LAB){const t=[],n=[];ha(v,t),ha(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],va(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===pb.DIVERGING?(bb(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):hb(&quot;ColorSpace set to invalid value.&quot;,t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===pb.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===pb.HSV){const e=[],n=[];ua(v,e),ua(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);da(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===pb.LAB){const e=[],t=[];ha(v,e),ha(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;va(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===pb.DIVERGING?(bb(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):hb(&quot;ColorSpace set to invalid value.&quot;);for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return hb(&quot;Attempting to lookup a value with no points in the function&quot;),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(hb(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return hb(&quot;Index out of range!&quot;),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void hb(&quot;attempt to set zero width color range&quot;);s&&(o[0]<=0?console.warn(&quot;attempt to set log scale color range with non-positive minimum&quot;):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):mb(&quot;Transfer Function Has No Points!&quot;)},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void vb(&quot;Transfer Function Has No Points!&quot;);const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===gb.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===gb.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===gb.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===gb.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=pb[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(hb(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=pb.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var Sb={newInstance:Wt.newInstance(Cb,&quot;vtkColorTransferFunction&quot;),extend:Cb,...db},Ab={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Ib,ScaleModes:wb}=Ab,{vtkErrorMacro:Ob}=Wt,Pb={orient:!0,orientationMode:Ib.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:wb.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function Rb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),Gl.extend(e,t,n),Wt.algo(e,t,2,0),t.buildTime={},Wt.obj(t.buildTime,{mtime:0}),t.boundsTime={},Wt.obj(t.boundsTime,{mtime:0}),Wt.setGet(e,t,[&quot;orient&quot;,&quot;orientationMode&quot;,&quot;orientationArray&quot;,&quot;scaleArray&quot;,&quot;scaleFactor&quot;,&quot;scaleMode&quot;,&quot;scaling&quot;]),Wt.get(e,t,[&quot;colorArray&quot;,&quot;matrixArray&quot;,&quot;normalArray&quot;,&quot;buildTime&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkGlyph3DMapper&quot;),e.getOrientationModeAsString=()=>Wt.enumToString(Ib,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Ib.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Ib.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Ib.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Wt.enumToString(wb,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(wb.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(wb.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(wb.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Pa()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===wb.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(Ob(&quot;Cannot scale by components since scale array does not have 3 components.&quot;),a=null);const l=r.getBounds(),c=[];Gi.getCorners(l,c),t.bounds[0]=Gi.INIT_BOUNDS[0],t.bounds[1]=Gi.INIT_BOUNDS[1],t.bounds[2]=Gi.INIT_BOUNDS[2],t.bounds[3]=Gi.INIT_BOUNDS[3],t.bounds[4]=Gi.INIT_BOUNDS[4],t.bounds[5]=Gi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=m(new Float64Array(16)),f=[],g=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,y=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],x(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Ib.MATRIX:b(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Ib.ROTATION:w(n,n,O[2]),A(n,n,O[0]),I(n,n,O[1]);break;case Ib.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&I(n,n,3.1415926);else{const e=No(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,S(n,n,3.1415926,t)}}if(t.scaling){if(g[0]=t.scaleFactor,g[1]=t.scaleFactor,g[2]=t.scaleFactor,a)switch(t.scaleMode){case wb.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)y[t]=i[e*s+t];g[0]*=No(y,s),g[1]=g[0],g[2]=g[0];break;case wb.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)y[t]=i[e*s+t];g[0]*=y[0],g[1]*=y[1],g[2]*=y[2];case wb.SCALE_BY_CONSTANT:}0===g[0]&&(g[0]=1e-10),0===g[1]&&(g[1]=1e-10),0===g[2]&&(g[2]=1e-10),C(n,n,g)}for(let e=0;e<8;++e)In(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);le(r,n),me(r,r),ge(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var Mb={newInstance:Wt.newInstance(Rb,&quot;vtkGlyph3DMapper&quot;),extend:Rb,...Ab};const{vtkErrorMacro:Eb}=Wt,Vb={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function Db(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vb,n),Wt.obj(e,t),t.nodes=[],Wt.setGet(e,t,[&quot;allowDuplicateScalars&quot;,&quot;clamping&quot;]),Wt.setArray(e,t,[&quot;range&quot;],2),Wt.getArray(e,t,[&quot;range&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkPiecewiseFunction&quot;),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return&quot;Constant&quot;;case 1:return&quot;NonDecreasing&quot;;case 2:return&quot;NonIncreasing&quot;;default:return&quot;Varied&quot;}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(Eb(&quot;Index out of range!&quot;),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return Eb(&quot;Index out of range!&quot;),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return Eb(&quot;Midpoint outside range [0.0, 1.0]&quot;),-1;if(a<0||a>1)return Eb(&quot;Sharpness outside range [0.0, 1.0]&quot;),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var Lb={newInstance:Wt.newInstance(Db,&quot;vtkPiecewiseFunction&quot;),extend:Db};const{InterpolationType:Bb,OpacityMode:Nb,FilterMode:Fb,ColorMixPreset:_b}=Jf,{vtkErrorMacro:kb}=Wt;function Gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:_b.DEFAULT,independentComponents:!0,interpolationType:Bb.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:Fb.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Wt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:Nb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Wt.setGet(e,t,[&quot;colorMixPreset&quot;,&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;shade&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;specular&quot;,&quot;specularPower&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;,&quot;filterMode&quot;,&quot;preferSizeOverAccuracy&quot;,&quot;computeNormalFromOpacity&quot;,&quot;volumetricScatteringBlending&quot;,&quot;globalIlluminationReach&quot;,&quot;anisotropy&quot;,&quot;localAmbientOcclusion&quot;,&quot;LAOKernelSize&quot;,&quot;LAOKernelRadius&quot;,&quot;updatedExtents&quot;]),Wt.setGetArray(e,t,[&quot;ipScalarRange&quot;],2),Wt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkVolumeProperty&quot;);const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(kb(&quot;Bad index - must be between 0 and 3&quot;),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=Lb.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=Sb.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=Lb.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return kb(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(kb(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(Bb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(Bb.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(Bb.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Wt.enumToString(Bb,t.interpolationType),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;,&quot;forceNearestInterpolation&quot;].forEach((n=>{const r=Wt.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),[&quot;useGradientOpacity&quot;,&quot;scalarOpacityUnitDistance&quot;,&quot;gradientOpacityMinimumValue&quot;,&quot;gradientOpacityMinimumOpacity&quot;,&quot;gradientOpacityMaximumValue&quot;,&quot;gradientOpacityMaximumOpacity&quot;,&quot;opacityMode&quot;,&quot;forceNearestInterpolation&quot;].forEach((n=>{const r=Wt.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn(&quot;setAverageIPScalarRange is deprecated use setIpScalarRange&quot;),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Wt.enumToString(Fb,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(Fb.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(Fb.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(Fb.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(ba(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(ba(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(ba(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(bo(ba(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var Ub={newInstance:Wt.newInstance(Gb,&quot;vtkVolumeProperty&quot;),extend:Gb,...Jf};const zb={mapper:null};function Wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zb,n),Xi.extend(e,t,n),t.boundsMTime={},Wt.obj(t.boundsMTime),Wt.setGet(e,t,[&quot;mapper&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkVolume&quot;),e.getVolumes=()=>[e],e.makeProperty=Ub.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var Hb={newInstance:Wt.newInstance(Wb,&quot;vtkVolume&quot;),extend:Wb};const{BlendMode:jb}=tg,Kb=[&quot;getAnisotropy&quot;,&quot;getComputeNormalFromOpacity&quot;,&quot;getFilterMode&quot;,&quot;getFilterModeAsString&quot;,&quot;getGlobalIlluminationReach&quot;,&quot;getIpScalarRange&quot;,&quot;getIpScalarRangeByReference&quot;,&quot;getLAOKernelRadius&quot;,&quot;getLAOKernelSize&quot;,&quot;getLocalAmbientOcclusion&quot;,&quot;getPreferSizeOverAccuracy&quot;,&quot;getVolumetricScatteringBlending&quot;,&quot;setAnisotropy&quot;,&quot;setAverageIPScalarRange&quot;,&quot;setComputeNormalFromOpacity&quot;,&quot;setFilterMode&quot;,&quot;setFilterModeToNormalized&quot;,&quot;setFilterModeToOff&quot;,&quot;setFilterModeToRaw&quot;,&quot;setGlobalIlluminationReach&quot;,&quot;setIpScalarRange&quot;,&quot;setIpScalarRangeFrom&quot;,&quot;setLAOKernelRadius&quot;,&quot;setLAOKernelSize&quot;,&quot;setLocalAmbientOcclusion&quot;,&quot;setPreferSizeOverAccuracy&quot;,&quot;setVolumetricScatteringBlending&quot;],$b={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=Lb.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Gi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:jb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),As(e,t,n),Wt.setGet(e,t,[&quot;sampleDistance&quot;,&quot;imageSampleDistance&quot;,&quot;maximumSamplesPerRay&quot;,&quot;autoAdjustSampleDistances&quot;,&quot;initialInteractionScale&quot;,&quot;interactionSampleDistanceFactor&quot;,&quot;blendMode&quot;,&quot;volumeShadowSamplingDistFactor&quot;,&quot;colorTextureWidth&quot;,&quot;opacityTextureWidth&quot;,&quot;labelOutlineTextureWidth&quot;]),Wt.event(e,t,&quot;lightingActivated&quot;),function(e,t){t.classHierarchy.push(&quot;vtkVolumeMapper&quot;);const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(jb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(jb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(jb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(jb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(jb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(jb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Wt.enumToString(jb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),Kb.forEach((t=>{e[t]=()=>{throw new Error(`The method &quot;volumeMapper.${t}()&quot; doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\\nvolumeActor.getProperty().${t}()\\n`)}}))}(e,t)}var Xb={newInstance:Wt.newInstance(qb,&quot;vtkVolumeMapper&quot;),extend:qb,...$b};const{InterpolationType:Yb}=Rf,{vtkErrorMacro:Zb}=Wt;function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:Yb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Wt.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Wt.setGet(e,t,[&quot;independentComponents&quot;,&quot;interpolationType&quot;,&quot;colorWindow&quot;,&quot;colorLevel&quot;,&quot;ambient&quot;,&quot;diffuse&quot;,&quot;opacity&quot;,&quot;useLookupTableScalarRange&quot;,&quot;useLabelOutline&quot;,&quot;labelOutlineOpacity&quot;,&quot;updatedExtents&quot;]),Wt.setGetArray(e,t,[&quot;labelOutlineThickness&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkImageProperty&quot;),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Zb(&quot;Invalid index&quot;),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Zb(&quot;Invalid index&quot;),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(Yb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(Yb.LINEAR),e.getInterpolationTypeAsString=()=>Wt.enumToString(Yb,t.interpolationType)}(e,t)}var Jb={newInstance:Wt.newInstance(Qb,&quot;vtkImageProperty&quot;),extend:Qb};const ex={mapper:null,forceOpaque:!1,forceTranslucent:!1};function tx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ex,n),Xi.extend(e,t,n),t.boundsMTime={},Wt.obj(t.boundsMTime),Wt.setGet(e,t,[&quot;mapper&quot;,&quot;forceOpaque&quot;,&quot;forceTranslucent&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkImageSlice&quot;),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=Jb.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Gi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return h(a,t.matrix),Gi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var nx={newInstance:Wt.newInstance(tx,&quot;vtkImageSlice&quot;),extend:tx};const rx={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var ox=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rx,n),As(e,t,n),Wt.setGet(e,t,[&quot;slice&quot;,&quot;useCustomExtents&quot;,&quot;colorTextureWidth&quot;,&quot;opacityTextureWidth&quot;,&quot;labelOutlineTextureWidth&quot;]),Wt.setGetArray(e,t,[&quot;customDisplayExtent&quot;],6),Wt.setGetArray(e,t,[&quot;backgroundColor&quot;],4),function(e,t){t.classHierarchy.push(&quot;vtkAbstractImageMapper&quot;),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Wt.vtkErrorMacro(&quot;vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED&quot;),Pa())}(e,t)};function ax(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA(&quot;vtkImageArrayMapper&quot;)?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Cn(c,c);const u=ei.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:ix,otherStaticMethods:sx}=Sl,{SlicingMode:lx}=Lf;const cx={slicingMode:lx.NONE,closestIJKAxis:{ijkMode:lx.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function ux(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cx,n),ox(e,t,n),Wt.get(e,t,[&quot;slicingMode&quot;]),Wt.setGet(e,t,[&quot;closestIJKAxis&quot;,&quot;renderToRectangle&quot;,&quot;sliceAtFocalPoint&quot;,&quot;preferSizeOverAccuracy&quot;]),Sl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case lx.X:n=0;break;case lx.Y:n=1;break;case lx.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ra(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push(&quot;vtkImageMapper&quot;),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case lx.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case lx.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case lx.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case lx.I:l=ba(a[0],i[0],i[1]);break;case lx.J:l=ba(a[1],i[2],i[3]);break;case lx.K:l=ba(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case lx.I:case lx.J:case lx.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case lx.X:e.setSlice(r[0]);break;case lx.Y:e.setSlice(r[1]);break;case lx.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(lx.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(lx.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(lx.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(lx.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(lx.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(lx.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case lx.X:n[0]=1;break;case lx.Y:n[1]=1;break;case lx.Z:n[2]=1;break;case lx.I:Ho(r,[1,0,0],n);break;case lx.J:Ho(r,[0,1,0],n);break;case lx.K:Ho(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==lx.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Pa();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case lx.I:r[0]=a,r[1]=a;break;case lx.J:r[2]=a,r[3]=a;break;case lx.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Pa();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case lx.I:a[0]=s-r,a[1]=s+r;break;case lx.J:a[2]=s-r,a[3]=s+r;break;case lx.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=ax(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=ax(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var dx={newInstance:Wt.newInstance(ux,&quot;vtkImageMapper&quot;),extend:ux,...ix,...sx,...Lf};const{vtkErrorMacro:px}=Wt;function fx(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const gx={outputPointsPrecision:Ms.DEFAULT};function mx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gx,n),Wt.setGet(e,t,[&quot;outputPointsPrecision&quot;]),Wt.obj(e,t),Wt.algo(e,t,1,1),function(e,t){t.classHierarchy.push(&quot;vtkAppendPolyData&quot;),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void px(&quot;No input specified.&quot;);if(1===o)return void(r[0]=n[0]);const a=r[0]&&n[0]!==r[0]?r[0].initialize():gu.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Ms.SINGLE?s=cs.FLOAT:t.outputPointsPrecision===Ms.DOUBLE&&(s=cs.DOUBLE);const v=Yl.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=xs.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=xs.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=xs.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),fx(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),fx(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),fx(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),fx(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var hx={newInstance:Wt.newInstance(mx,&quot;vtkAppendPolyData&quot;),extend:mx};const vx={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:&quot;Float64Array&quot;};function Tx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vx,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;height&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),Wt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push(&quot;vtkConeSource&quot;),e.requestData=(e,n)=>{const r=2*Math.PI/t.resolution,o=-t.height/2,a=t.resolution+1,i=4*t.resolution+1+t.resolution;let s=0;const l=Wt.newTypedArray(t.pointType,3*a);let c=0;const u=new Uint32Array(i);l[0]=t.height/2,l[1]=0,l[2]=0,t.capping&&(u[c++]=t.resolution);for(let e=0;e<t.resolution;e++)s++,l[3*s+0]=o,l[3*s+1]=t.radius*Math.cos(e*r),l[3*s+2]=t.radius*Math.sin(e*r),t.capping&&(u[t.resolution-c+++1]=s);for(let e=0;e<t.resolution;e++)u[c++]=3,u[c++]=0,u[c++]=e+1,u[c++]=e+2>t.resolution?1:e+2;df().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(l);const d=n[0]?.initialize()||gu.newInstance();d.getPoints().setData(l,3),d.getPolys().setData(u,1),n[0]=d}}(e,t)}var yx={newInstance:Wt.newInstance(Tx,&quot;vtkConeSource&quot;),extend:Tx};const bx={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:&quot;Float64Array&quot;};function xx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,bx,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;height&quot;,&quot;initAngle&quot;,&quot;otherRadius&quot;,&quot;radius&quot;,&quot;resolution&quot;,&quot;capping&quot;]),Wt.setGetArray(e,t,[&quot;center&quot;,&quot;direction&quot;],3),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push(&quot;vtkCylinderSource&quot;),e.requestData=(e,n)=>{const r=2*Math.PI/t.resolution;let o=2*t.resolution,a=5*t.resolution;t.capping&&(o=4*t.resolution,a=7*t.resolution+2);const i=Wt.newTypedArray(t.pointType,3*o);let s=0;const l=new Uint32Array(a),c=new Float32Array(3*o),u=xs.newInstance({numberOfComponents:3,values:c,name:&quot;Normals&quot;}),d=new Float32Array(2*o),p=xs.newInstance({numberOfComponents:2,values:d,name:&quot;TCoords&quot;}),f=[0,0,0],g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0],T=[0,0],y=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){f[0]=Math.cos(e*r+t.initAngle),g[0]=f[0],m[0]=t.radius*f[0]+t.center[0],h[0]=m[0],v[0]=Math.abs(2*e/t.resolution-1),T[0]=v[0],m[1]=.5*t.height+t.center[1],h[1]=-.5*t.height+t.center[1],v[1]=0,T[1]=1,f[2]=-Math.sin(e*r+t.initAngle),g[2]=f[2],m[2]=y*f[2]+t.center[2],h[2]=m[2];const n=2*e;for(let e=0;e<3;e++)c[3*n+e]=f[e],c[3*(n+1)+e]=g[e],i[3*n+e]=m[e],i[3*(n+1)+e]=h[e],e<2&&(d[2*n+e]=v[e],d[2*(n+1)+e]=T[e])}for(let e=0;e<t.resolution;e++){l[s++]=4,l[s++]=2*e,l[s++]=2*e+1;const n=(2*e+3)%(2*t.resolution);l[s++]=n,l[s++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){m[0]=t.radius*Math.cos(e*r+t.initAngle),h[0]=m[0],v[0]=m[0],T[0]=m[0],m[0]+=t.center[0],h[0]+=t.center[0],f[1]=1,g[1]=-1,m[1]=.5*t.height+t.center[1],h[1]=-.5*t.height+t.center[1],m[2]=-y*Math.sin(e*r+t.initAngle),h[2]=m[2],v[1]=m[2],T[1]=m[2],m[2]+=t.center[2],h[2]+=t.center[2];const n=2*t.resolution+e,o=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)c[3*n+e]=f[e],c[3*o+e]=g[e],i[3*n+e]=m[e],i[3*o+e]=h[e],e<2&&(d[2*n+e]=v[e],d[2*o+e]=T[e])}l[s++]=t.resolution;for(let e=0;e<t.resolution;e++)l[s++]=2*t.resolution+e;l[s++]=t.resolution;for(let e=0;e<t.resolution;e++)l[s++]=3*t.resolution+e}df().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(i);const b=n[0]?.initialize()||gu.newInstance();b.getPoints().setData(i,3),b.getPolys().setData(l,1),b.getPointData().setNormals(u),b.getPointData().setTCoords(p),n[0]=b}}(e,t)}var Cx={newInstance:Wt.newInstance(xx,&quot;vtkCylinderSource&quot;),extend:xx};const Sx={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:&quot;Float64Array&quot;};function Ax(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sx,n),Wt.obj(e,t),Wt.setGet(e,t,[&quot;tipResolution&quot;,&quot;tipRadius&quot;,&quot;tipLength&quot;,&quot;shaftResolution&quot;,&quot;shaftRadius&quot;,&quot;invert&quot;]),Wt.setGetArray(e,t,[&quot;direction&quot;],3),Wt.algo(e,t,0,1),function(e,t){t.classHierarchy.push(&quot;vtkArrowSource&quot;),e.requestData=(e,n)=>{const r=Cx.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();uf().rotateZ(-90).apply(a).apply(i);const s=yx.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();df().translate(1-.5*t.tipLength,0,0).apply(c);const u=hx.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();df().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(df().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(df().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Ix={newInstance:Wt.newInstance(Ax,&quot;vtkArrowSource&quot;),extend:Ax};function wx(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];uf().translate(...n).apply(e.getPoints().getData())}function Ox(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],uf().translate(...o).apply(e.getPoints().getData())}function Px(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(xs.newInstance({name:&quot;color&quot;,numberOfComponents:3,values:a}))}function Rx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};ss.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Wt.setGet(e,t,[&quot;config&quot;,&quot;xConfig&quot;,&quot;yConfig&quot;,&quot;zConfig&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkAxesActor&quot;);const n=Gl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Ix.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?wx(r):Ox(r,0,e.invert),Px(r,...e.color),e={...t.config,...t.yConfig};const o=Ix.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?wx(o):Ox(o,1,e.invert),Px(o,...e.color),e={...t.config,...t.zConfig};const a=Ix.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?wx(a):Ox(a,2,e.invert),Px(a,...e.color);const i=hx.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Wt.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var Mx={newInstance:Wt.newInstance(Rx,&quot;vtkAxesActor&quot;),extend:Rx};const Ex=&quot;resetcamera&quot;,Vx=&quot;orientation&quot;,Dx={MODE_RESET_CAMERA:Ex,MODE_ORIENTATION:Vx,MODE_SAME:&quot;same&quot;};const Lx={mode:Vx,focalPoint:[0,0,0],distance:6.8,active:!0};function Bx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lx,n),ht(e,t),Ct(e,t,[&quot;mode&quot;,&quot;active&quot;,&quot;srcRenderer&quot;,&quot;dstRenderer&quot;,&quot;distance&quot;]),It(e,t,[&quot;focalPoint&quot;],3,0),function(e,t){t.classHierarchy.push(&quot;vtkCameraSynchronizer&quot;);const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName(&quot;position&quot;),s=e.getReferenceByName(&quot;focalPoint&quot;),l=e.getReferenceByName(&quot;viewUp&quot;),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===Vx?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],Fo(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===Ex&&t.dstRenderer.resetCamera())},e.delete=Et((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var Nx={newInstance:Mt(Bx,&quot;vtkCameraSynchronizer&quot;),extend:Bx,SynchronizationMode:Dx};const Fx={},_x={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=Nx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:Nx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var kx=function(e,t,n){const r=e.get(&quot;synchronizedViewId&quot;).synchronizedViewId;if(!t.behaviors||!r)return;Fx[r]||(Fx[r]={});const o=Fx[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=Nx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];_x[e.type]?o[r]=new _x[e.type](n,e):console.log(&quot;No mapping for&quot;,e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const Gx={},Ux=/instance:\\${([^}]+)}/,zx={},Wx=[],Hx={},jx={vtkPoints:Yl,vtkCellArray:Kl,vtkDataArray:xs};function Kx(e){return e.map((e=>Ux.exec(e))).filter((e=>e)).map((e=>e[1]))}function $x(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),$x(e,t)})),t}function qx(e,t,n,r){if(!t)return Promise.reject(new Error(&quot;No instance provided.&quot;));const o=Gx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function Xx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Gx[e];return n&&n.build?n.build(t):(console.log(&quot;No builder for&quot;,e),null)}function Yx(){Object.keys(Gx).forEach((e=>{delete Gx[e]}))}function Zx(e){if(1===e[1].length)return-1===Wx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===Wx.indexOf(e[1][n]);return t}function Qx(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(Hx[r]){const{key:n,value:o}=Hx[r];if(!n||e.properties[n]===o)return void Wx.push((e=>`instance:\\${${e}}`)(t))}let o=n.getInstance(t);o||(o=Xx(r,{managedInstanceId:t}),n.registerInstance(t,o)),qx(r,o,e,n)})),t.calls&&t.calls.filter(Zx).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=Ux.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:&quot;addArray&quot;,a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:&quot;vtkDataArray&quot;,l=jx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log(&quot;Error fetching array&quot;,JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error(&quot;Error in array handling for state&quot;,JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function Jx(e,t,n){zx[t.id]||Qx(e,t,n),zx[t.id]=!0}function eC(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function tC(e){const t=e.name?`_${e.name}`:&quot;&quot;;return`${e.hash}_${e.dataType}${t}`}function nC(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${st(r)}`;const t=tC(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=tC(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),eC(t.getPointData(),i.pointData),eC(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Qx(t,s,r);return r.end(),l}}const rC=nC([&quot;points&quot;,&quot;polys&quot;,&quot;verts&quot;,&quot;lines&quot;,&quot;strips&quot;]),oC=nC([]);function aC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Qx;Xx||qx?Gx[e]={build:t,update:n}:delete Gx[e]}const iC={vtkMapper:[&quot;vtkOpenGLPolyDataMapper&quot;,&quot;vtkCompositePolyDataMapper2&quot;,&quot;vtkDataSetMapper&quot;],vtkProperty:[&quot;vtkOpenGLProperty&quot;],vtkRenderer:[&quot;vtkOpenGLRenderer&quot;],vtkCamera:[&quot;vtkOpenGLCamera&quot;],vtkColorTransferFunction:[&quot;vtkPVDiscretizableColorTransferFunction&quot;],vtkActor:[&quot;vtkOpenGLActor&quot;,&quot;vtkPVLODActor&quot;],vtkLight:[&quot;vtkOpenGLLight&quot;,&quot;vtkPVLight&quot;],vtkTexture:[&quot;vtkOpenGLTexture&quot;],vtkImageMapper:[&quot;vtkOpenGLImageSliceMapper&quot;],vtkVolumeMapper:[&quot;vtkFixedPointVolumeRayCastMapper&quot;]},sC={vtkAxesActor:{build:Mx.newInstance,update:Qx},vtkRenderWindow:{build:hh.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Zx).filter((e=>&quot;removeRenderer&quot;===e[0])).forEach((e=>{Kx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Qx(e,t,n),kx(e,t,n)}},vtkRenderer:{build:uh.newInstance,update:function(e,t,n){Qx(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=$x(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Zx).filter((e=>&quot;removeViewProp&quot;===e[0])).forEach((e=>{Kx(e[1]).forEach((e=>{const t=n.getInstance(e).get(&quot;flattenedDepIds&quot;).flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:fl.newInstance,update:Qx},vtkCamera:{build:Ym.newInstance,update:Jx},vtkPolyData:{build:gu.newInstance,update:rC},vtkImageData:{build:Xs.newInstance,update:oC},vtkMapper:{build:Gl.newInstance,update:Qx},vtkGlyph3DMapper:{build:Mb.newInstance,update:Qx},vtkProperty:{build:os.newInstance,update:Qx},vtkActor:{build:ss.newInstance,update:Qx},vtkLight:{build:Jm.newInstance,update:Qx},vtkColorTransferFunction:{build:Sb.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:vu.newInstance,update:Qx},vtkVolume:{build:Hb.newInstance,update:Qx},vtkVolumeMapper:{build:Xb.newInstance,update:Qx},vtkVolumeProperty:{build:Ub.newInstance,update:Qx},vtkImageSlice:{build:nx.newInstance,update:Qx},vtkImageMapper:{build:dx.newInstance,update:Qx},vtkImageProperty:{build:Jb.newInstance,update:Qx},vtkPiecewiseFunction:{build:Lb.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:Lu.newInstance,update:Qx},vtkScalarBarActor:{build:dp.newInstance,update:Qx}};function lC(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&Yx(),Object.keys(sC).forEach((e=>{const t=sC[e];aC(e,t.build,t.update)}))}function cC(){Object.keys(iC).forEach((e=>{iC[e].forEach((t=>{Gx[t]=Gx[e]}))}))}lC(),cC(),Hx.vtkPVLight={};var uC={build:Xx,update:qx,genericUpdater:Qx,oneTimeGenericUpdater:Jx,setTypeMapping:aC,clearTypeMapping:Yx,getSupportedTypes:function(){return Object.keys(Gx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(zx).forEach((e=>{delete zx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete zx[e]})),r},updateRenderWindow:function(e,t,n){return qx(&quot;vtkRenderWindow&quot;,e,t,n)},excludeInstance:function(e,t,n){Hx[e]={key:t,value:n}},setDefaultMapping:lC,applyDefaultAliases:cC,alwaysUpdateCamera:function(){aC(&quot;vtkCamera&quot;,Ym.newInstance),cC()}};const dC={};function pC(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if(&quot;string&quot;==typeof t&&(i=$g.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=at(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=at(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log(&quot;Error getting data array:&quot;),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use &quot;setArrayFetcher&quot; to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function fC(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function gC(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Rt(t,n,&quot;progressEvent&quot;),Rt(t,n,&quot;progressDone&quot;),t}function mC(){const e={};let t=&quot;default&quot;;return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function hC(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:&quot;default&quot;,t=dC[e];return t||(t={...pC(),...fC(),...gC(),...mC()},dC[e]=t),t}function vC(e,t){let n=-1,r=100;const o=e=>e.get(&quot;managedInstanceId&quot;).managedInstanceId,a=()=>Dt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get(&quot;synchronizedViewId&quot;).synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),uC.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){uC.clearOneTimeUpdaters(a())}}}const TC={synchronizerContextName:&quot;default&quot;,synchronizerContext:null,synchronizedViewId:null};function yC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,TC,n),hh.extend(e,t),Tt(e,t,[&quot;synchronizerContext&quot;]),function(e,t){t.classHierarchy.push(&quot;vtkSynchronizableRenderWindow&quot;),t.synchronizerContext||(t.synchronizerContext=hC(t.synchronizerContextName));const n=vC(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Et(e[t],n[t]):e[t]=n[t]}))}(e,t)}var bC={newInstance:Mt(yC,&quot;vtkSynchronizableRenderWindow&quot;),extend:yC,getSynchronizerContext:hC,setSynchronizerContext:function(e,t){dC[e]=t},clearSynchronizerContext:function(e){if(e&&dC[e]&&delete dC[e],!e){const e=Object.keys(dC);for(let t=0;t<e.length;t++)delete dC[e[t]]}},decorate:function(e){const t=vC(e,hC(arguments.length>1&&void 0!==arguments[1]?arguments[1]:&quot;default&quot;));return{...t,...e,delete:Et(e.delete,t.delete)}},createInstanceMap:fC,createArrayHandler:pC,createProgressHandler:gC,createSceneMtimeHandler:mC,vtkObjectManager:uC};const{vtkErrorMacro:xC,vtkDebugMacro:CC}=Wt;let SC=0;function AC(e){const t=document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`);return t?t.innerHTML:null}function IC(e){return&quot;/&quot;===e[0]?e.substr(1):e}const wC={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=AC(IC(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=AC(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=IC([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join(&quot;/&quot;)),s=AC(i);if(null===s)a(new Error(`No such array ${i}`));else{if(&quot;string&quot;===n.dataType){let e=atob(s);r.compression&&(e=Lm(Em(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array($g.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&(&quot;string&quot;===n.dataType||&quot;JSON&quot;===n.dataType?n.buffer=Lm(Em(new Uint8Array(n.buffer))):n.buffer=Em(new Uint8Array(n.buffer)).buffer),&quot;JSON&quot;===n.ref.encode?n.values=JSON.parse(n.buffer):(Gm!==n.ref.encode&&Gm&&(CC(`Swap bytes of ${n.name}`),Um(n.buffer,ls[n.dataType])),n.values=Wt.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&xC(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--SC&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url=&quot;${e}&quot;]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};Xg(&quot;html&quot;,(e=>wC));const{vtkErrorMacro:OC,vtkDebugMacro:PC}=Wt;function RC(e){return function(e){return&quot;/&quot;===e[0]?e.substr(1):e}(function(e){return new URL(e,&quot;http://any&quot;).pathname}(e))}const MC=function(e){let t=!1,n=0,r=null,o=&quot;&quot;;var a;return(a=e.zipContent,new Promise(((e,t)=>{&quot;string&quot;==typeof a?e(function(e,t){if(t){for(var n=new Zg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(Vm)return Vm.encode(e);var o=e.length,a=new Zg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new Zg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return bm(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error(&quot;Invalid datatype to unpack.&quot;))}))).then((n=>{r=_m(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith(&quot;index.json&quot;)&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\\.json$/,&quot;&quot;),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||OC(&quot;ERROR!!! zip not ready...&quot;);const u=RC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join(&quot;/&quot;));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if(&quot;string&quot;!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&(&quot;string&quot;===e.dataType||&quot;JSON&quot;===e.dataType?e.buffer=Lm(Em(new Uint8Array(e.buffer))):e.buffer=Em(new Uint8Array(e.buffer)).buffer),&quot;JSON&quot;===e.ref.encode?e.values=JSON.parse(e.buffer):(Gm!==e.ref.encode&&Gm&&(PC(`Swap bytes of ${e.name}`),Um(e.buffer,ls[e.dataType])),e.values=Wt.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&OC(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(Lm(Em(r))):JSON.parse(r),n()}}(i,s.compression,d);e(Lm(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=RC(n);t||OC(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];if(a.compression){if(&quot;gz&quot;===a.compression){const e=Lm(Em(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error(&quot;Invalid compression&quot;))}return Promise.resolve(JSON.parse(Lm(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=RC(n);t||OC(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(Lm(_m(s))):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(Lm(s))},fetchImage(e,n){const a=RC(n);t||OC(&quot;ERROR!!! zip not ready...&quot;);const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=Kg(i.buffer);n.src=`data:image/${function(e){const t=e.split(&quot;.&quot;).pop().toLowerCase();return&quot;jpg&quot;===t?&quot;jpeg&quot;:t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=RC(n);t||OC(&quot;ERROR!!! zip not ready...&quot;);const s=r[`${o}${i}`];return a.compression?&quot;gz&quot;===a.compression?Promise.resolve(Em(s).buffer):Promise.reject(new Error(&quot;Invalid compression&quot;)):Promise.resolve(s.buffer)}}};Xg(&quot;zip&quot;,(e=>MC(e)));var EC=n(911),VC=n.n(EC),DC=n(893),LC=n.n(DC),BC=n(383),NC=n.n(BC),FC=n(884),_C=n.n(FC),kC=n(88),GC=n.n(kC),UC=n(997),zC=n.n(UC),WC=n(96),HC={};HC.styleTagTransform=zC(),HC.setAttributes=_C(),HC.insert=NC().bind(null,&quot;head&quot;),HC.domAPI=LC(),HC.insertStyleElement=GC(),VC()(WC.A,HC);var jC=WC.A&&WC.A.locals?WC.A.locals:void 0;let KC=!0;function $C(e){e.preventDefault(),e.stopPropagation()}function qC(e,t){KC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=ub.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:&quot;100%&quot;,width:&quot;100%&quot;,position:&quot;absolute&quot;}}).getRenderWindow(),o=bC.getSynchronizerContext(),a=bC.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement(&quot;div&quot;);n.setAttribute(&quot;class&quot;,jC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Wt.formatBytesToProperUnit(e.loaded)};t.fileURL?Km.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=Yg.get(&quot;zip&quot;,{zipContent:t,callback:e=>{r.fetchJSON(null,&quot;index.json&quot;).then(i)}})})):Km.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=Yg.get(&quot;zip&quot;,{zipContent:t.file,callback:t=>{e.fetchJSON(null,&quot;index.json&quot;).then(i)}})}else if(t.base64Str){const e=$g.toArrayBuffer(t.base64Str),n=Yg.get(&quot;zip&quot;,{zipContent:e,callback:e=>{n.fetchJSON(null,&quot;index.json&quot;).then(i)}})}}function XC(e){KC=!1;const t=document.querySelector(&quot;.content&quot;),n=document.querySelector(&quot;body&quot;),r=e||t||n;r!==e?(r.classList.add(jC.fullScreen),n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;):(n.style.margin=&quot;0&quot;,n.style.padding=&quot;0&quot;);const o=document.createElement(&quot;div&quot;);o.innerHTML=`<div class=&quot;${jC.bigFileDrop}&quot;/><input type=&quot;file&quot; accept=&quot;.zip,.vtksz&quot; style=&quot;display: none;&quot;/>`,r.appendChild(o);const a=o.querySelector(&quot;input&quot;);function i(e){$C(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(&quot;.&quot;).slice(-1)[0];qC(r,{file:n[0],ext:e})}}a.addEventListener(&quot;change&quot;,i),o.addEventListener(&quot;drop&quot;,i),o.addEventListener(&quot;click&quot;,(e=>a.click())),o.addEventListener(&quot;dragover&quot;,$C)}const YC=Zh();if(YC.url||YC.fileURL){const e=document.querySelector(&quot;.content&quot;),t=document.querySelector(&quot;body&quot;),n=e||t;n&&(n.classList.add(jC.fullScreen),t.style.margin=&quot;0&quot;,t.style.padding=&quot;0&quot;),KC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>qC(n,YC)))}setTimeout((()=>{KC&&XC()}),100),window.OfflineLocalView={initLocalFileLoader:XC,load:qC}},613:function(e){&quot;use strict&quot;;e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n=&quot;&quot;,r=void 0!==t[5];return t[4]&&(n+=&quot;@supports (&quot;.concat(t[4],&quot;) {&quot;)),t[2]&&(n+=&quot;@media &quot;.concat(t[2],&quot; {&quot;)),r&&(n+=&quot;@layer&quot;.concat(t[5].length>0?&quot; &quot;.concat(t[5]):&quot;&quot;,&quot; {&quot;)),n+=e(t),r&&(n+=&quot;}&quot;),t[2]&&(n+=&quot;}&quot;),t[4]&&(n+=&quot;}&quot;),n})).join(&quot;&quot;)},t.i=function(e,n,r,o,a){&quot;string&quot;==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]=&quot;@layer&quot;.concat(u[5].length>0?&quot; &quot;.concat(u[5]):&quot;&quot;,&quot; {&quot;).concat(u[1],&quot;}&quot;)),u[5]=a),n&&(u[2]?(u[1]=&quot;@media &quot;.concat(u[2],&quot; {&quot;).concat(u[1],&quot;}&quot;),u[2]=n):u[2]=n),o&&(u[4]?(u[1]=&quot;@supports (&quot;.concat(u[4],&quot;) {&quot;).concat(u[1],&quot;}&quot;),u[4]=o):u[4]=&quot;&quot;.concat(o)),t.push(u))}},t}},336:function(e){&quot;use strict&quot;;e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['&quot;].*['&quot;]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/[&quot;'() \\t\\n]|(%20)/.test(e)||t.needQuotes?'&quot;'.concat(e.replace(/&quot;/g,'\\\\&quot;').replace(/\\n/g,&quot;\\\\n&quot;),'&quot;'):e):e}},20:function(e){&quot;use strict&quot;;e.exports=function(e){return e[1]}},555:function(e,t,n){&quot;use strict&quot;;var r=n(382),o=&quot;function&quot;==typeof Symbol&&&quot;symbol&quot;==typeof Symbol(&quot;foo&quot;),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,&quot;x&quot;,{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||&quot;function&quot;==typeof(o=r)&&&quot;[object Function]&quot;===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){&quot;use strict&quot;;e.exports=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;var e;try{e=this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window;if(&quot;object&quot;==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){&quot;use strict&quot;;e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&&quot;object&quot;==typeof t&&&quot;object&quot;==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){&quot;use strict&quot;;&quot;undefined&quot;!=typeof self?e.exports=self:&quot;undefined&quot;!=typeof window?e.exports=window:e.exports=Function(&quot;return this&quot;)()},59:function(e,t,n){&quot;use strict&quot;;var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){&quot;use strict&quot;;var r=n(979);e.exports=function(){return&quot;object&quot;==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){&quot;use strict&quot;;var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,&quot;globalThis&quot;);t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,&quot;globalThis&quot;,{configurable:!0,enumerable:!1,value:e,writable:!0})}else&quot;object&quot;==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){&quot;use strict&quot;;var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},&quot;toString&quot;),c=s.call((function(){}),&quot;prototype&quot;),u=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if(&quot;undefined&quot;==typeof window)return!1;for(var e in window)try{if(!p[&quot;$&quot;+e]&&o.call(window,e)&&null!==window[e]&&&quot;object&quot;==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&&quot;object&quot;==typeof e,n=&quot;[object Function]&quot;===a.call(e),r=i(e),s=t&&&quot;[object String]&quot;===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError(&quot;Object.keys called on a non-object&quot;);var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&&quot;prototype&quot;===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if(&quot;undefined&quot;==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&&quot;constructor&quot;===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){&quot;use strict&quot;;var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){&quot;use strict&quot;;var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r=&quot;[object Arguments]&quot;===n;return r||(r=&quot;[object Array]&quot;!==n&&null!==e&&&quot;object&quot;==typeof e&&&quot;number&quot;==typeof e.length&&e.length>=0&&&quot;[object Function]&quot;===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(&quot; &quot;),n.s1=r(&quot; &quot;),n.s2=r(&quot; &quot;),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&(&quot;object&quot;==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n=&quot;&quot;;t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+=&quot;\\0&quot;,r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=&quot;&quot;+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n=&quot;&quot;;t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(&quot;object&quot;==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,&quot;global&quot;in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&&quot;object&quot;==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:&quot;string&quot;==o?e:e+&quot;\\0&quot;}function v(e,t){for(var n,r=e+&quot;&quot;,o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}(&quot;undefined&quot;!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){&quot;use strict&quot;;var e=[&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r=&quot;&quot;;for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join(&quot;&quot;)}function s(e){return/[\\u0080-\\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o(&quot;hello&quot;)),&quot;undefined&quot;==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff=&quot;&quot;,this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){&quot;use strict&quot;;var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,&quot;.viewer-module-fullScreen_bbk9Y {\\n  position: absolute;\\n  width: 100vw;\\n  height: 100vh;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n  background: black;\\n  margin: 0;\\n  padding: 0;\\n  z-index: -1;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n}\\n\\n.viewer-module-fullParentSize_ETopO {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  top: 0;\\n  left: 0;\\n  overflow: hidden;\\n}\\n\\n.viewer-module-bigFileDrop_aqCgh {\\n  position: absolute;\\n  left: 50%;\\n  top: 50%;\\n  transform: translate(-50%, -50%);\\n  background-color: white;\\n  background-image: url(&quot;+d+&quot;);\\n  background-repeat: no-repeat;\\n  background-position: center;\\n  background-size: contain;\\n  border-radius: 10px;\\n  width: 50px;\\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\\n  cursor: pointer;\\n}\\n\\n.viewer-module-progress_cYjQJ {\\n  flex: none;\\n  font-size: 50px;\\n  color: black;\\n  z-index: 1;\\n  background: rgba(128,128,128,.5);\\n  padding: 20px;\\n  border-radius: 10px;\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n\\nbody {\\n  margin: 0;\\n}\\n\\nhtml { \\n  overflow: hidden; \\n}\\n&quot;,&quot;&quot;]),u.locals={fullScreen:&quot;viewer-module-fullScreen_bbk9Y&quot;,fullParentSize:&quot;viewer-module-fullParentSize_ETopO&quot;,bigFileDrop:&quot;viewer-module-bigFileDrop_aqCgh&quot;,progress:&quot;viewer-module-progress_cYjQJ&quot;},t.A=u},50:function(e,t,n){var r=n(853),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){&quot;use strict&quot;;var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d=&quot;&quot;.concat(c,&quot; &quot;).concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){&quot;use strict&quot;;var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error(&quot;Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.&quot;);r.appendChild(n)}},88:function(e){&quot;use strict&quot;;e.exports=function(e){var t=document.createElement(&quot;style&quot;);return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){&quot;use strict&quot;;e.exports=function(e){var t=n.nc;t&&e.setAttribute(&quot;nonce&quot;,t)}},893:function(e){&quot;use strict&quot;;e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r=&quot;&quot;;n.supports&&(r+=&quot;@supports (&quot;.concat(n.supports,&quot;) {&quot;)),n.media&&(r+=&quot;@media &quot;.concat(n.media,&quot; {&quot;));var o=void 0!==n.layer;o&&(r+=&quot;@layer&quot;.concat(n.layer.length>0?&quot; &quot;.concat(n.layer):&quot;&quot;,&quot; {&quot;)),r+=n.css,o&&(r+=&quot;}&quot;),n.media&&(r+=&quot;}&quot;),n.supports&&(r+=&quot;}&quot;);var a=n.sourceMap;a&&&quot;undefined&quot;!=typeof btoa&&(r+=&quot;\\n/*# sourceMappingURL=data:application/json;base64,&quot;.concat(btoa(unescape(encodeURIComponent(JSON.stringify(a)))),&quot; */&quot;)),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){&quot;use strict&quot;;e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){&quot;use strict&quot;;e.exports=n.p+&quot;138e7b1469f64156810a.jpg&quot;},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error(&quot;define cannot be used indirect&quot;)},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if(&quot;object&quot;==typeof globalThis)return globalThis;try{return this||new Function(&quot;return this&quot;)()}catch(e){if(&quot;object&quot;==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){&quot;undefined&quot;!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:&quot;Module&quot;}),Object.defineProperty(e,&quot;__esModule&quot;,{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p=&quot;&quot;,n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();\n<\/script>\n<script>\nvar container = document.querySelector('.content');\nvar base64Str = &quot;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&quot;;\n\nOfflineLocalView.load(container, { base64Str });\n<\/script>\n</body>\n</html>\n\" class=\"pyvista\" style=\"width: 1024px; height: 768px; border: 1px solid rgb(221,221,221);\"></iframe>"}}}, "version_major": 2, "version_minor": 0}
</script></section>
</section>
<hr class="docutils" />
<div class="admonition-download-this-example admonition">
<p class="admonition-title">Download this example</p>
<p>Download this example as a <a class="reference external" href="https://examples.aedt.docs.pyansys.com/version/dev/examples/low_frequency/motor/aedt_motor/pm_synchronous.ipynb">Jupyter Notebook</a>
or as a <a class="reference external" href="https://examples.aedt.docs.pyansys.com/version/dev/examples/low_frequency/motor/aedt_motor/pm_synchronous.py">Python script</a>.</p>
</div>


                </article>
              
              
              
              
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Perform-imports-and-define-constants">Perform imports and define constants</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-temporary-directory-and-download-files">Create temporary directory and download files</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-dictionaries">Initialize dictionaries</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definitions-for-th-stator,-rotor,-and-shaft">Initialize definitions for th stator, rotor, and shaft</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definitions-for-stator-windings">Initialize definitions for stator windings</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definitions-for-model-setup">Initialize definitions for model setup</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definitions-for-operational-machine">Initialize definitions for operational machine</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Launch-AEDT-and-Maxwell-2D">Launch AEDT and Maxwell 2D</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Define-modeler-units">Define modeler units</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Define-variables-from-dictionaries">Define variables from dictionaries</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Define-path-for-non-linear-material-properties">Define path for non-linear material properties</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-first-material">Create first material</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-materials-with-a-non-linear-permeability">Create materials with a non-linear permeability</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-geometry-for-stator">Create geometry for stator</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Assign-properties-to-stator">Assign properties to stator</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-outer-and-inner-PMs">Create outer and inner PMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-coordinate-system-for-PMs">Create coordinate system for PMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-coordinate-system-for-PMs-in-face-center">Create coordinate system for PMs in face center</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Duplicate-and-mirror-PMs">Duplicate and mirror PMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-coils">Create coils</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-shaft-and-region">Create shaft and region</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-bands">Create bands</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-list-of-vacuum-objects">Create list of vacuum objects</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-rotor">Create rotor</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-section-of-machine">Create section of machine</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-boundary-conditions">Create boundary conditions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Assign-vector-potential">Assign vector potential</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-excitations">Create excitations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Define-windings-in-phase-A">Define windings in phase A</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Define-windings-in-phase-B">Define windings in phase B</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Define-windings-in-phase-C">Define windings in phase C</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Assign-total-current-on-PMs">Assign total current on PMs</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-mesh-operations">Create mesh operations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Turn-on-core-loss">Turn on core loss</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Compute-transient-inductance">Compute transient inductance</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Set-model-depth">Set model depth</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Set-symmetry-factor">Set symmetry factor</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Assign-motion-setup-to-object">Assign motion setup to object</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-setup-and-validate">Create setup and validate</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definitions-for-output-variables">Initialize definitions for output variables</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-output-variables-for-postprocessing">Create output variables for postprocessing</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definition-for-postprocessing-plots">Initialize definition for postprocessing plots</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Initialize-definition-for-postprocessing-multiplots">Initialize definition for postprocessing multiplots</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-report.">Create report.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-multiplot-report">Create multiplot report</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Analyze-and-save-project">Analyze and save project</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Create-flux-lines-plot-on-region">Create flux lines plot on region</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Export-a-field-plot-to-an-image-file">Export a field plot to an image file</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Get-solution-data">Get solution data</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Retrieve-the-data-magnitude-of-an-expression">Retrieve the data magnitude of an expression</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Export-a-report-to-a-file">Export a report to a file</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Retrieve-the-data-values-of-Torque-within-a-time-range">Retrieve the data values of Torque within a time range</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Extract-the-torque-values-within-the-specified-time-range">Extract the torque values within the specified time range</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Release-AEDT">Release AEDT</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#Clean-up">Clean up</a></li>
</ul>
  </nav></div>

  <div class="sidebar-secondary-item"> 
<div class="tocsection editthispage">
  <a href="https://github.com/ansys/pyaedt-examples/edit/main/doc/source/examples/low_frequency/motor/aedt_motor/pm_synchronous.ipynb">
    <i class="fa-solid fa-pencil"></i>
       Edit
    on GitHub  
  </a>
</div>

</div>

  <div class="sidebar-secondary-item">

  <div class="tocsection sourcelink">
    <a href="../../../../_sources/examples/low_frequency/motor/aedt_motor/pm_synchronous.ipynb.txt">
      <i class="fa-solid fa-file-lines"></i> Show Source
    </a>
  </div>
</div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      Â© Copyright (c) 2021 - 2026 ANSYS, Inc. All rights reserved.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.0.2.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item"><p class="theme-version">
  Built with the
  <a href="https://sphinxdocs.ansys.com/version/stable/index.html"
    >Ansys Sphinx Theme</a
  >
  1.0.11. <br />Last updated on
  <span id="date"></span>
</p>
<script>
  var options = { day: "numeric", month: "long", year: "numeric" };
  var lastModifiedDate = new Date(document.lastModified);
  var date = lastModifiedDate.toLocaleDateString("en-US", options);
  document.getElementById("date").innerHTML = date;
</script></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>