{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "bcaee5b4",
   "metadata": {},
   "source": [
    "# Inductive iris waveguide filter\n",
    "\n",
    "This example shows how to build and analyze a four-pole\n",
    "X-Band waveguide filter using inductive irises.\n",
    "\n",
    "Keywords: **HFSS**, **modal**, **waveguide filter**."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bfe9c662",
   "metadata": {},
   "source": [
    "<img src=\"_static/wgf.png\" width=\"500\">"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "13ff835f",
   "metadata": {},
   "source": [
    "## Perform imports and define constants\n",
    "\n",
    "Perform required imports.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f00f3c67",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import tempfile\n",
    "import time\n",
    "\n",
    "import ansys.aedt.core"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1c27547c",
   "metadata": {},
   "source": [
    "Define constants."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "94e79c09",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "AEDT_VERSION = \"2025.2\"\n",
    "NUM_CORES = 4\n",
    "NG_MODE = False  # Open AEDT UI when it is launched."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ef592bf1",
   "metadata": {},
   "source": [
    "## Launch AEDT"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "36366944",
   "metadata": {},
   "source": [
    "### Define parameters and values for waveguide iris filter\n",
    "\n",
    "Define these parameters:"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "44b04d06",
   "metadata": {},
   "source": [
    "l: Length of the cavity from the mid-point of one iris\n",
    "   to the midpoint of the next iris\n",
    "\n",
    "w: Width of the iris opening\n",
    "\n",
    "a: Long dimension of the waveguide cross-section (X-Band)\n",
    "\n",
    "b: Short dimension of the waveguide cross-section\n",
    "\n",
    "t: Metal thickness of the iris insert"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "192b9bc2",
   "metadata": {},
   "outputs": [],
   "source": [
    "wgparams = {\n",
    "    \"l\": [0.7428, 0.82188],\n",
    "    \"w\": [0.50013, 0.3642, 0.3458],\n",
    "    \"a\": 0.4,\n",
    "    \"b\": 0.9,\n",
    "    \"t\": 0.15,\n",
    "    \"units\": \"in\",\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd577e6b",
   "metadata": {},
   "source": [
    "## Create temporary directory\n",
    "\n",
    "Create a temporary directory where downloaded data or\n",
    "dumped data can be stored.\n",
    "If you'd like to retrieve the project data for subsequent use,\n",
    "the temporary folder name is given by ``temp_folder.name``."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91ac7582",
   "metadata": {},
   "outputs": [],
   "source": [
    "temp_folder = tempfile.TemporaryDirectory(suffix=\".ansys\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "724eb2c4",
   "metadata": {},
   "source": [
    "### Create HFSS design"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bca4d5bd",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "outputs": [],
   "source": [
    "project_name = os.path.join(temp_folder.name, \"waveguide.aedt\")\n",
    "hfss = ansys.aedt.core.Hfss(\n",
    "    project=project_name,\n",
    "    version=AEDT_VERSION,\n",
    "    design=\"filter\",\n",
    "    solution_type=\"Modal\",\n",
    "    non_graphical=NG_MODE,\n",
    "    new_desktop=True,\n",
    "    close_on_exit=True,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e953f8f9",
   "metadata": {},
   "source": [
    "### Initialize design parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "231c6bf0",
   "metadata": {},
   "outputs": [],
   "source": [
    "hfss.modeler.model_units = \"in\"  # Set to inches\n",
    "var_mapping = dict()  # Used by parse_expr to parse expressions.\n",
    "for key in wgparams:\n",
    "    if type(wgparams[key]) in [int, float]:\n",
    "        hfss[key] = str(wgparams[key]) + wgparams[\"units\"]\n",
    "        var_mapping[key] = wgparams[key]  # Used for expression parsing.\n",
    "    elif type(wgparams[key]) == list:\n",
    "        count = 1\n",
    "        for v in wgparams[key]:\n",
    "            this_key = key + str(count)\n",
    "            hfss[this_key] = str(v) + wgparams[\"units\"]\n",
    "            var_mapping[\n",
    "                this_key\n",
    "            ] = v  # Used to parse expressions and generate numerical values.\n",
    "            count += 1\n",
    "\n",
    "if len(wgparams[\"l\"]) % 2 == 0:\n",
    "    zstart = \"-t/2\"  # Even number of cavities, odd number of irises.\n",
    "    is_even = True\n",
    "else:\n",
    "    zstart = \"l1/2 - t/2\"  # Odd number of cavities, even number of irises.\n",
    "    is_even = False"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "488e6563",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    "### Draw parametric waveguide filter\n",
    "\n",
    "Define a function to place each iris at the correct longitudinal (z) position,\n",
    "Loop from the largest index (interior of the filter) to 1, which is the first\n",
    "iris nearest the waveguide ports."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "97a443a2",
   "metadata": {},
   "outputs": [],
   "source": [
    "def place_iris(z_pos, dz, param_count):\n",
    "    w_str = \"w\" + str(param_count)  # Iris width parameter as a string.\n",
    "    this_name = \"iris_a_\" + str(param_count)  # Iris object name in the HFSS project.\n",
    "    iris_new = []  # Return a list of the two objects that make up the iris.\n",
    "    if this_name in hfss.modeler.object_names:\n",
    "        this_name = this_name.replace(\"a\", \"c\")\n",
    "    iris_new.append(\n",
    "        hfss.modeler.create_box(\n",
    "            [\"-b/2\", \"-a/2\", z_pos],\n",
    "            [\"(b - \" + w_str + \")/2\", \"a\", dz],\n",
    "            name=this_name,\n",
    "            material=\"silver\",\n",
    "        )\n",
    "    )\n",
    "    iris_new.append(iris_new[0].mirror([0, 0, 0], [1, 0, 0], duplicate=True))\n",
    "    return iris_new"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "85d3f889",
   "metadata": {},
   "source": [
    "### Place irises\n",
    "\n",
    "Place the irises from inner (highest integer) to outer."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4752858a",
   "metadata": {},
   "outputs": [],
   "source": [
    "zpos = zstart\n",
    "for count in reversed(range(1, len(wgparams[\"w\"]) + 1)):\n",
    "    if count < len(wgparams[\"w\"]):  # Update zpos\n",
    "        zpos = zpos + \"\".join([\" + l\" + str(count) + \" + \"])[:-3]\n",
    "        iris = place_iris(zpos, \"t\", count)\n",
    "        iris = place_iris(\"-(\" + zpos + \")\", \"-t\", count)\n",
    "\n",
    "    else:  # Place first iris\n",
    "        iris = place_iris(zpos, \"t\", count)\n",
    "        if not is_even:\n",
    "            iris = place_iris(\"-(\" + zpos + \")\", \"-t\", count)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c277e312",
   "metadata": {},
   "source": [
    "### Draw full waveguide with ports\n",
    "\n",
    "Use ``hfss.variable_manager``, which acts like a dictionary, to return an instance of\n",
    "the ``ansys.aedt.core.application.variables.VariableManager`` class for any variable.\n",
    "The ``VariableManager`` instance takes the HFSS variable name as a key.\n",
    "``VariableManager`` properties enable access to update, modify, and\n",
    "evaluate variables."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "10487d6c",
   "metadata": {},
   "outputs": [],
   "source": [
    "var_mapping[\"port_extension\"] = 1.5 * wgparams[\"l\"][0]\n",
    "hfss[\"port_extension\"] = str(var_mapping[\"port_extension\"]) + wgparams[\"units\"]\n",
    "hfss[\"wg_z_start\"] = \"-(\" + zpos + \") - port_extension\"\n",
    "hfss[\"wg_length\"] = \"2*(\" + zpos + \" + port_extension )\"\n",
    "wg_z_start = hfss.variable_manager[\"wg_z_start\"]\n",
    "wg_length = hfss.variable_manager[\"wg_length\"]\n",
    "hfss[\"u_start\"] = \"-a/2\"\n",
    "hfss[\"u_end\"] = \"a/2\"\n",
    "hfss.modeler.create_box(\n",
    "    [\"-b/2\", \"-a/2\", \"wg_z_start\"],\n",
    "    [\"b\", \"a\", \"wg_length\"],\n",
    "    name=\"waveguide\",\n",
    "    material=\"vacuum\",\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "290be939",
   "metadata": {},
   "source": [
    "### Draw the entire waveguide\n",
    "\n",
    "The variable ``# wg_z`` is the total length of the waveguide, including the port extension.\n",
    "Note that the ``.evaluated_value`` provides access to the numerical value of\n",
    "``wg_z_start``, which is an expression in HFSS."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27db6478",
   "metadata": {},
   "outputs": [],
   "source": [
    "wg_z = [\n",
    "    wg_z_start.evaluated_value,\n",
    "    hfss.value_with_units(wg_z_start.numeric_value + wg_length.numeric_value, \"in\"),\n",
    "]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "64155555",
   "metadata": {},
   "source": [
    "Assign wave ports to the end faces of the waveguide\n",
    "and define the calibration lines to ensure self-consistent\n",
    "polarization between wave ports."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "520e269a",
   "metadata": {},
   "outputs": [],
   "source": [
    "count = 0\n",
    "ports = []\n",
    "for n, z in enumerate(wg_z):\n",
    "    face_id = hfss.modeler.get_faceid_from_position([0, 0, z], assignment=\"waveguide\")\n",
    "    u_start = [0, hfss.variable_manager[\"u_start\"].evaluated_value, z]\n",
    "    u_end = [0, hfss.variable_manager[\"u_end\"].evaluated_value, z]\n",
    "\n",
    "    ports.append(\n",
    "        hfss.wave_port(\n",
    "            face_id,\n",
    "            integration_line=[u_start, u_end],\n",
    "            name=\"P\" + str(n + 1),\n",
    "            renormalize=False,\n",
    "        )\n",
    "    )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2c4d8527",
   "metadata": {},
   "source": [
    "### Insert mesh adaptation setup\n",
    "\n",
    "Insert a mesh adaptation setup using refinement at two frequencies.\n",
    "This approach is useful for resonant structures because the coarse initial\n",
    "mesh impacts the resonant frequency and, hence, the field propagation through the\n",
    "filter. Adaptation at multiple frequencies helps to ensure that energy propagates\n",
    "through the resonant structure while the mesh is refined."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "37f69d58",
   "metadata": {},
   "outputs": [],
   "source": [
    "setup = hfss.create_setup(\n",
    "    \"Setup1\",\n",
    "    setup_type=\"HFSSDriven\",\n",
    "    MultipleAdaptiveFreqsSetup=[\"9.8GHz\", \"10.2GHz\"],\n",
    "    MaximumPasses=5,\n",
    ")\n",
    "\n",
    "setup.create_frequency_sweep(\n",
    "    unit=\"GHz\",\n",
    "    name=\"Sweep1\",\n",
    "    start_frequency=9.5,\n",
    "    stop_frequency=10.5,\n",
    "    sweep_type=\"Interpolating\",\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f6dc63e5",
   "metadata": {
    "lines_to_next_cell": 2
   },
   "source": [
    " Solve the project with two tasks.\n",
    " Each frequency point is solved simultaneously."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "593aca94",
   "metadata": {},
   "outputs": [],
   "source": [
    "setup.analyze(cores=NUM_CORES)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a1a110a0",
   "metadata": {},
   "source": [
    "### Postprocess\n",
    "\n",
    " The following commands fetch solution data from HFSS for plotting directly\n",
    " from the Python interpreter.\n",
    "\n",
    " **Caution:** The syntax for expressions must be identical to that used\n",
    " in HFSS."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b2e36f3c",
   "metadata": {},
   "outputs": [],
   "source": [
    "traces_to_plot = hfss.get_traces_for_plot(second_element_filter=\"P1*\")\n",
    "report = hfss.post.create_report(traces_to_plot)  # Creates a report in HFSS\n",
    "solution = report.get_solution_data()\n",
    "\n",
    "plt = solution.plot(solution.expressions)  # Matplotlib axes object."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "326591d6",
   "metadata": {},
   "source": [
    " The following command generates a field plot in HFSS and uses PyVista\n",
    " to plot the field in Jupyter."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4f6979db",
   "metadata": {},
   "outputs": [],
   "source": [
    "plot = hfss.post.plot_field(\n",
    "    quantity=\"Mag_E\",\n",
    "    assignment=[\"Global:XZ\"],\n",
    "    plot_type=\"CutPlane\",\n",
    "    setup=hfss.nominal_adaptive,\n",
    "    intrinsics={\"Freq\": \"9.8GHz\", \"Phase\": \"0deg\"},\n",
    "    export_path=hfss.working_directory,\n",
    "    show=False,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2ae09573",
   "metadata": {},
   "source": [
    "## Release AEDT\n",
    "\n",
    " The following command saves the project to a file and closes AEDT."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d1b76151",
   "metadata": {},
   "outputs": [],
   "source": [
    "hfss.save_project()\n",
    "hfss.release_desktop()\n",
    "# Wait 3 seconds to allow AEDT to shut down before cleaning the temporary directory.\n",
    "time.sleep(3)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b50a7e85",
   "metadata": {},
   "source": [
    "## Clean up\n",
    "\n",
    "All project files are saved in the folder ``temp_folder.name``.\n",
    "If you've run this example as a Jupyter notebook, you\n",
    "can retrieve those project files. The following cell removes\n",
    "all temporary files, including the project folder."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f6a08856",
   "metadata": {},
   "outputs": [],
   "source": [
    "temp_folder.cleanup()"
   ]
  }
 ],
 "metadata": {
  "jupytext": {
   "cell_metadata_filter": "-all",
   "main_language": "python",
   "notebook_metadata_filter": "-all"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
